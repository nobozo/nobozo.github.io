<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="2"?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Pro Git</title>
<date>$$DATE$$</date>
<authorgroup>
<author>
<personname>
<firstname>Scott</firstname>
<surname>Chacon</surname>
</personname>
</author>
<author>
<personname>
<firstname>Ben</firstname>
<surname>Straub</surname>
</personname>
</author>
<author>
<personname>
<firstname>Jon</firstname>
<surname>Forrest</surname>
</personname>
</author>
</authorgroup>
<revhistory>
<revision>
<revnumber></revnumber>
<date>$$DATE$$</date>
<authorinitials>SC</authorinitials>
</revision>
</revhistory>
</info>
<preface xml:id="_license">
<title>License</title>
<simpara>This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
To view a copy of this license, visit <link xl:href="http://creativecommons.org/licenses/by-nc-sa/3.0/">http://creativecommons.org/licenses/by-nc-sa/3.0/</link> or send a
letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.</simpara>
</preface>
<preface xml:id="_preface_by_scott_chacon">
<title>Preface by Scott Chacon</title>
<simpara>Welcome to the second edition of Pro Git.
The first edition was published over four years ago now.
Since then a lot has changed and yet many important things have not.
While most of the core commands and concepts are still valid today as the Git core team is pretty fantastic at keeping things backward compatible, there have been some significant additions and changes in the community surrounding Git.
The second edition of this book is meant to address those changes and update the book so it can be more helpful to the new user.</simpara>
<simpara>When I wrote the first edition, Git was still a relatively difficult to use and barely adopted tool for the harder core hacker.
It was starting to gain steam in certain communities, but had not reached anywhere near the ubiquity it has today.
Since then, nearly every open source community has adopted it.
Git has made incredible progress on Windows, in the explosion of graphical user interfaces to it for all platforms, in IDE support and in business use.
The Pro Git of four years ago knows about none of that.
One of the main aims of this new edition is to touch on all of those new frontiers in the Git community.</simpara>
<simpara>The Open Source community using Git has also exploded.
When I originally sat down to write the book nearly five years ago (it took me a while to get the first version out), I had just started working at a very little known company developing a Git hosting website called GitHub.
At the time of publishing there were maybe a few thousand people using the site and just four of us working on it.
As I write this introduction, GitHub is announcing our 10 millionth hosted project, with nearly 5 million registered developer accounts and over 230 employees.
Love it or hate it, GitHub has heavily changed large swaths of the Open Source community in a way that was barely conceivable when I sat down to write the first edition.</simpara>
<simpara>I wrote a small section in the original version of Pro Git about GitHub as an example of hosted Git which I was never very comfortable with.
I didn&#8217;t much like that I was writing what I felt was essentially a community resource and also talking about my company in it.
While I still don&#8217;t love that conflict of interests, the importance of GitHub in the Git community is unavoidable.
Instead of an example of Git hosting, I have decided to turn that part of the book into more deeply describing what GitHub is and how to effectively use it.
If you are going to learn how to use Git then knowing how to use GitHub will help you take part in a huge community, which is valuable no matter which Git host you decide to use for your own code.</simpara>
<simpara>The other large change in the time since the last publishing has been the development and rise of the HTTP protocol for Git network transactions. Most of the examples in the book have been changed to HTTP from SSH because it&#8217;s so much simpler.</simpara>
<simpara>It&#8217;s been amazing to watch Git grow over the past few years from a relatively obscure version control system to basically dominating commercial and open source version control. I&#8217;m happy that Pro Git has done so well and has also been able to be one of the few technical books on the market that is both quite successful and fully open source.</simpara>
<simpara>I hope you enjoy this updated edition of Pro Git.</simpara>
</preface>
<preface xml:id="_preface_by_ben_straub">
<title>Preface by Ben Straub</title>
<simpara>The first edition of this book is what got me hooked on Git. This was my introduction to a style of making software that felt more natural than anything I had seen before. I had been a developer for several years by then, but this was the right turn that sent me down a much more interesting path than the one I was on.</simpara>
<simpara>Now, years later, I&#8217;m a contributor to a major Git implementation, I&#8217;ve worked for the largest Git hosting company, and I&#8217;ve traveled the world teaching people about Git. When Scott asked if I&#8217;d be interested in working on the second edition, I didn&#8217;t even have to think.</simpara>
<simpara>It&#8217;s been a great pleasure and privilege to work on this book. I hope it helps you as much as it did me.</simpara>
</preface>
<preface xml:id="_preface_by_jon_forrest">
<title>Preface by Jon Forrest</title>
<simpara>First of all, I want to make it clear that I didn’t write this book. This is Scott Chacon and Ben Straub&#8217;s book,
which they released under a Creative Commons Attribution Non Commercial Share Alike 3.0 license.
All I did was edit it. I’m distinguishing the original book from this edited version by calling
this version Pro Git Reedited Second Edition. Naturally, I’m releasing it under that same Creative Commons license.</simpara>
<simpara>When I started learning Git, I spent a fair amount of time reading the first edition of Pro Git.
I found that it was a 2 step forward, 1 step back experience. By this I mean I’d learn a couple
of new things but then I’d either read something I didn’t understand, or else I’d realize that my
previous understanding was wrong. But, once I developed a better understanding of Git, I went back
to re-read the sections that I didn’t previously understand. I’d almost always think to myself that
if only this word or that phrase could be changed slightly, the concept would have been much easier
to understand. This happens to me a lot when reading technical books.</simpara>
<simpara>Given that Scott and Ben were generous enough to release Pro Git Second Edition as a free book with
the manuscript sources available at GitHub, I decided to return the favor by doing a complete edit
in an attempt to improve the areas I had trouble with and to generally tighten up the text.</simpara>
<simpara>It’s crystal clear that Scott and Ben know more about Git than I’ll ever know.
Plus, I&#8217;m the first to admit that I&#8217;m no Git expert.
For these reasons, I didn’t even attempt to find technical errors in the text or in the examples.
What I did instead was to go over each paragraph, one by one, asking myself if I really understood what it
was saying, and whether I could change it into something clearer. As a result, I made a lot of changes.
Most of these I’d have a hard time defending because they’re very subjective.
In fact, it might turn out that I’m overly sensitive and that everybody else is already satisfied with
Pro Git Second Edition.
If you fall into this category then you probably won&#8217;t find much value in this edition.
Also, in my efforts to achieve clarity I might have gone too far,
and accidentally changed something to be just plain wrong. I’m entirely responsible for any such errors.
Please point out any errors and ways to make things even clearer. I intend to keep this book updated
with the results of your input.</simpara>
<simpara>Unless I’ve made a serious mistake in judgment, I think that Pro Git Reedited Second Edition can replace Pro Git Second Edition for English readers.
I’m not sure whether it’s worth translating this edition into other languages.
In fact, I’d like to think of it as simply a collection of English-specific
edits that can be ignored in other languages.</simpara>
<simpara>I welcome your feedback. Please open an issue on <link xl:href="https://github.com/nobozo/progit2">https://github.com/nobozo/progit2</link>
with any comments or errors.</simpara>
</preface>
<dedication xml:id="_dedications">
<title>Dedications</title>
<simpara><emphasis>To my wife, Becky, without whom this adventure never would have begun. — Ben</emphasis></simpara>
<simpara><emphasis>This edition is dedicated to my girls.
To my wife Jessica who has supported me for all of these years and to my daughter Josephine,
who will support me when I&#8217;m too old to know what&#8217;s going on. — Scott</emphasis></simpara>
<simpara><emphasis>To Anne, Leah, Thyme (RIP), and Athena. — Jon</emphasis></simpara>
</dedication>
<preface xml:id="_contributors">
<title>Contributors</title>
<simpara>Since this is an Open Source book, we have gotten several errata and content changes donated over the years. Here are all the people who have contributed to the English version of Pro Git as an open source project. Thank you everyone for helping make this a better book for everyone.</simpara>
<screen>4wk-                            Joris Valette                   Shengbin Meng
Adrien Ollier                   Joshua Webb                     Siarhei Krukau
Akrom K                         Justin Clift                    Skyper
Aleh Suprunovich                Kaartic Sivaraam                Snehal Shekatkar
Alexander Bezzubov              Kausar Mehmood                  Song Li
Alexandre Garnier               Kenneth Kin Lum                 Stephan van Maris
Andrei Dascalu                  Klaus Frank                     Steven Roddis
Andrew MacFie                   Kristijan "Fremen" Velkovski    SudarsanGP
Andrew Metcalf                  Krzysztof Szumny                Sven Selberg
Andrew Murphy                   Kyrylo Yatsenko                 Thanix
AndyGee                         Lars Vogel                      Thomas Ackermann
AnneTheAgile                    Laxman                          Thomas Hartmann
Anthony Loiseau                 Lazar95                         Tom Schady
Anton Trunov                    Leonard Laszlo                  Tomoki Aonuma
Antonello Piemonte              Linus Heckemann                 Tvirus
Antonino Ingargiola             Logan Hasson                    Tyler Cipriani
Atul Varma                      Louise Corrigan                 Vadim Markovtsev
Ben Sima                        Luc Morin                       Vangelis Katsikaros
Benjamin Dopplinger             Lukas Röllin                    Victor Ma
Borek Bernard                   Marcin Sędłak-Jakubowski        Vitaly Kuznetsov
Brett Cannon                    Marius Žilėnas                  William Gathoye
Buzut                           Markus KARG                     William Turrell
C Nguyen                        Marti Bolivar                   Wlodek Bzyl
Cadel Watson                    Mashrur Mia (Sa'ad)             Yann Soubeyrand
Carlos Martín Nieto             Masood Fallahpoor               Yue Lin Ho
Chaitanya Gurrapu               Mathieu Dubreuilh               Yunhai Luo
Changwoo Park                   Matthew Miner                   Yusuke SATO
Christoph Prokop                Matthieu Moy                    alex-koziell
Christopher Wilson              Michael MacAskill               allen joslin
Cory Donnelly                   Michael Sheaver                 atalakam
Cullen Rhodes                   Michael Welch                   axmbo
Cyril                           Michiel van der Wulp            brotherben
Damien Tournoud                 Mike Charles                    delta4d
Dan Schmidt                     Mike Pennisi                    devwebcl
Daniel Shahaf                   Mike Thibodeau                  dualsky
Daniel Sturm                    Niels Widger                    evanderiel
Daniele Tricoli                 Nils Reuße                      eyherabh
Danny Lin                       Owen                            flip111
David Rogers                    Pablo Schläpfer                 flyingzumwalt
Davide Angelocola               Pascal Berger                   goekboet
Denis Savitskiy                 Pascal Borreli                  grgbnc
DiamondeX                       Patrick Steinhardt              haripetrov
Dino Karic                      Pavel Janík                     i-give-up
Dmitri Tikhonov                 Paweł Krupiński                 iprok
Duncan Dean                     Peter Kokot                     jingsam
Eden Hochbaum                   Phil Mitchell                   johnhar
Eric Henziger                   Philippe Miossec                maks
Explorare                       Rafi                            mmikeww
Felix Nehrke                    Raphael R                       mosdalsvsocld
Fornost461                      Ray Chen                        nicktime
Frederico Mazzone               Reza Ahmadi                     patrick96
Frej Drejhammar                 Richard Hoyle                   paveljanik
Guthrie McAfee Armstrong        Ricky Senft                     pedrorijo91
HairyFotr                       Rintze M. Zelle                 peterwwillis
Hamidreza Mahdavipanah          Rob Blanco                      petsuter
Haruo Nakayama                  Robert P. Goldman               rahrah
Helmut K. C. Tessarek           Robert P. J. Day                rmzelle
Howard                          Rohan D'Souza                   root
Ignacy                          Roman Kosenko                   sanders@oreilly.com
Ilker Cat                       Ronald Wampler                  spacewander
Jan Groenewald                  Rüdiger Herrmann                td2014
Jaswinder Singh                 SATO Yusuke                     twekberg
Jean-Noël Avila                 Sam Ford                        uerdogan
Jeroen Oortwijn                 Sam Joseph                      un1versal
Jim Hill                        Sanders Kleinfeld               xJom
Joel Davies                     Sarah Schneider                 xtreak
Johannes Dewender               Saurav Sachidanand              yakirwin
Johannes Schindelin             Scott Bronson                   zwPapEr
Jon Forrest                     Sean Head                       ᐯᕮᒪᗝᑕᕮᒣ
Jon Freed                       Sebastian Krause                狄卢
Jordan Hayashi                  Severino Lorilla Jr</screen>
</preface>
<preface xml:id="_introduction">
<title>Introduction</title>
<simpara>You’re about to spend several hours of your life reading about Git. Let’s take a minute to explain
what we have in store for you. Here&#8217;s a quick summary of the ten chapters and three appendices in this book.</simpara>
<simpara><emphasis role="strong">Chapter 1</emphasis> covers Version Control Systems (VCSs) and Git basics&#8201;&#8212;&#8201;no
technical stuff, just what Git is, why it came about in a land full of VCSs, what sets it apart
from other VCSs, and why so many people use it. Then, this chapter explains how to download Git
and set it up for the first time if you don’t already have it on your system.</simpara>
<simpara><emphasis role="strong">Chapter 2</emphasis> goes over basic Git usage&#8201;&#8212;&#8201;how to use Git in 80% of the situations you
encounter most often. After reading this chapter, you should be able to clone a repository, see
the history of a project, modify files, and contribute changes.</simpara>
<simpara><emphasis role="strong">Chapter 3</emphasis> is about the branching model in Git, often described as Git’s killer feature. Here
you learn what truly sets Git apart from the pack. When you’re done, you may feel the need to
spend a quiet moment pondering how you lived before Git branching was part of your life.</simpara>
<simpara><emphasis role="strong">Chapter 4</emphasis> covers Git on the server. This chapter is for those of you who want to install Git
inside your organization or on your own personal server. We also explore
various hosted options if you prefer to let someone else handle that for you.</simpara>
<simpara><emphasis role="strong">Chapter 5</emphasis> goes over in full detail various distributed workflows and how to accomplish
them with Git. When you&#8217;re done with this chapter, you should be able to work expertly with
multiple remote repositories, use Git over email, and deftly juggle numerous remote branches
and contributed patches.</simpara>
<simpara><emphasis role="strong">Chapter 6</emphasis> covers the GitHub hosting service and tooling in depth. We discuss signing
up for and managing a GitHub account, creating and using Git repositories,
common workflows to contribute to projects and to accept contributions to your own projects,
GitHub&#8217;s programmatic interface, and lots of little tips to make your life easier.</simpara>
<simpara><emphasis role="strong">Chapter 7</emphasis> is about advanced Git commands. Here you learn about topics like mastering the
scary <emphasis>reset</emphasis> command, using binary search to identify bugs, editing history, revision selection in detail,
and lots  more. This chapter rounds out your knowledge of Git so that you&#8217;re truly a master.</simpara>
<simpara><emphasis role="strong">Chapter 8</emphasis> is about configuring your custom Git environment. This includes setting up hook
scripts to enforce or encourage customized policies and using environment configuration settings
so you can work the way you want. We also cover building your own set of scripts to
enforce a custom committing policy.</simpara>
<simpara><emphasis role="strong">Chapter 9</emphasis> deals with Git with other VCSs. This includes using Git in a Subversion (SVN) world
and converting projects from other VCSs to Git. A lot of organizations still use SVN and are
not about to change, but by this point you’ll have learned the incredible power of Git. This
chapter shows how to cope if you still have to use SVN. We also cover how to
import projects from several other VCSs in case you do convince everyone to make the
plunge.</simpara>
<simpara><emphasis role="strong">Chapter 10</emphasis> dives into the murky yet beautiful depths of Git internals. Now that you know all
about Git and can wield it with power and grace, you can move on to learn how Git stores the objects it manages,
what the object model is, details of packfiles, server protocols, and more. Throughout the book,
we refer to sections of this chapter in case you feel like diving in deep early.
But, if you&#8217;re like us and want to dive into the technical details, you may want to read Chapter 10 first.
We leave that to you.</simpara>
<simpara><emphasis role="strong">Appendix A</emphasis> looks at a number of examples of using Git in various specific environments. We cover
a number of different GUIs and IDEs that you may want to use with Git.
If you&#8217;re interested in an overview of using Git in your shell, in Visual Studio,
or Eclipse, look here.</simpara>
<simpara>Finally, <emphasis role="strong">Appendix B</emphasis> explores scripting and extending Git through tools like libgit2 and JGit. If you&#8217;re
interested in writing complex and fast custom tools that need low-level Git access, this shows you
what&#8217;s available.</simpara>
<simpara>Let’s get started.</simpara>
</preface>
<chapter xml:id="ch01-getting-started">
<title>Getting Started</title>
<simpara>This chapter is about getting started with Git.
It starts by providing some background on VCSs, moves on to describe how to install Git,
and finishes with how to get started using Git.
By the end of this chapter you should understand why Git exists and, more importantly, why you should use it.</simpara>
<section xml:id="_about_version_control">
<title>About Version Control</title>
<simpara><indexterm>
<primary>version control</primary>
</indexterm>
What is <literal>version control</literal>, and why should you care?
Version control is a way to record changes to files over time.
Using version control, you can revert a file or an entire project back to a previous version, review changes
made over time, see who made a change that might be causing a problem, and more.  Even though the examples in
this book use version control to manage files containing computer source code, in reality you can use version
control to manage any type of file.</simpara>
<note>
<simpara>The word <literal>project</literal> is used throughout this book without being formally defined. Just think of a project as a
collection of files. For example, all the files used to create this book are a project.</simpara>
</note>
<section xml:id="_local_version_control_systems">
<title>Local Version Control Systems</title>
<simpara><indexterm>
<primary>version control</primary><secondary>local</secondary>
</indexterm>
<indexterm>
<primary>local</primary>
</indexterm>
One popular way to do version control is to copy files into a backup directory (perhaps with a name cleverly
containing a version number or the current date and time) each time you make a change.
This approach is very common because it&#8217;s so simple, but it&#8217;s also incredibly error prone.
It&#8217;s easy to forget which directory you should be using and accidentally copy a file
into the wrong directory.</simpara>
<simpara>To deal with this issue, programmers long ago developed VCSs based on the concept
of a simple repository containing all the changes to their files.</simpara>
<note>
<simpara>This book uses the terms <literal>database</literal> and <literal>repository</literal> interchangeably.</simpara>
</note>
<figure>
<title>Local version control.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/local.png"/>
</imageobject>
<textobject><phrase>Local version control diagram</phrase></textobject>
</mediaobject>
</figure>
<simpara>One popular VCS is called RCS, which is still distributed with many computers today.
RCS works by storing the differences between files. It can then re-create any file at any point in time
by re-applying changes.</simpara>
</section>
<section xml:id="_centralized_version_control_systems">
<title>Centralized Version Control Systems</title>
<simpara><indexterm>
<primary>version control</primary><secondary>centralized</secondary>
</indexterm>
<indexterm>
<primary>centralized</primary>
</indexterm>
The next major issue VCSs attack is how to make it possible for developers using their own computers to collaborate.
To solve this problem, Centralized Version Control Systems (CVCSs) were created.
These systems, such as CVS, Subversion, and Perforce, rely on a repository stored
on a single central server.
Clients check files in to and out of that central server. <indexterm>
<primary>CVS</primary>
</indexterm><indexterm>
<primary>Subversion</primary>
</indexterm><indexterm>
<primary>Perforce</primary>
</indexterm>
This has been the standard way of doing version control for many years.</simpara>
<figure>
<title>Centralized version control.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/centralized.png"/>
</imageobject>
<textobject><phrase>Centralized version control diagram</phrase></textobject>
</mediaobject>
</figure>
<simpara>This approach offers many advantages over local VCSs.
For example, everyone can see what everyone else on the project has done.
Administrators can control who can do what, and it&#8217;s far easier to administer a CVCS than it is to deal with
VCSs on every client.</simpara>
<simpara>However, this approach also has some serious downsides.
The most obvious is the single point of failure that the centralized server presents.
If that server goes down for an hour, then nobody can collaborate or check in changes
during that time.
If the disk storing the repository breaks, and proper backups haven&#8217;t been kept,
you lose the entire history of the project and all its files except whatever copies people happen to
have on their local computers.
Local VCS systems suffer from this same problem. Whenever you have the entire history of a project
in a single place, you risk losing everything.</simpara>
</section>
<section xml:id="_distributed_version_control_systems">
<title>Distributed Version Control Systems</title>
<simpara><indexterm>
<primary>version control</primary><secondary>distributed</secondary>
</indexterm>
<indexterm>
<primary>distributed</primary>
</indexterm>
This is where Distributed Version Control Systems (DVCSs) step in.
In a DVCS (such as Git, Mercurial, Bazaar, or Darcs), clients don&#8217;t just check out files.
Rather, they fully mirror the repository on their local disk.
Each client then contains a complete copy of the repository.</simpara>
<figure>
<title>Distributed version control.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/distributed.png"/>
</imageobject>
<textobject><phrase>Distributed version control diagram</phrase></textobject>
</mediaobject>
</figure>
<simpara>Furthermore, DVCSs make it easy to access remote repositories, allowing collaboration between people
working simultaneously on the same project.
This allows doing things in ways that aren&#8217;t possible with CVCSs.
Of course, there&#8217;s now a new problem, which is how to keep the various repositories in sync, which
is something that a DVCS must be able to solve.</simpara>
</section>
</section>
<section xml:id="_a_short_history_of_git">
<title>A Short History of Git</title>
<simpara>As with many great things in life, Git began with a bit of creative destruction and fiery controversy.</simpara>
<simpara>The Linux kernel is an open source software project of fairly large scope.<indexterm>
<primary>Linux</primary>
</indexterm>
For most of the lifetime of the Linux kernel from 1991 through 2002, changes ware were passed around
as patches and archived files.
In 2002, the Linux kernel project began using a proprietary DVCS called BitKeeper, which the project was allowed to use free-of-charge.<indexterm>
<primary>BitKeeper</primary>
</indexterm></simpara>
<simpara>In 2005, the relationship between the Linux kernel developers and the commercial company that developed
BitKeeper broke down, and the tool&#8217;s free-of-charge status was revoked.
This prompted the Linux development community (and in particular Linus Torvalds, the creator of Linux)
to develop their own tool based on some of the lessons they learned while using BitKeeper.<indexterm>
<primary>Linus Torvalds</primary>
</indexterm>
Some of the goals of the new system were</simpara>
<itemizedlist>
<listitem>
<simpara>Speed</simpara>
</listitem>
<listitem>
<simpara>Simple design</simpara>
</listitem>
<listitem>
<simpara>Strong support for non-linear development (thousands of parallel branches)</simpara>
</listitem>
<listitem>
<simpara>Fully distributed</simpara>
</listitem>
<listitem>
<simpara>Able to handle large projects like the Linux kernel efficiently (speed and data size)</simpara>
</listitem>
</itemizedlist>
<simpara>Since its birth in 2005, Git has evolved and matured to be easy to use and yet retains these initial qualities.
It&#8217;s amazingly fast, very efficient with large projects, and has an incredible branching system for
non-linear development (See <xref linkend="ch03-git-branching"/>).</simpara>
</section>
<section xml:id="_git_basics">
<title>Git Basics</title>
<simpara>So, what is Git?
This is an important question, because if you understand what Git is and the fundamentals of how it works, then using it effectively is much easier.
As you learn Git, try to clear your mind of the things you may know about other VCSs, such as Subversion and Perforce. This helps avoid subtle confusion.
Git stores and thinks about information much differently than these other systems,
even though the user interface is similar. Understanding those differences is crucial.<indexterm>
<primary>Subversion</primary>
</indexterm><indexterm>
<primary>Perforce</primary>
</indexterm></simpara>
<section xml:id="_snapshots_not_differences">
<title>Snapshots, Not Differences</title>
<simpara>The major difference between Git and other VCSs is the way Git records changes to files.
Conceptually, most other VCSs store a set of files along with the changes made to each file over time.
This is commonly called <emphasis>delta-based</emphasis> version control.</simpara>
<figure>
<title>Storing data as changes to a base version of each file.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/deltas.png"/>
</imageobject>
<textobject><phrase>Storing data as changes to a base version of each file.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Git employs a different approach.
Instead, Git stores what&#8217;s more like a set of copies of your project.
Every time you save the state of your project in Git, Git basically stores a "snapshot" of what <emphasis>all</emphasis> your files looked like at that moment.
This is called a <emphasis>commit</emphasis>.
For efficiency, if a file hasn&#8217;t changed since the last commit was made,
Git doesn&#8217;t actually store the file again. Instead, Git creates a link to the previous identical version it already contains.</simpara>
<figure>
<title>Storing data as snapshots of the project over time.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/snapshots.png"/>
</imageobject>
<textobject><phrase>Git stores data as snapshots of the project over time.</phrase></textobject>
</mediaobject>
</figure>
<simpara>(The dotted ovals in this picture represent links to unchanged file versions.)</simpara>
<simpara>This is an important distinction between Git and nearly all other VCSs.
Git reimplements almost every aspect of version control, but does so in a way that reflects this new approach.
We explore some of the benefits you gain from this approach when we cover Git branching in <xref linkend="ch03-git-branching"/>.</simpara>
</section>
<section xml:id="_all_repositories_are_technically_equivalent">
<title>All Repositories Are Technically Equivalent</title>
<simpara>The illustration in Figure 3 is actually misleading in that it labels one computer specifically as a server.
A major difference between Git and other systems is that technically there’s no difference
between the copies of the repositories located on servers or on developers' computers.
The fact that one repository is designated as the official project repository is a management decision,
not a technical distinction. Sure, it means that all changes must somehow be synced to the chosen official repository,
and eventually to the repositories on developer&#8217;s computers. Fortunately, as you&#8217;ll see, Git is very good at
doing this. But the point is that there&#8217;s no way to recognize that a particular repository
is the official project repository simply by looking at it.</simpara>
</section>
<section xml:id="_nearly_every_operation_is_local">
<title>Nearly Every Operation Is Local</title>
<simpara>Most operations in Git only access local repositories. Generally nothing is needed from another computer.
If you&#8217;re used to a CVCS where most operations require network access, this feature of Git makes you
think that the gods of speed have blessed Git with unworldly powers.
Because you have the entire project history right there on your local disk, most operations seem almost instantaneous.</simpara>
<simpara>For example, to browse the history of a project, Git doesn&#8217;t need to access a remote server.
It simply reads the history directly from the local repository.
This means you see the project history almost instantly.
To see the changes between the current version of a file and the version from a month ago,
Git retrieves both versions from the local repository and compares them on the local computer,
instead of either having to ask a remote server to do it or fetching an older version of
the file from a remote server.</simpara>
<simpara>This also means that there&#8217;s very little you can&#8217;t do while offline.
If you&#8217;re without internet access on an airplane or a train and want to do a little work,
you can do so happily until you get back online.
If you&#8217;re at home and your internet connection goes down, you can still work.
With many other systems, it’s either impossible or painful to get any work done when you’re offline.
In Perforce, for example, you can&#8217;t do much when you aren&#8217;t connected to the server.
In Subversion and CVS, you can edit files, but you can&#8217;t commit changes while the repository is inaccessible.
This may not seem like a huge deal, but you&#8217;d be surprised what a big difference it can make.</simpara>
</section>
<section xml:id="_git_has_integrity">
<title>Git Has Integrity</title>
<simpara>When making a commit, the content of what you&#8217;re committing is
checksummed before it&#8217;s stored, and the checksum itself is stored in the
repository along with what you committed.
This means it&#8217;s impossible to change the content of anything in a repository without Git noticing.
This behavior is built into Git at the lowest levels and is integral to its philosophy.
You can&#8217;t lose information in transit or experience file corruption without Git detecting it.</simpara>
<simpara>The mechanism that Git uses for this checksumming is called an SHA-1 hash.<indexterm>
<primary>SHA-1</primary>
</indexterm>
This is a 40-character string composed of hexadecimal characters (0-9 and a-f), and is calculated based
on the content of a file or directory. An SHA-1 hash looks something like</simpara>
<screen>24b9da6552252987aa493b52f8696cd6d3b00373</screen>
<simpara>You see these SHA-1 hashes all over the place in Git because they&#8217;re used so much.
In fact, Git stores everything in its repository not by filename but by the SHA-1 hash of its content.
The only way to reference a file is by that hash.</simpara>
</section>
<section xml:id="_git_generally_only_adds_data">
<title>Git Generally Only Adds Data</title>
<simpara>When you make changes in Git, you almost always only add to a Git repository.
It&#8217;s hard to get Git to do anything that&#8217;s not undoable or that erases data.
As in any VCS, you can lose or mess up changes you haven&#8217;t committed yet.
But after you commit a change in Git, it&#8217;s very difficult to lose.</simpara>
<simpara>This makes using Git a joy because we know we can experiment without any danger of severely screwing things up.
For a more in-depth look at how Git stores data and how to recover seemingly lost data, see <xref linkend="_undoing"/>.</simpara>
</section>
<section xml:id="_three_important_locations">
<title>Three Important Locations</title>
<simpara>Now it&#8217;s time to become familiar with the three places that you need to be aware of when working with Git.
These are the working directory, the staging area, and the Git repository.</simpara>
<note>
<simpara>This book uses the term <literal>working directory</literal> instead of the longer but more
accurate <literal>working directory tree</literal>. Your project can have as many levels of
directories as you need.</simpara>
</note>
<figure>
<title>Working directory, staging area, and Git repository.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/areas.png"/>
</imageobject>
<textobject><phrase>Working directory, staging area, and Git directory.</phrase></textobject>
</mediaobject>
</figure>
<simpara>The working directory contains a copy of one version of a project,
and is where you make changes.</simpara>
<simpara>The staging area stores what will be saved
when you make your next commit. More information about what it means to make a commit
appears below.
The staging area is sometimes referred to as the "index" or as the "cache".</simpara>
<simpara>The .git directory is where the Git repository for your project is stored.
This is the most important part of Git, and it&#8217;s what&#8217;s copied when you copy, or <emphasis>clone</emphasis>,
a repository from another computer.</simpara>
</section>
<section xml:id="_three_important_states">
<title>Three Important States</title>
<simpara>Git sees each file in one of three states: <emphasis>committed</emphasis>, <emphasis>modified</emphasis>, or <emphasis>staged</emphasis>.
Committed means that the file is safely stored in the Git repository.
Modified means that the file has been changed in the working directory since
the last commit but hasn&#8217;t been copied into the staging area yet.
Staged means that the current version of the file in the working directory has been copied into the staging area.</simpara>
<simpara>The basic Git workflow goes something like</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Checkout or create files in the working directory.</simpara>
</listitem>
<listitem>
<simpara>Modify files in the working directory.</simpara>
</listitem>
<listitem>
<simpara>Stage the files.</simpara>
</listitem>
<listitem>
<simpara>Make a commit.</simpara>
</listitem>
</orderedlist>
<simpara>In <xref linkend="ch02-git-basics-chapter"/>, you learn more about these states.</simpara>
</section>
</section>
<section xml:id="_the_command_line">
<title>The Command Line</title>
<simpara>There are several ways to use Git&#8201;&#8212;&#8201;on the command line or using a graphical user interface (GUI).
In this book, we use Git on the command line.
One reason for this is that the command line is the only place where you can run <emphasis>all</emphasis> Git commands&#8201;&#8212;&#8201;most GUIs only implement a subset of Git.
If you know how to run Git on the command line, you can probably also figure out how to use it from a GUI, while the opposite isn&#8217;t necessarily true.
Also, while your choice of GUI is a matter of personal taste, the command-line tools are available to <emphasis>all</emphasis> users.</simpara>
<simpara>So we expect you to know how to open Terminal in Mac, Command Prompt or Powershell in Windows,
or Xterm or equivalent in Linux.
If you don&#8217;t know what we&#8217;re talking about, you need to figure this out so that you can follow the rest of the examples in this book.</simpara>
</section>
<section xml:id="_installing_git">
<title>Installing Git</title>
<simpara>Before you start using Git, you have to install it.
Even if it&#8217;s already installed, it&#8217;s probably a good idea to update to the latest version.
You can either install it as a package or download the source code and build it yourself.</simpara>
<note>
<simpara>This book was written using Git version <emphasis role="strong">2.8.0</emphasis>. Though most of the commands we use should work in older versions,
some might not or might work slightly differently on an older version.
Since Git is quite excellent at preserving backwards compatibility, any version after 2.0 should work just fine.</simpara>
</note>
<section xml:id="_installing_on_linux">
<title>Installing on Linux</title>
<simpara><indexterm>
<primary>Linux</primary><secondary>installing</secondary>
</indexterm>
<indexterm>
<primary>installing</primary>
</indexterm>
To install Git on Linux, you can generally run the package-management tool that comes with your Linux distribution.</simpara>
<simpara>If you&#8217;re on RedHat or CentOS, run <literal>yum</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo yum install git-all</programlisting>
<simpara>If you&#8217;re on Fedora, run <literal>dnf</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo dnf install git-all</programlisting>
<simpara>If you&#8217;re on a Debian-based distribution, such as Ubuntu, run <literal>apt-get</literal>:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo apt-get install git-all</programlisting>
<simpara>There are instructions for installing on other Linux and Unix flavors on the Git website <link xl:href="http://git-scm.com/download/linux">http://git-scm.com/download/linux</link>.</simpara>
</section>
<section xml:id="_installing_on_mac">
<title>Installing on Mac</title>
<simpara><indexterm>
<primary>Mac</primary><secondary>installing</secondary>
</indexterm>
<indexterm>
<primary>installing</primary>
</indexterm>
There are several ways to install Git on a Mac.
The easiest is probably to install the Xcode command line tools.<indexterm>
<primary>Xcode</primary>
</indexterm>
On Mavericks (10.9) and above simply run <emphasis>git</emphasis> from the Terminal.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git --version</programlisting>
<simpara>If you don&#8217;t have Git installed already, you&#8217;ll be prompted to install it.</simpara>
<simpara>To run a more up to date version, install it using an installer
available for download at the Git website <link xl:href="http://git-scm.com/download/mac">http://git-scm.com/download/mac</link>.</simpara>
<figure>
<title>Git OS X Installer.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/git-osx-installer.png"/>
</imageobject>
<textobject><phrase>Git macOS installer.</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can also install Git as part of the GitHub for Mac package.
Their GUI Git tool has an option to install the Git command line tools as well.
Download that package from the GitHub for Mac website <link xl:href="http://mac.github.com">http://mac.github.com</link>.</simpara>
</section>
<section xml:id="_installing_on_windows">
<title>Installing on Windows</title>
<simpara>There are several ways to install Git on Windows.<indexterm>
<primary>Windows</primary><secondary>installing</secondary>
</indexterm>
<indexterm>
<primary>installing</primary>
</indexterm>
The most popular is to install the version that&#8217;s available for download on the Git website.
Just go to <link xl:href="http://git-scm.com/download/win">http://git-scm.com/download/win</link> and the download starts automatically.
Note that this is a project called Git for Windows, which is separate from Git itself.
For more information, go to <link xl:href="http://git-for-windows.github.io/">http://git-for-windows.github.io/</link>.</simpara>
<simpara>Another easy way to run Git is by installing GitHub for Windows.
The installer includes the command line version of Git as well as a GUI.
It also works well with Powershell, and sets up solid credential caching and sane
CRLF settings.<indexterm>
<primary>Powershell</primary>
</indexterm><indexterm>
<primary>CRLF</primary>
</indexterm><indexterm>
<primary>credential caching</primary>
</indexterm>
We describe those things more a little later, but suffice it to say they&#8217;re what you want.
Download this package from the GitHub for Windows website at <link xl:href="http://windows.github.com">http://windows.github.com</link>.</simpara>
</section>
<section xml:id="_building_from_source">
<title>Building from Source</title>
<simpara>You might instead find it useful to build Git from source, because this gives you the most recent version.
The binary installers tend to be a bit behind, although as Git matures, this is less important.</simpara>
<simpara>To build Git from source, you need the following libraries that Git depends on: autotools, curl, zlib, openssl, expat, and libiconv.
For example, on a system that has yum (RedHat or CentOS), dnf (Fedora),
or apt-get (Debian-based systems), run the corresponding command below to install the
dependencies for compiling and installing Git.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo yum install dh-autoreconf curl-devel expat-devel gettext-devel \
  openssl-devel perl-devel zlib-devel
$ sudo dnf install dh-autoreconf curl-devel expat-devel gettext-devel \
  openssl-devel perl-devel zlib-devel
$ sudo apt-get install dh-autoreconf libcurl4-gnutls-dev libexpat1-dev \
  gettext libz-dev libssl-dev</programlisting>
<simpara>To install the documentation in various formats (doc, html, info), run one of the following commands:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo yum install asciidoc xmlto docbook2X getopt
$ sudo dnf install asciidoc xmlto docbook2X getopt
$ sudo apt-get install asciidoc xmlto docbook2x getopt</programlisting>
<simpara>Users of RHEL and RHEL-derivatives, like CentOS, must enable the EPEL repository to install the <literal>docbook2X</literal> package.
Check Google for instructions on how to do this.
Additionally, run this to resolve binary name differences.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo ln -s /usr/bin/db2x_docbook2texi /usr/bin/docbook2x-texi</programlisting>
<simpara>On a Debian-based distribution (Debian/Ubuntu/Ubuntu-derivatives), you also need the <literal>install-info</literal> package:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo apt-get install install-info</programlisting>
<simpara>After you&#8217;ve installed all the necessary dependencies, grab the latest tagged Git release tarball
from kernel.org at <link xl:href="https://www.kernel.org/pub/software/scm/git">https://www.kernel.org/pub/software/scm/git</link>, or the mirror on the GitHub website, at <link xl:href="https://github.com/git/git/releases">https://github.com/git/git/releases</link>.
Make sure you&#8217;re downloading the latest version of Git, and check the release signatures to verify your download.</simpara>
<simpara>Then, compile and install:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ tar -zxf git-2.0.0.tar.gz
$ cd git-2.0.0
$ make configure
$ ./configure --prefix=/usr
$ make all doc info
$ sudo make install install-doc install-html install-info</programlisting>
</section>
</section>
<section xml:id="_first_time">
<title>First-Time Git Setup</title>
<simpara>Now that you&#8217;ve installed Git, there are a few commands to run to customize your Git environment.
You only have to run these once per computer, and they stick around between upgrades.
You can also change them at any time by running the commands again, supplying
different options.</simpara>
<simpara><literal>git config</literal> sets and shows these values, which are stored
in one or more of the following files:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>/etc/gitconfig</literal>: holds values used by for every user and all repositories on the system.
Git uses this file when you run <literal>git config --system</literal>.
(You need superuser privilege to make changes to it.)</simpara>
</listitem>
<listitem>
<simpara><literal>~/.gitconfig</literal> or <literal>~/.config/git/config</literal>: user specific values for all repositories on the system.
Git uses this file when you run <literal>git config --global</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>.git/config</literal>: values specific to the current repository.</simpara>
</listitem>
</orderedlist>
<simpara>Each level overrides values in the previous level, so values in <literal>.git/config</literal> trump those in <literal>/etc/gitconfig</literal>.</simpara>
<simpara>On Windows, Git looks for <literal>.gitconfig</literal> in <literal>$HOME</literal> (<literal>C:\Users\$USER</literal>).
If you&#8217;re using version 2.x or later of Git for Windows, there&#8217;s also a system-level config file at
<literal>C:\Documents and Settings\All Users\Application Data\Git\config</literal> on Windows XP, and in <literal>C:\ProgramData\Git\config</literal> on Windows Vista and newer.
This config file can only be changed by running <literal>git config -f &lt;file&gt;</literal> as an admin.</simpara>
<section xml:id="_your_identity">
<title>Your Identity</title>
<simpara>The first thing you should do after installing Git is to set your user name and email address.
This is important because every Git commit uses this information.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com</programlisting>
<simpara>Again, you only need to run these once, because Git uses these values everywhere
you work since you supplied the <literal>--global</literal> flag.
To set a different name or email address for a specific project, run <literal>git config</literal> without <literal>--global</literal> when you&#8217;re
in the project&#8217;s working directory.</simpara>
<simpara>Many of the GUI tools help you set these values the first time you run them.</simpara>
</section>
<section xml:id="_your_editor">
<title>Your Editor</title>
<simpara>Now that you&#8217;ve set up your identity, configure the default text editor Git uses when you enter a message.
If not configured, Git uses your system&#8217;s default editor.
To use a different editor, such as <literal>emacs</literal>, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global core.editor emacs</programlisting>
<simpara>On Windows, to use a different text editor, such as Notepad++, specify the full path to its executable file.</simpara>
<simpara>On x86</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -nosession"</programlisting>
<simpara>On x64</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global core.editor "'C:/Program Files (x86)/Notepad++/notepad++.exe' -multiInst -nosession"</programlisting>
<warning>
<simpara><literal>vim</literal> and <literal>emacs</literal> are popular text editors often used on Unix-based systems, like Linux and MacOS.
If you aren&#8217;t familiar with either of these editors or are using Windows, you need to learn
how to set up your favorite text editor with Git.
If you don&#8217;t set an editor and you don&#8217;t know <literal>vim</literal> or <literal>emacs</literal>, you&#8217;ll likely get into a
really confused state when they&#8217;re launched.</simpara>
</warning>
</section>
<section xml:id="_checking_your_configuration">
<title>Checking Your Configuration</title>
<simpara>To check your configuration values, run <literal>git config --list</literal> to list all the values currently in effect.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --list
user.name=John Doe
user.email=johndoe@example.com
color.status=auto
color.branch=auto
color.interactive=auto
color.diff=auto
...</programlisting>
<simpara>A value might appear more than once if Git finds it in more than one file (<literal>/etc/gitconfig</literal> and <literal>~/.gitconfig</literal>, for example).
In this case, Git uses the last value shown.</simpara>
<simpara>You can also check a specific value by running <literal>git config &lt;value&gt;</literal>.<indexterm>
<primary>git commands</primary><secondary>config</secondary>
</indexterm>
<indexterm>
<primary>config</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config user.name
John Doe</programlisting>
<note>
<simpara>Since the same configuration value might be set in more than one configuration file,
you might find that Git uses a value that you didn&#8217;t expect.
If this happens, Git can show you which configuration file that value came from.</simpara>
</note>
<programlisting language="console" linenumbering="unnumbered">$ git config --show-origin rerere.autoUpdate
file:/home/johndoe/.gitconfig	false</programlisting>
</section>
</section>
<section xml:id="_git_help">
<title>Getting Help</title>
<simpara>If you ever need help while using Git, there are two ways to see the manual page for any Git command.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git help &lt;verb&gt;
$ man git-&lt;verb&gt;</programlisting>
<simpara>For example, to see the manual page for <literal>git config</literal>, run<indexterm>
<primary>git commands</primary><secondary>help</secondary>
</indexterm>
<indexterm>
<primary>help</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git help config</programlisting>
<simpara>These commands are nice because you can run them anytime, even when offline.
If the manual pages and this book aren&#8217;t enough and you need in-person help, try the <literal>#git</literal> or <literal>#github</literal> channels
on the Freenode IRC server (irc.freenode.net).
These channels are regularly filled with hundreds of people who are very knowledgeable about Git and are often willing to help.<indexterm>
<primary>IRC</primary>
</indexterm></simpara>
<simpara>In addition, if you don&#8217;t need to see the complete manual page, but just need a quick summary of the available options for a Git command, use the <literal>-h</literal> or <literal>--help</literal> option to the command.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add -h
usage: git add [&lt;options&gt;] [--] &lt;pathspec&gt;...

    -n, --dry-run         dry run
    -v, --verbose         be verbose

    -i, --interactive     interactive picking
    -p, --patch           select hunks interactively
    -e, --edit            edit current diff and apply
    -f, --force           allow adding otherwise ignored files
    -u, --update          update tracked files
    -N, --intent-to-add   record only the fact that the path will be added later
    -A, --all             add changes from all tracked and untracked files
    --ignore-removal      ignore paths removed in the working tree (same as --no-all)
    --refresh             don't add, only refresh the index
    --ignore-errors       just skip files which cannot be added because of errors
    --ignore-missing      check if - even missing - files are ignored in dry run
    --chmod &lt;(+/-)x&gt;      override the executable bit of the listed files</programlisting>
</section>
<section xml:id="_summary">
<title>Summary</title>
<simpara>You now have a basic understanding of what Git is and how it&#8217;s different than a CVCS.
You also now have a working version of Git that&#8217;s set up with your personal information.
It&#8217;s now time to learn some Git basics.</simpara>
</section>
</chapter>
<chapter xml:id="ch02-git-basics-chapter">
<title>Git Basics</title>
<simpara>If you read only one chapter in this book, this is it.
It covers the basic Git commands that you use the vast majority of time.
By the end of the chapter, you should be able to configure and initialize a repository, start and stop
tracking files, and stage and commit changes.
We also show how to tell Git to ignore certain files and filename patterns, how to undo mistakes quickly
and easily, how to browse the history of your project, how to view changes made by commits,
and how to push and pull from remote repositories.</simpara>
<section xml:id="_creating_a_repo">
<title>Creating a Git Repository</title>
<simpara>There are two main ways to create a Git repository.
The first turns an existing project not currently under version control into a Git repository.
The second copies, or clones, an existing Git repository into a new location.</simpara>
<section xml:id="_initializing_a_repository_in_an_existing_directory">
<title>Initializing a Repository in an Existing Directory</title>
<simpara>To put an existing project under Git control, change directory to the project&#8217;s top-level directory and run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git init</programlisting>
<simpara>This creates a new subdirectory named <literal>.git</literal> that contains an empty Git repository.
At this point, nothing in your project is managed by Git.
(See <xref linkend="ch10-git-internals"/> for more information about exactly what files are contained in the <literal>.git</literal> directory you just created.)<indexterm>
<primary>git commands</primary><secondary>init</secondary>
</indexterm>
<indexterm>
<primary>init</primary>
</indexterm></simpara>
<simpara>Next, tell Git to manage, or <literal>track</literal>, the files in your project, and then make an initial commit,
which copies the tracked files into the Git repository.
Do this by running <literal>git add</literal> to specify the files you want to track, followed by <literal>git commit</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add LICENSE *.c
$ git commit -m 'initial project version'</programlisting>
<simpara>We&#8217;ll go over what these commands do in just a minute.
At this point, you have a Git repository, tracked files, and an initial commit.</simpara>
</section>
<section xml:id="_git_cloning">
<title>Cloning an Existing Repository</title>
<simpara>To create a local copy of an existing Git repository that exists on another computer&#8201;&#8212;&#8201;for example,
a project on GitHub you&#8217;d like to contribute to&#8201;&#8212;&#8201;run <literal>git clone</literal>.
If you&#8217;re familiar with other VCSs such as Subversion, notice that the subcommand is <literal>clone</literal> and not <literal>checkout</literal>.
This is an important distinction&#8201;&#8212;&#8201;instead of checking out just a working copy, you receive a
nearly complete clone of the remote repository.
Every version of every file for the history of the project is copied by default.
In fact, if the remote server&#8217;s disk gets corrupted, you can often use a clone to get the server back
to the state it was in when the clone was done
(see <xref linkend="_getting_git_on_a_server"/> for more details).</simpara>
<simpara>Clone a repository by running <literal>git clone [url]</literal>.<indexterm>
<primary>git commands</primary><secondary>clone</secondary>
</indexterm>
<indexterm>
<primary>clone</primary>
</indexterm>
For example, to clone the library called libgit2, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone https://github.com/libgit2/libgit2</programlisting>
<simpara>This creates a subdirectory named <literal>libgit2</literal> that itself contains a <literal>.git</literal> subdirectory, pulls down
the content of the <literal>libgit2</literal> repository, and populates the <literal>libgit2</literal> subdirectory with the latest
version of <literal>libgit2</literal>.
To clone the repository into a directory named something other than <literal>libgit2</literal>, specify the directory
name as the next command-line argument.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone https://github.com/libgit2/libgit2 mylibgit</programlisting>
<simpara>This does the same thing but puts the repository in the <literal>mylibgit</literal> directory.</simpara>
<simpara>Git supports a number of transfer protocols.
The previous example uses the <literal>https://</literal> protocol when transferring the repository,
but you may also use <literal>git://</literal> or <literal>user@server:</literal>, which use the SSH protocol.
<xref linkend="_getting_git_on_a_server"/> introduces all of the available transfer protocols along
with their pros and cons.</simpara>
</section>
</section>
<section xml:id="_recording_changes_in_the_repository">
<title>Recording Changes in the Repository</title>
<simpara>You now have a <emphasis>bona fide</emphasis> Git repository and a working directory containing the files in a project.
Now make some changes to the files and commit the changes to your repository</simpara>
<simpara>Remember that each file in your working directory can be in one of two states: <emphasis>tracked</emphasis> or <emphasis>untracked</emphasis>.
A tracked file is a file that you told Git to keep an eye on by specifying its
name in a <literal>git add</literal> command. The file can further be <emphasis>unmodified</emphasis>, <emphasis>modified</emphasis>, or <emphasis>staged</emphasis>.
Untracked files are everything else&#8201;&#8212;&#8201;files in your working directory that Git isn&#8217;t managing.
When you first clone a repository, all files in the resulting directory are tracked and unmodified because
Git just retrieved them and you haven&#8217;t made any changes yet.
The files are tracked because they were tracked in the repository you cloned
from, and they remain tracked in the repository you just created.</simpara>
<simpara>As you edit files, Git sees them as modified, because you&#8217;ve changed them since your last commit or since you cloned
the repository they came from.</simpara>
<figure>
<title>The lifecycle of the status of your files.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/lifecycle.png"/>
</imageobject>
<textobject><phrase>The lifecycle of the status of your files.</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_checking_status">
<title>Checking the Status of Your Files</title>
<simpara>The command that shows the state files are in is <literal>git status</literal>.<indexterm>
<primary>git commands</primary><secondary>status</secondary>
</indexterm>
<indexterm>
<primary>status</primary>
</indexterm>
If you run this command right after running <literal>git clone</literal>, you see something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean</programlisting>
<simpara>Ignore the line showing the branch you&#8217;re on for now (we talk a lot more
about branches later in <xref linkend="ch03-git-branching"/>).
Git sees that you have a clean working directory. In other words, there are no untracked
files or modified tracked files.</simpara>
<simpara>Let&#8217;s say you create a new file called README in your project.
If you then run <literal>git status</literal> you see that README is untracked.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo 'My Project' &gt; README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)</programlisting>
<simpara>You see that README is untracked because it appears in the <literal>Untracked files</literal> section of the output.
Again, untracked means that a file isn&#8217;t being managed by Git.
When a file isn&#8217;t being managed by Git, it isn&#8217;t included in any commits.</simpara>
<simpara>One reason Git requires files to be explicitly tracked
is so you don&#8217;t accidentally commit binary files or other recreatable files
You do want to start tracking README, so let&#8217;s add it.</simpara>
</section>
<section xml:id="_tracking_files">
<title>Tracking Files</title>
<simpara>To begin tracking a file, run <literal>git add</literal>.<indexterm>
<primary>git commands</primary><secondary>add</secondary>
</indexterm>
<indexterm>
<primary>add</primary>
</indexterm>
For example, to track README, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add README</programlisting>
<simpara>If you run <literal>git status</literal> again, you see that README is now tracked and ready to be committed.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README</programlisting>
<simpara>You see that README is ready to be committed because it&#8217;s in the <literal>Changes to be committed</literal> section.
If you commit at this point, the version of the file that existed when you ran <literal>git add</literal> is committed.
If you make any changes to README after you run <literal>git add</literal>, those changes aren&#8217;t committed unless you
run <literal>git add</literal> again.
This is important to remember. If you want the latest changes to be committed, run <literal>git add</literal> after making the changes.</simpara>
<simpara><literal>git add</literal> can optionally take a directory path name, in which case all the files in that directory and
all its subdirectories are added, recursively.</simpara>
</section>
<section xml:id="_staging_modified_files">
<title>Staging Modified Files</title>
<simpara>You might have noticed the word <literal>staged</literal> in the output of <literal>git status</literal>.
We now explain what this means.</simpara>
<simpara>Let&#8217;s change a file that&#8217;s already being tracked.
If you change a tracked file called <literal>CONTRIBUTING.md</literal> and then run <literal>git status</literal> again, you see</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</programlisting>
<simpara><literal>CONTRIBUTING.md</literal> appears in a section named <literal>Changes not staged for commit</literal>.
This means that a tracked file has been modified but
the new version isn&#8217;t in the location where files are copied from when you do a commit.
This location is called the <literal>staging area</literal>. <literal>git add</literal> copies files from the working directory
to the staging area.
To stage <literal>CONTRIBUTING.md</literal>, run <literal>git add</literal>. This is a multipurpose command&#8201;&#8212;&#8201;it begins tracking
new files and stages modified files.
After running <literal>git add</literal>, run <literal>git status</literal> again.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</programlisting>
<simpara>Both files are staged and will go into your next commit.
At this point, suppose you remember one little change that you want to make to <literal>CONTRIBUTING.md</literal>
before committing it. After making that change, you might think you&#8217;re ready to commit.
However, running <literal>git status</literal> one more time shows</simpara>
<programlisting language="console" linenumbering="unnumbered">$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</programlisting>
<simpara>What the heck?
Now <literal>CONTRIBUTING.md</literal> is shown as both staged <emphasis>and</emphasis> unstaged.  How is that possible?
It turns out that when you ran <literal>git add CONTRIBUTING.md</literal> to stage <literal>CONTRIBUTING.md</literal>,
Git copied the current content of <literal>CONTRIBUTING.md</literal> to the staging area.
When you commit, the version in the staging area is what goes into the commit,
not the version in your working directory.
In other words, if you modify a file after running <literal>git add</literal>, you have to run it again
to stage the latest version of the file so that that version goes into the next commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</programlisting>
</section>
<section xml:id="_short_status">
<title>Short Status</title>
<simpara>Although <literal>git status</literal> output is pretty comprehensive, it&#8217;s also quite verbose.
If you run <literal>git status -s</literal> or <literal>git status --short</literal> you see a far more simplified output.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt</programlisting>
<simpara>New files that aren&#8217;t tracked have <literal>??</literal> in front of them, new files that have been added to the staging
area have <literal>A</literal>, modified files have <literal>M</literal>, and so on.
There are two columns in the output&#8201;&#8212;&#8201;the left-hand column indicates the status of the staging
area and the right-hand column indicates the status of the working directory.
So, in the output above, <literal>README</literal> is modified in the working directory but not yet staged,
while <literal>lib/simplegit.rb</literal> is modified and staged.
<literal>Rakefile</literal> was modified, staged, and then modified again, so there are changes to it that are both
staged and unstaged.</simpara>
</section>
<section xml:id="_ignoring">
<title>Ignoring Files</title>
<simpara>There are often files that you don&#8217;t want Git to ever add or even show as being untracked.
These are generally automatically generated files, such as log files or files produced by your build system.
In such cases, you can create a file named <literal>.gitignore</literal> in your project&#8217;s root
directory that contains patterns showing the files to ignore.<indexterm>
<primary>ignoring files</primary>
</indexterm></simpara>
<simpara>Here&#8217;s an example <literal>.gitignore</literal> file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat .gitignore
*.[oa]
*~</programlisting>
<simpara>The first line tells Git to ignore any files ending in <literal>.o</literal> or <literal>.a</literal>&#8201;&#8212;&#8201;object or archive files that might be created
when you build your code.
The second line tells Git to ignore all files whose name ends with a tilde (<literal>~</literal>), which is used by many text editors for temporary files.
You may also want to ignore <literal>.log</literal> and <literal>.tmp</literal> files, automatically generated documentation, and so on.
Setting up a <literal>.gitignore</literal> file before you get going is generally a good idea so you don&#8217;t accidentally commit files that you really don&#8217;t want in your Git repository.</simpara>
<simpara>The rules for the patterns in <literal>.gitignore</literal> are</simpara>
<itemizedlist>
<listitem>
<simpara>Blank lines or lines starting with <literal>#</literal> are ignored.</simpara>
</listitem>
<listitem>
<simpara>Standard glob patterns work, and will be applied recursively throughout the entire working directory.</simpara>
</listitem>
<listitem>
<simpara>Start patterns with a forward slash (<literal>/</literal>) to avoid recursion.</simpara>
</listitem>
<listitem>
<simpara>End patterns with a forward slash (<literal>/</literal>) to specify a directory.</simpara>
</listitem>
<listitem>
<simpara>Negate a pattern by starting it with an exclamation point (<literal>!</literal>).</simpara>
</listitem>
</itemizedlist>
<simpara>Glob patterns are like the simplified regular expressions that shells use.
An asterisk (<literal>*</literal>) matches zero or more characters, <literal>[abc]</literal> matches any single character inside the brackets
(in this case <literal>a</literal>, <literal>b</literal>, or <literal>c</literal>), a question mark (<literal>?</literal>) matches any single character, and brackets
enclosing characters separated by a hyphen (<literal>[0-9]</literal>) match any character in the range shown
(in this case <literal>0</literal> through <literal>9</literal>, inclusive).
You can also use two asterisks to match nested directories. <literal>a/**/z</literal> would match <literal>a/z</literal>, <literal>a/b/z</literal>, <literal>a/b/c/z</literal>, and so on.</simpara>
<simpara>Here&#8217;s another example <literal>.gitignore</literal> file.</simpara>
<screen># ignore all .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in any directory named build
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory and any of its subdirectories
doc/**/*.pdf</screen>
<tip>
<simpara>GitHub maintains a fairly comprehensive list of good <literal>.gitignore</literal> file examples for dozens of
projects and languages at <link xl:href="https://github.com/github/gitignore">https://github.com/github/gitignore</link>.</simpara>
</tip>
<note>
<simpara>A repository might have a single <literal>.gitignore</literal> file in its root directory, which applies recursively to the entire repository.
However, it&#8217;s also possible to have additional <literal>.gitignore</literal> files in subdirectories.
The rules in these nested <literal>.gitignore</literal> files apply only to the files under the directory where the <literal>.gitignore</literal> files are located.
(The Linux kernel source repository has 206 <literal>.gitignore</literal> files, as of this writing.)</simpara>
</note>
</section>
<section xml:id="_git_diff_staged">
<title>Viewing Your Staged and Unstaged Changes</title>
<simpara>If the output of <literal>git status</literal> is too vague&#8201;&#8212;&#8201;you want to know exactly what changed, not just which files were changed&#8201;&#8212;&#8201;run <literal>git diff</literal>.<indexterm>
<primary>git commands</primary><secondary>diff</secondary>
</indexterm>
<indexterm>
<primary>diff</primary>
</indexterm>
We cover <literal>git diff</literal> in more detail later, but you probably use it most often to answer the following
two questions: What have you changed but not yet staged, and what have you changed that you&#8217;re about to commit?
Although <literal>git status</literal> answers those questions very generally by showing the names of files that have changed,
<literal>git diff</literal> shows the exactly what changed.</simpara>
<simpara>Let&#8217;s say you edit and stage <literal>README</literal> again and then edit <literal>CONTRIBUTING.md</literal> without staging it.
If you run <literal>git status</literal>, you once again see</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    modified:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</programlisting>
<simpara>To see what you&#8217;ve changed but not yet staged, run <literal>git diff</literal> with no arguments.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</programlisting>
<simpara><literal>git diff</literal> compares what&#8217;s in your working directory with what&#8217;s in the staging area.
The result shows the changes you&#8217;ve made that you haven&#8217;t yet staged.</simpara>
<simpara>To see the differences between what you&#8217;ve staged and what&#8217;s been committed already, run <literal>git diff --staged</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project</programlisting>
<simpara>It&#8217;s important to note that <literal>git diff</literal> with no flags doesn&#8217;t show all changes made since your last commit&#8201;&#8212;&#8201;only changes that are still unstaged.
This can be confusing, because if you&#8217;ve staged all of your changes, <literal>git diff</literal> shows nothing.</simpara>
<simpara>For another example, if you stage <literal>CONTRIBUTING.md</literal> and then modify it, <literal>git status</literal> shows that there&#8217;s both
a staged and an unstaged file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add CONTRIBUTING.md
$ echo '# test line' &gt;&gt; CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</programlisting>
<simpara>Now run <literal>git diff</literal> to see the unstaged changes&#8201;&#8212;&#8201;that is the changes between
what&#8217;s in the working directory and what&#8217;s in the cache.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line</programlisting>
<simpara>And run <literal>git diff --cached</literal> to see the staged changes&#8201;&#8212;&#8201;that is the changes
between what&#8217;s in the cache and what&#8217;s been committed (remember <literal>--staged</literal> and <literal>--cached</literal> are synonyms).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</programlisting>
<note>
<title>Git Diff in an External Tool</title>
<simpara>We continue to run <literal>git diff</literal> in various ways throughout the rest of the book.
However, Git also allows using other diff viewing programs.
If you run <literal>git difftool</literal> instead of <literal>git diff</literal>, you can view any of these diffs using software like
emerge, vimdiff, and more
(including commercial products). Run <literal>git difftool --tool-help</literal> to see what&#8217;s available on your system.</simpara>
</note>
</section>
<section xml:id="_committing_changes">
<title>Committing Your Changes</title>
<simpara>Now commit your staged changes.
Remember that anything in your working directory that&#8217;s still unstaged&#8201;&#8212;&#8201;any files you&#8217;ve created or
modified that you haven&#8217;t run <literal>git add</literal> on since you edited them&#8201;&#8212;&#8201;don&#8217;t go into this commit.
They remain as modified files.
Let&#8217;s say that the last time you ran <literal>git status</literal>, you saw that everything was staged, so you&#8217;re ready
to commit your changes.<indexterm>
<primary>git commands</primary><secondary>status</secondary>
</indexterm>
<indexterm>
<primary>status</primary>
</indexterm>
The simplest way to commit is to run <literal>git commit</literal>.<indexterm>
<primary>git commands</primary><secondary>commit</secondary>
</indexterm>
<indexterm>
<primary>commit</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit</programlisting>
<simpara>This launches your text editor of choice.
(This choice is set by your <literal>$EDITOR</literal> environment variable&#8201;&#8212;&#8201;usually <literal>vim</literal> or <literal>emacs</literal>, although it can be
anything you want by running <literal>git config --global core.editor</literal>, as you saw in <xref linkend="_getting_started"/>).<indexterm>
<primary>editor</primary><secondary>changing default</secondary>
</indexterm>
<indexterm>
<primary>changing default</primary>
</indexterm><indexterm>
<primary>git commands</primary><secondary>config</secondary>
</indexterm>
<indexterm>
<primary>config</primary>
</indexterm></simpara>
<simpara>You see the following text (this example is a <literal>vim</literal> screen):</simpara>
<screen># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C</screen>
<simpara>By default, the editor buffer contains the commented-out output of <literal>git status</literal>.
You can remove these comments and enter your commit message, or you can leave them in to help you remember what
you&#8217;re committing.
(For an even more explicit reminder of what you&#8217;ve modified, run <literal>git commit -v</literal>.
This also puts the diff of your changes in the editor buffer so you can see exactly what you&#8217;re committing.)
When you exit the editor, Git creates the commit with the message you entered (the comments and diff are stripped out).</simpara>
<simpara>Or, include your commit message on the <literal>git commit</literal> command line by specifying the message after the <literal>-m</literal> flag.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README</programlisting>
<simpara>Now you&#8217;ve created your first commit!
You can see which branch you committed to (<literal>master</literal>),
the commit&#8217;s SHA-1 checksum (<literal>463dc4f</literal>), how many files were changed, and statistics about how many lines were added and removed.</simpara>
<simpara>Remember that the commit only saves what you staged.
Nothing in your working directory is commmitted or changed.
Every time you make a commit, you&#8217;re recording a snapshot of what&#8217;s in the staging area.</simpara>
</section>
<section xml:id="_skipping_the_staging_step">
<title>Skipping the Staging Step</title>
<simpara><indexterm>
<primary>staging area</primary><secondary>skipping</secondary>
</indexterm>
<indexterm>
<primary>skipping</primary>
</indexterm>
In simple projects, having to run <literal>git add</literal> to first stage the files you want to commit can get in the way.
To skip this step, Git provides a simple shortcut.
Adding the <literal>-a</literal> flag to <literal>git commit</literal> makes Git automatically stage every modified tracked file
before making the commit, letting you skip running <literal>git add</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)</programlisting>
<simpara>Notice how you didn&#8217;t have to run <literal>git add CONTRIBUTING.md</literal> here before you commit.
But be careful you don&#8217;t accidently commit files that shouldn&#8217;t be committed.</simpara>
</section>
<section xml:id="_removing_files">
<title>Removing Files</title>
<simpara><indexterm>
<primary>files</primary><secondary>removing</secondary>
</indexterm>
<indexterm>
<primary>removing</primary>
</indexterm>
<indexterm>
<primary>files</primary><secondary>removing</secondary>
</indexterm>
<indexterm>
<primary>removing</primary>
</indexterm>
Removing a file from Git can mean several things. Probably the most common is
to remove the file from a commit. To do this,
remove the file from the staging area by running <literal>git rm</literal>, and then commit.
This also removes the file from your working directory so you don&#8217;t see it as an untracked file.</simpara>
<note>
<title>Removing Files Containing Sensitive Data</title>
<simpara>In keeping with Git&#8217;s philosophy of (almost) never removing anything from a
repository, running <literal>git rm</literal>
doesn&#8217;t completely remove the file from the repository.
If you accidently commit a file containing sensitive data that you don&#8217;t want
someone else to see if they clone your repository or otherwise see the files in
<literal>.git</literal>, you have to use a different method.</simpara>
</note>
<simpara>If you simply remove the file from your working directory, it shows up under the <literal>Changes not staged for commit</literal> section in your <literal>git status</literal> output.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")</programlisting>
<simpara>Then, if you run <literal>git rm</literal>, the file is removed from the staging area.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    deleted:    PROJECTS.md</programlisting>
<simpara>The file isn&#8217;t included in your next commit, because it&#8217;s no longer in the staging area.
If you modified the file or you&#8217;ve staged it already, you must force the removal with the <literal>-f</literal> flag.
This is a safety feature to prevent you from accidentally removing content that hasn&#8217;t yet
een committed and that can&#8217;t be recovered from Git.</simpara>
<simpara>Perhaps you forgot to add something to your <literal>.gitignore</literal> file and accidentally staged a large log
file or a bunch of archive files. You do want to keep the files in your working directory but don&#8217;t want
them staged or committed.</simpara>
<simpara>To do this, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rm --cached output.log</programlisting>
<simpara>Let&#8217;s say you accidently removed a bunch of files by running <literal>rm log/\*.log</literal> when you
really meant to run <literal>git rm log/*.log</literal>. At this point you can&#8217;t run <literal>git rm
log/\*.log</literal> because the shell doesn&#8217;t find any files matching the pattern <literal>log/*.log</literal>
because the files that used to match this pattern were just deleted.
However, Git itself can also do filename expansion against what&#8217;s in the repository
if you include file-glob patterns on the <literal>git rm</literal> command line.</simpara>
<simpara>That means you can do things like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rm log/\*.log</programlisting>
<simpara>Note the backslash (<literal>\</literal>) in front of the <literal>*</literal>.
This is necessary because you want Git to do filename expansion rather than the shell.
This command removes all files that have the <literal>.log</literal> extension in the <literal>log/</literal> directory.
Or, you can run something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rm \*~</programlisting>
<simpara>This removes all files whose names end with a <literal>~</literal>.</simpara>
</section>
<section xml:id="_git_mv">
<title>Moving Files</title>
<simpara><indexterm>
<primary>files</primary><secondary>moving</secondary>
</indexterm>
<indexterm>
<primary>moving</primary>
</indexterm>
Unlike many other VCSs, Git doesn&#8217;t explicitly track file moving or renaming.
(These are basically the same operation.)
If you move a file in Git, Git doesn&#8217;t store any metadata saying this happened.
However, Git is pretty smart about figuring it out after the fact&#8201;&#8212;&#8201;we deal with detecting file moving a bit later.</simpara>
<simpara>Thus it&#8217;s a bit confusing that Git has a <literal>git mv</literal> subcommand.
To move a file in Git, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git mv file_from file_to</programlisting>
<simpara>In fact, if you run something like this and look at the output of <literal>git status</literal>, you notice that Git sees a renamed file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    renamed:    README.md -&gt; README</programlisting>
<simpara>However, this is equivalent to running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ mv README.md README
$ git rm README.md
$ git add README</programlisting>
<simpara>Git figures out that a rename occurred, so it doesn&#8217;t matter if you rename a file as above or with <literal>git mv</literal>.
The only real difference is that <literal>git mv</literal> is one command instead of three&#8201;&#8212;&#8201;it&#8217;s more convenient.
More importantly, you can use any tool you like to rename a file, and run <literal>git rm</literal>
and <literal>git add</literal> later, before committing.</simpara>
</section>
</section>
<section xml:id="_viewing_history">
<title>Viewing Commit History</title>
<simpara>After making several commits, or cloning a repository containing commits,
you might want to look back to see the history of the repository.
The most basic way to do this is by running <literal>git log</literal>.</simpara>
<simpara>These examples use a very simple project called <literal>simplegit</literal>.
To get the project, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone https://github.com/schacon/simplegit-progit</programlisting>
<simpara>When you run <literal>git log</literal> in this project, you should see something like<indexterm>
<primary>git commands</primary><secondary>log</secondary>
</indexterm>
<indexterm>
<primary>log</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit</programlisting>
<simpara>By default, with no arguments, <literal>git log</literal> shows the repository&#8217;s commits in reverse chronological order&#8201;&#8212;&#8201;that is,
the most recent commit shows up first.
You see each commit&#8217;s SHA-1 hash, author&#8217;s name and email address, commit date, and commit message.</simpara>
<simpara><literal>git log</literal> has a huge number and variety of flags that allow you to specify exactly what you&#8217;re looking for.</simpara>
<simpara>One of the more helpful flags is <literal>-p</literal>, which shows the differences introduced in each commit.
If you run <literal>git log -p -2</literal>, you only see the last two commits.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require 'rake/gempackagetask'
 spec = Gem::Specification.new do |s|
     s.platform  =   Gem::Platform::RUBY
     s.name      =   "simplegit"
-    s.version   =   "0.1.0"
+    s.version   =   "0.1.1"
     s.author    =   "Scott Chacon"
     s.email     =   "schacon@gee-mail.com"
     s.summary   =   "A simple gem for using Git in Ruby code."

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
     end

 end
-
-if $0 == __FILE__
-  git = SimpleGit.new
-  puts git.show
-end</programlisting>
<simpara>Using the <literal>-p</literal> flag is very helpful for code reviews or to quickly review what changed in a commit.
You can also add various summary flags to <literal>git log</literal>.
For example, to see abbreviated statistics for each commit, use the <literal>--stat</literal> flag.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

 Rakefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test

 lib/simplegit.rb | 5 -----
 1 file changed, 5 deletions(-)

commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit

 README           |  6 ++++++
 Rakefile         | 23 +++++++++++++++++++++++
 lib/simplegit.rb | 25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+)</programlisting>
<simpara>As you see, for each commit <literal>git log --stat</literal> show modified files, the number of lines in those files that were added and removed,
and how many files were changed.</simpara>
<simpara>Another really useful flag is <literal>--pretty</literal>,
which allows you to specify a prebuilt output format.
Several prebuilt formats are available.
The <literal>oneline</literal> format puts each commit on a single line, which is useful when looking at a lot of commits.
In addition, the <literal>short</literal>, <literal>full</literal>, and <literal>fuller</literal> formats vary in how much
information they show.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</programlisting>
<simpara>The most interesting format is <literal>format</literal>, which allows you to create a custom output format.
This is especially useful when you&#8217;re generating output for machine parsing. Since you specify the format explicitly,
you should know how to parse it.<indexterm>
<primary>log formatting</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit</programlisting>
<simpara>Here are some of the more useful <literal>format</literal> options.</simpara>
<table xml:id="pretty_format" frame="all" rowsep="1" colsep="1">
<title>Useful options for <literal>git log --pretty=format</literal></title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Option</entry>
<entry align="left" valign="top">Description of Output</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>%H</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commit hash</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%h</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Abbreviated commit hash</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%T</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Tree hash</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%t</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Abbreviated tree hash</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%P</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Parent hashes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%p</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Abbreviated parent hashes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%an</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Author name</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%ae</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Author email</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%ad</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Author date (format respects the --date=option)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%ar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Author date, relative</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%cn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Committer name</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%ce</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Committer email</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%cd</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Committer date</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%cr</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Committer date, relative</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>%s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Subject</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>You may be wondering what the difference is between <emphasis>author</emphasis> and <emphasis>committer</emphasis>.
The author is the person who originally created the change, whereas the committer is the person who actually committed it.
So, if you send in a patch to a project and one of the project members applies the patch, both of you get
credit&#8201;&#8212;&#8201;you as the author, and the project member as the committer.
We cover this distinction in more detail in <xref linkend="ch05-distributed-git"/>.</simpara>
<simpara>The <literal>oneline</literal> and <literal>format</literal> flags are particularly useful with the <literal>--graph</literal> flag to <literal>git log</literal>.
This adds a nice little ASCII graph showing your branch and merge history.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty=format:"%h %s" --graph
* 2d3acf9 ignore errors from SIGCHLD on trap
*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit
|\
| * 420eac9 Added a method for getting the current branch.
* | 30e367c timeout code and tests
* | 5a09431 add timeout protection to grit
* | e1193f8 support for heads with slashes in them
|/
* d6016bc require time for xmlschema
*  11d191e Merge branch 'defunkt' into local</programlisting>
<simpara>This type of output becomes more interesting when we cover branching and merging in the next chapter.</simpara>
<simpara>Those are only some simple output-formatting flags for <literal>git log</literal>&#8201;&#8212;&#8201;there are many more.
<xref linkend="log_options"/> lists the flags we&#8217;ve covered so far, as well as some other useful common flags, along with how they change the output of <literal>git log</literal>.</simpara>
<table xml:id="log_options" frame="all" rowsep="1" colsep="1">
<title>Common options to <literal>git log</literal></title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Option</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>-p</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Show the patch introduced with each commit.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--stat</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Show statistics for files modified in each commit.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--shortstat</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Display only the changed/insertions/deletions line from the --stat command.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--name-only</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Show the list of files modified after the commit information.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--name-status</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Show the list of files affected with added/modified/deleted information as well.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--abbrev-commit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Show only the first few characters of the SHA-1 checksum instead of all 40.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--relative-date</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Display the date in a relative format (for example, 2 weeks ago) instead of using the full date format.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--graph</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Display an ASCII graph of the branch and merge history beside the log output.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--pretty</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Show commits in an alternate format. Options include oneline, short, full, fuller, and format (where you specify your own format).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--oneline</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Shorthand for <literal>--pretty=oneline --abbrev-commit</literal> used together.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="_limiting_log_output">
<title>Limiting Log Output</title>
<simpara>In addition to output formatting flags, <literal>git log</literal> takes a number of useful output limiting flags&#8201;&#8212;&#8201;that is, flags that let you select a subset of commits.
You&#8217;ve seen one such flag already&#8201;&#8212;&#8201;the <literal>-2</literal> flag, which shows only the last two commits.
In fact, you can use <literal>-&lt;n&gt;</literal>, where <literal>n</literal> is any positive integer, to show the last <literal>n</literal> commits.
You&#8217;re unlikely to use this option often, because <literal>git log</literal> by default pipes all output through a pager so you see only one page of output at a time.</simpara>
<simpara>The time selection flags, <literal>--since</literal> and <literal>--until</literal>, can be very useful.
For example, this command shows a list of commits made in the last two weeks.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --since=2.weeks</programlisting>
<simpara>This flag works with lots of date and time formats&#8201;&#8212;&#8201;you can specify a specific date like <literal>"2008-01-15"</literal>, or a relative date such as <literal>"2 years 1 day 3 minutes ago"</literal>.</simpara>
<simpara>You can also filter the output to only show commits that match some search criteria.
The <literal>--author</literal> flag selects a specific author, and the <literal>--grep</literal> flag searches for keywords in the commit messages.</simpara>
<note>
<simpara>You can specify both the <literal>--author</literal> and <literal>--grep</literal> flags more than once, which
limits the commit output to commits that match <emphasis>any</emphasis> of the <literal>--author</literal> patterns and <emphasis>any</emphasis>
of the <literal>--grep</literal> patterns. However, adding the <literal>--all-match</literal> flag further limits the output to
just those commits that match <emphasis>all</emphasis> <literal>--grep</literal> patterns.</simpara>
</note>
<simpara>Another really helpful filter is the <literal>-S</literal> flag which takes a string and only shows the commits
that introduced a change that added or removed that string. For instance, to find the last commit
that added or removed a reference to a specific function, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -S function_name</programlisting>
<simpara>The last really useful flag includes a path on the <literal>git log</literal> command line as a filter.
Specifying a directory or file name limits the log output to commits that introduced a change to a file in or
under that directory, or to the specified file.
This is always the last argument, and is preceded by double dashes (<literal>--</literal>) to separate paths from flags.</simpara>
<simpara>In <xref linkend="limit_options"/> we list these and a few other common flags.</simpara>
<table xml:id="limit_options" frame="all" rowsep="1" colsep="1">
<title>Options to limit the output of <literal>git log</literal></title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Option</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>-&lt;n&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Show only the last n commits</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--since</literal>, <literal>--after</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Limit the commits to those made after the specified date.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--until</literal>, <literal>--before</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Limit the commits to those made before the specified date.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--author</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Only show commits in which the author entry matches the specified string.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--committer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Only show commits in which the committer entry matches the specified string.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--grep</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Only show commits with a commit message containing the string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-S</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Only show commits adding or removing code matching the string</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>For example, to see the commits by Junio Hamano that modified test files in the Git source code
in the month of October 2008 that weren&#8217;t merge commits, run<indexterm>
<primary>log filtering</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty="%h - %s" --author='Junio C Hamano' --since="2008-10-01" \
   --before="2008-11-01" --no-merges -- t/
5610e3b - Fix testcase failure when extended attributes are in use
acd3b9e - Enhance hold_lock_file_for_{update,append}() API
f563754 - demonstrate breakage of detached checkout with symbolic link HEAD
d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths
51a94af - Fix "checkout --track -b newbranch" on detached HEAD
b0ad11e - pull: allow "git pull origin $something:$current_branch" into an unborn branch</programlisting>
<simpara>Of the nearly 40,000 commits in the Git source code history, this command shows the 6 that match those criteria.</simpara>
</section>
</section>
<section xml:id="_undoing">
<title>Undoing Things</title>
<simpara>You may find that you&#8217;ve changed your mind and want to undo a change.
We review a few methods for doing so now.
Be careful, because you can&#8217;t always undo what you undo.
This is one of the few areas in Git where you may lose work if you make a mistake.</simpara>
<simpara>One common undo situation is when you commit too early and forget to add some files,
or you mess up your commit message. To try that commit again, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit --amend</programlisting>
<simpara>If you&#8217;ve made no changes since your last commit (for instance, you run this command immediately after your
previous commit), then your snapshot looks exactly the same, and all you change is the commit message.</simpara>
<simpara>The editor starts, containing the commit message from your previous commit.
Editing and saving the message overwrites the previous message.</simpara>
<simpara>As an example, if you commit and then realize you forgot to stage a file you wanted to add to the commit, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend</programlisting>
<simpara>You end up with a single commit&#8201;&#8212;&#8201;the second commit replaces the first.</simpara>
<note>
<simpara>Remember that when you amend your last commit, you&#8217;re not really fixing it.
Instead you&#8217;re <emphasis>replacing</emphasis> the old commit entirely with a new commit.
It&#8217;s as if the previous commit never happened, and it won&#8217;t be in your repository.</simpara>
<simpara>The obvious value to amending commits is to improve your last commit, without cluttering your repository history with commit messages of the form, &#8220;Oops, forgot to add a file&#8221; or &#8220;Darn, fixing a typo in last commit&#8221;.</simpara>
</note>
<section xml:id="_unstaging">
<title>Unstaging a Staged File</title>
<simpara>The next two sections demonstrate how to manage your staging area and working directory.
The nice part is that when <literal>git status</literal> shows the state of these areas it also reminds you how to undo changes to them.
For example, let&#8217;s say you&#8217;ve changed two files and want to save them in two separate commits,
but you accidentally run <literal>git add *</literal> and stage them both. How can you unstage one of them?
<literal>git status</literal> reminds you.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add *
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    renamed:    README.md -&gt; README
    modified:   CONTRIBUTING.md</programlisting>
<simpara>Right below the <literal>Changes to be committed:</literal> section, you see <literal>(use "git reset HEAD &lt;file&gt;..." to unstage)</literal>.
So, let&#8217;s follow that advice to unstage <literal>CONTRIBUTING.md</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    renamed:    README.md -&gt; README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</programlisting>
<simpara>The command looks a bit strange, but it works.
The modified version of <literal>CONTRIBUTING.md</literal> remains in the working directory but once again is unstaged.</simpara>
<note>
<simpara><literal>git reset</literal> <emphasis>can</emphasis> be dangerous if you run it with the <literal>--hard</literal> flag because it can change files in your working directory.</simpara>
</note>
<simpara>For now this magic invocation is all you need to know about <literal>git reset</literal>. We go into much more detail about what it does and how to get it to do really interesting things in <xref linkend="_git_reset"/>.</simpara>
</section>
<section xml:id="_unmodifying_a_modified_file">
<title>Unmodifying a Modified File</title>
<simpara>What if you realize that you don&#8217;t want to keep your changes to <literal>CONTRIBUTING.md</literal>?
How can you unmodify it&#8201;&#8212;&#8201;that is, revert it back to what it looked like before you changed it?
Luckily, <literal>git status</literal> tells you how to do that too.
In the last example, the unstaged output area looks like</simpara>
<programlisting language="console" linenumbering="unnumbered">Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</programlisting>
<simpara>This tells you exactly how to discard the changes you&#8217;ve made.
Let&#8217;s do what it says.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    renamed:    README.md -&gt; README</programlisting>
<simpara>You can see that the changes have been reverted.</simpara>
<important>
<simpara>It&#8217;s important to understand that <literal>git checkout -- &lt;file&gt;</literal> is a dangerous command. Any changes in
the working directory you made to that file are gone. Git just replaced it with
the version in the last commit.
Don&#8217;t ever use this command unless you&#8217;re absolutely sure you no longer want the modified file.</simpara>
</important>
<simpara>To keep the changes you&#8217;ve made to a file but get it out of the way for now, read about
stashing and branching in <xref linkend="ch03-git-branching"/>.
There are generally better ways to accomplish this
than reverting.</simpara>
<simpara>Remember, anything that&#8217;s <emphasis>committed</emphasis> in Git can almost always be recovered.
Even commits that were deleted or were overwritten with the <literal>--amend</literal> flag can be recovered
(see <xref linkend="_data_recovery"/> for data recovery).
However, anything you lose that was never committed is likely never to be seen again.</simpara>
</section>
</section>
<section xml:id="_remote_repos">
<title>Working with Remotes</title>
<simpara>To collaborate with other people on projects managed by Git, you need to know how to access remote repositories,
called simply <literal>remotes</literal>, which are versions of the project in Git repositories located on remote computers.
Collaborating with others involves managing these remotes, and pushing to and pulling from them
when you need to share work. This requires knowing how to add remotes, remove remotes that no longer exist,
manage remote branches, and more. In this section, we cover some of these skills.</simpara>
<section xml:id="_showing_your_remotes">
<title>Showing Your Remotes</title>
<simpara>Run <literal>git remote</literal> to see the remote repositories you&#8217;ve added.<indexterm>
<primary>git commands</primary><secondary>remote</secondary>
</indexterm>
<indexterm>
<primary>remote</primary>
</indexterm>
What you see will be an alias, called a <literal>shortname</literal>, for each remote.
If you&#8217;ve cloned a repository, you should at least see <literal>origin</literal>&#8201;&#8212;&#8201;that&#8217;s the default shortname Git
gives to the repository you cloned from.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin</programlisting>
<simpara>You can also add the <literal>-v</literal> flag, which shows both the shortname and URL of all remotes associated
with the current repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)</programlisting>
<simpara>For example, a repository with multiple remotes for working with multiple collaborators
might look something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd grit
$ git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)</programlisting>
<simpara>Remotes make it easier to reference your collaborators' repositories.</simpara>
<simpara>Notice that these remotes use a variety of access protocols, which we cover in more detail in <xref linkend="_getting_git_on_a_server"/>.</simpara>
</section>
<section xml:id="_adding_remote_repositories">
<title>Adding Remote Repositories</title>
<simpara>We&#8217;ve shown how <literal>git clone</literal> implicitly adds the <literal>origin</literal> remote.
To add a remote explicitly<indexterm>
<primary>git commands</primary><secondary>remote</secondary>
</indexterm>
<indexterm>
<primary>remote</primary>
</indexterm>
run <literal>git remote add &lt;shortname&gt; &lt;url&gt;</literal>.
This adds a new remote repository and a shortname.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote
origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)</programlisting>
<simpara>Now when you reference a remote you can use the shortname <literal>pb</literal> on the command line in lieu of the whole URL.
The next section shows an example of this.</simpara>
</section>
<section xml:id="_fetching_and_pulling">
<title>Fetching and Pulling from Your Remotes</title>
<simpara>To get data from a remote repository, run:<indexterm>
<primary>git commands</primary><secondary>fetch</secondary>
</indexterm>
<indexterm>
<primary>fetch</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch &lt;remote&gt;</programlisting>
<simpara>For example, to fetch the content in the <literal>pb</literal> repository that you don&#8217;t yet have in your repository,
run <literal>git fetch pb</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
 * [new branch]      master     -&gt; pb/master
 * [new branch]      ticgit     -&gt; pb/ticgit</programlisting>
<simpara>When you clone a remote repository, the remote repository&#8217;s name is assigned the shortname <literal>origin</literal>.
So, <literal>git fetch origin</literal> fetches any new work added to that remote repository since you cloned (or last fetched from) it.
It&#8217;s important to note that <literal>git fetch</literal> puts the data from the remote repository
into its own location in your repository&#8201;&#8212;&#8201;the data isn&#8217;t automatically merged with any of your existing work.
You have to merge it manually when you&#8217;re ready.
Or, run <literal>git pull</literal> to automatically fetch and then merge any new content from the remote
repository into your local repository.<indexterm>
<primary>git commands</primary><secondary>pull</secondary>
</indexterm>
<indexterm>
<primary>pull</primary>
</indexterm></simpara>
</section>
<section xml:id="_pushing_remotes">
<title>Pushing to Your Remotes</title>
<simpara>When your project is at a point you want to share, push it to the
repositories of the people you&#8217;re working with.
The command for this is simple: <literal>git push [remote-name] [branch-name]</literal>.<indexterm>
<primary>git commands</primary><secondary>push</secondary>
</indexterm>
<indexterm>
<primary>push</primary>
</indexterm>
(<xref linkend="ch03-git-branching"/>, the next chapter, describes what a branch is.)
To push your commits to the <literal>origin</literal> remote, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin master</programlisting>
<simpara>This command works only if you have write access to the repository you&#8217;re pushing to,
and if nobody has pushed since you cloned the repository.
If you and someone else clone at the same time and they push before you push, your push is rejected.
This is because you might have made changes that conflict with their changes.
You have to fetch their work first and incorporate it into your work before you&#8217;re allowed to push.
See <xref linkend="ch03-git-branching"/> for more detailed information on how to push to remote servers.</simpara>
</section>
<section xml:id="_inspecting_remote">
<title>Inspecting a Remote</title>
<simpara>To see more information about a particular remote, run <literal>git remote show [remote-name]</literal>.<indexterm>
<primary>git commands</primary><secondary>remote</secondary>
</indexterm>
<indexterm>
<primary>remote</primary>
</indexterm>
If you run this command with a shortname, such as <literal>origin</literal>, you see something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote show origin
* remote origin
  Fetch URL: https://github.com/schacon/ticgit
  Push  URL: https://github.com/schacon/ticgit
  HEAD branch: master
  Remote branches:
    master                               tracked
    dev-branch                           tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)</programlisting>
<simpara>Much of this information won&#8217;t make sense until you&#8217;ve learned about branches.</simpara>
</section>
<section xml:id="_renaming_and_removing_remotes">
<title>Renaming and Removing Remotes</title>
<simpara>Run <literal>git remote rename</literal> to change a remote&#8217;s shortname.<indexterm>
<primary>git commands</primary><secondary>remote</secondary>
</indexterm>
<indexterm>
<primary>remote</primary>
</indexterm>
For instance, to rename <literal>pb</literal> to <literal>paul</literal>, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote rename pb paul
$ git remote
origin
paul</programlisting>
<simpara>To remove a remote for some reason&#8201;&#8212;&#8201;perhaps the server moved or a contributor
isn&#8217;t contributing anymore&#8201;&#8212;&#8201;run <literal>git remote remove</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote remove paul
$ git remote
origin</programlisting>
</section>
</section>
<section xml:id="_git_tagging">
<title>Tagging</title>
<simpara><indexterm>
<primary>tags</primary>
</indexterm>
Like most VCSs, Git can tag specific commits.
Typically people do this to mark releases (v1.0, and so on).
In this section, you learn how to list existing tags, how to create new tags,
and what the different types of tags are.</simpara>
<section xml:id="_listing_your_tags">
<title>Listing Your Tags</title>
<simpara>Listing the tags in a Git repository is simple.
Just run <literal>git tag</literal>.<indexterm>
<primary>git commands</primary><secondary>tag</secondary>
</indexterm>
<indexterm>
<primary>tag</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag
v0.1
v1.3</programlisting>
<simpara>This lists the tags in alphabetical order.</simpara>
<simpara>You can also search for tags containing a particular string pattern.
The Git source repo, for instance, contains more than 500 tags.
If you&#8217;re only interested in looking at the 1.8.5 series, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag -l "v1.8.5*"
v1.8.5
v1.8.5-rc0
v1.8.5-rc1
v1.8.5-rc2
v1.8.5-rc3
v1.8.5.1
v1.8.5.2
v1.8.5.3
v1.8.5.4
v1.8.5.5</programlisting>
<note>
<simpara>Running <literal>git tag</literal> produces the entire list of tags. <literal>-l</literal> or <literal>--list</literal> is optional.
If, however, you&#8217;re supplying a wildcard pattern to match tag names, <literal>-l</literal> or <literal>--list</literal> is mandatory.</simpara>
</note>
</section>
<section xml:id="_creating_tags">
<title>Creating Tags</title>
<simpara>Git supports two types of tags: <emphasis>lightweight</emphasis> and <emphasis>annotated</emphasis>.</simpara>
<simpara>A lightweight tag simply points to a specific commit.</simpara>
<simpara>An annotated tag, however, is stored almost like a file that&#8217;s been committed in a Git repository.
It also points to a specific commit, but it&#8217;s also checksummed, contains the name
and email address of the tag creator, creation date, tagging message, and can be signed
and verified with GNU Privacy Guard (GPG).
It&#8217;s generally recommended that you create annotated tags to record all this information, but if you
don&#8217;t need all that information, lightweight tags are fine.</simpara>
</section>
<section xml:id="_annotated_tags">
<title>Annotated Tags</title>
<simpara><indexterm>
<primary>tags</primary><secondary>annotated</secondary>
</indexterm>
<indexterm>
<primary>annotated</primary>
</indexterm>
Creating an annotated tag is simple. Run <literal>git tag -a</literal>.<indexterm>
<primary>git commands</primary><secondary>tag</secondary>
</indexterm>
<indexterm>
<primary>tag</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag -a v1.4 -m "my version 1.4"
$ git tag
v0.1
v1.3
v1.4</programlisting>
<simpara>The <literal>-m</literal> flag specifies a message that&#8217;s stored with the tag.
If you don&#8217;t specify a message, Git launches your text editor for you to enter
the message.</simpara>
<simpara>You see the tag information along with the commit that was tagged by running <literal>git show</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show v1.4
tag v1.4
Tagger: Ben Straub &lt;ben@straub.cc&gt;
Date:   Sat May 3 20:19:12 2014 -0700

my version 1.4

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number</programlisting>
<simpara>You see who made the tag, the date the commit was tagged, the annotation message, and the commit information.</simpara>
</section>
<section xml:id="_lightweight_tags">
<title>Lightweight Tags</title>
<simpara><indexterm>
<primary>tags</primary><secondary>lightweight</secondary>
</indexterm>
<indexterm>
<primary>lightweight</primary>
</indexterm>
Another way to tag commits is with a lightweight tag.
This is basically a pointer to a commit&#8201;&#8212;&#8201;no other information is kept.
To create a lightweight tag, don&#8217;t supply the <literal>-a</literal>, <literal>-s</literal>, or <literal>-m</literal> flags.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag v1.4-lw
$ git tag
v0.1
v1.3
v1.4
v1.4-lw
v1.5</programlisting>
<simpara>This time, when you run <literal>git show</literal>, you don&#8217;t see the extra tag information.<indexterm>
<primary>git commands</primary><secondary>show</secondary>
</indexterm>
<indexterm>
<primary>show</primary>
</indexterm>
You just see the commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number</programlisting>
</section>
<section xml:id="_late_tagging">
<title>Late Tagging</title>
<simpara>You can also tag commits that you&#8217;ve already made.
Suppose your commit history looks like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty=oneline
15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'
a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support
0d52aaab4479697da7686c15f77a3d64d9165190 one more thing
6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'
0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function
4682c3261057305bdd616e23b64b0857d832627b added a todo file
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</programlisting>
<simpara>Now, suppose you forgot to tag the project at v1.2, which was at the <literal>updated rakefile</literal> commit.
You can add the tag after the fact.
To tag that commit, specify the commit ID (or part of it) at the end of the command.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag -a v1.2 9fceb02</programlisting>
<simpara>You see that you&#8217;ve tagged the commit.<indexterm>
<primary>git commands</primary><secondary>tag</secondary>
</indexterm>
<indexterm>
<primary>tag</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag
v0.1
v1.2
v1.3
v1.4
v1.4-lw
v1.5

$ git show v1.2
tag v1.2
Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Feb 9 15:32:16 2009 -0800

version 1.2
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;
Date:   Sun Apr 27 20:43:35 2008 -0700

    updated rakefile
...</programlisting>
</section>
<section xml:id="_sharing_tags">
<title>Sharing Tags</title>
<simpara>By default, <literal>git push</literal> doesn&#8217;t transfer tags to remote servers.<indexterm>
<primary>git commands</primary><secondary>push</secondary>
</indexterm>
<indexterm>
<primary>push</primary>
</indexterm>
You have to explicitly make this happen after you&#8217;ve created a tag.
You do this just like pushing to remotes&#8201;&#8212;&#8201;run <literal>git push origin [tagname]</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin v1.5
Counting objects: 14, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (12/12), done.
Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.
Total 14 (delta 3), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new tag]         v1.5 -&gt; v1.5</programlisting>
<simpara>If you have a lot of tags that you want to push all at once, run <literal>git push --tags</literal>.
This transfers all the tags that weren&#8217;t already there to the remote server.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin --tags
Counting objects: 1, done.
Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.
Total 1 (delta 0), reused 0 (delta 0)
To git@github.com:schacon/simplegit.git
 * [new tag]         v1.4 -&gt; v1.4
 * [new tag]         v1.4-lw -&gt; v1.4-lw</programlisting>
<simpara>Now, when someone else clones or pulls from your repository, they get all your tags as well.</simpara>
</section>
<section xml:id="_deleting_tags">
<title>Deleting Tags</title>
<simpara>To delete a tag on your local repository, run <literal>git tag -d &lt;tagname&gt;</literal>.
For example, we could remove our lightweight tag above by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag -d v1.4-lw
Deleted tag 'v1.4-lw' (was e7d5add)</programlisting>
<simpara>Note that this doesn&#8217;t remove the tag from any remote servers.
To update any remotes, you must run <literal>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</literal>:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin :refs/tags/v1.4-lw
To /git@github.com:schacon/simplegit.git
 - [deleted]         v1.4-lw</programlisting>
</section>
<section xml:id="_checking_out_tags">
<title>Checking out Tags</title>
<simpara>To view the versions of files a tag is pointing to, run <literal>git checkout</literal>, although this puts your repository
in <literal>detached HEAD</literal>' state.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout 2.0.0
Note: checking out '2.0.0'.

Your repository is in 'detached HEAD' state. You can look around, make experimental
changes, and commit them. You can discard any commits you make in this
state without impacting any branches by performing another checkout.

To create a new branch to retain commits you create, you may
do so now or later by using the `-b` flag to `git checkout` again.

  git checkout -b &lt;new-branch&gt;

HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final

$ git checkout 2.0-beta-0.1
Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final
HEAD is now at df3f601... add atlas.json and cover image</programlisting>
<simpara>In <literal>detached HEAD</literal> state, if you make changes and then create a commit, the tag will stay the same,
but your new commit won&#8217;t be on a branch, making it unreachable, except by specifying an exact commit SHA-1 hash.
Thus, if you need to make changes&#8201;&#8212;&#8201;say you&#8217;re fixing a bug in an older version of a file&#8201;&#8212;&#8201;you
generally want to create a branch:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b version2 v2.0.0
Switched to a new branch 'version2'</programlisting>
<simpara>If you do this and then commit, <literal>version2</literal> is slightly different than your <literal>v2.0.0</literal> tag since <literal>version2</literal>
moves forward with new changes, so do be careful.</simpara>
</section>
</section>
<section xml:id="_git_aliases">
<title>Git Aliases</title>
<simpara><indexterm>
<primary>aliases</primary>
</indexterm>
Before we finish this chapter on basic Git, here&#8217;s just one little tip that can make your Git experience simpler: aliases.
We don&#8217;t refer to them later in the book, so now&#8217;s the time to learn how to use them.</simpara>
<simpara>Git doesn&#8217;t automatically try to guess a partially entered command.
If you don&#8217;t want to enter the entire Git command, set up an alias for the command by running <literal>git config</literal>.<indexterm>
<primary>git commands</primary><secondary>config</secondary>
</indexterm>
<indexterm>
<primary>config</primary>
</indexterm>
Here are a couple of examples.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status</programlisting>
<simpara>This means that, for example, instead of typing <literal>git commit</literal>, you can just enter <literal>git ci</literal>.
As you continue using Git, don&#8217;t hesitate to create new aliases for commands you use frequently.</simpara>
<simpara>This technique can also be very useful for creating commands that you think should exist, but don&#8217;t.
For example, to correct the usability problem you encountered when unstaging a file,
add your own unstage alias to Git.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global alias.unstage 'reset HEAD --'</programlisting>
<simpara>This makes the following two commands equivalent:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git unstage fileA
$ git reset HEAD -- fileA</programlisting>
<simpara>The first seems a bit clearer.
It&#8217;s also common to add a <literal>last</literal> alias, like this.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global alias.last 'log -1 HEAD'</programlisting>
<simpara>This way, you can easily see the last commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel &lt;dreamer3@example.com&gt;
Date:   Tue Aug 26 19:48:51 2008 +0800

    test for current head

    Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</programlisting>
<simpara>Maybe you want to create an alias that runs an external command, rather than a Git option.
In that case, start the command with a <literal>!</literal> character.
This is useful if you write your own tools that work with a Git repository.
We demonstrate this by aliasing <literal>git visual</literal> to run <literal>gitk</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global alias.visual '!gitk'</programlisting>
</section>
<section xml:id="_summary_2">
<title>Summary</title>
<simpara>At this point, you know how to perform all the basic local Git operations&#8201;&#8212;&#8201;creating or cloning a repository,
making changes, staging and committing those changes, and viewing the history
of all the changes in the repository.</simpara>
<simpara>Next, we cover Git&#8217;s killer feature: its branching model.</simpara>
</section>
</chapter>
<chapter xml:id="ch03-git-branching">
<title>Git Branching</title>
<simpara><indexterm>
<primary>branches</primary>
</indexterm>
Every modern VCS has some form of branching support.
Branching is when you start a new path of development off an existing path.
You can continue working on both branches without one interfering with the other.
Later on you can merge the two branches back to one development path.
In many VCSs, creating a branch is a somewhat expensive process, often requiring a new copy
of your source code directory, which can take a long time to create in large projects.</simpara>
<simpara>Some people refer to Git&#8217;s branching model as its killer feature. It certainly sets Git apart in the VCS world.
Why is it so special?
The way Git branches is incredibly lightweight, making branching operations nearly instantaneous.
Switching back and forth between branches is just as fast.
Unlike many other VCSs, Git encourages frequent branching and merging, even multiple times a day.
Understanding and mastering Git branching and merging gives you powerful tools
and can entirely change the way you work.</simpara>
<section xml:id="_git_branches_overview">
<title>Branches in a Nutshell</title>
<simpara>To really understand Git branching, we need to take a step back and examine how Git stores files
in a repository.</simpara>
<simpara>As you may remember from <xref linkend="ch01-getting-started"/>, Git doesn&#8217;t store files as a series of changes,
but instead as a series of copies, or <emphasis>snapshots</emphasis>, of what&#8217;s in the staging area.</simpara>
<simpara>When you commit, Git creates a <literal>commit object</literal> and places it and the file(s) you&#8217;re committing into the repository.
The commit object contains a pointer to what you&#8217;re committing, a commit identifier, your name and email address,
a commit message, and the identifiers of the commit&#8217;s parent commit(s)&#8201;&#8212;&#8201;the commit(s) that came directly
before it, if any.
The first commit you make in a repository has no parents, regular commits have one parent,
and merge commits resulting from a merge of two or more branches have multiple parents.
The commit identifier is actually the SHA-1 hash of all the information in the commit,
and is guaranteed to be unique for each commit.</simpara>
<simpara>To visualize this, let&#8217;s assume your working directory contains three files. You stage them and then commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add README test.rb LICENSE
$ git commit -m 'The initial commit of my project'</programlisting>
<simpara>When you run <literal>git commit</literal>, Git adds the information mentioned above to the repository.<indexterm>
<primary>git commands</primary><secondary>commit</secondary>
</indexterm>
<indexterm>
<primary>commit</primary>
</indexterm>
Although this isn&#8217;t strictly technically accurate, you can now visualize
your Git repository as follows (ignore the <emphasis>tree</emphasis> entry for now and
remember <literal>98ca9</literal> is the abbreviated SHA-1 hash of the commit):</simpara>
<figure>
<title>A commit</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/commit.png"/>
</imageobject>
<textobject><phrase>A commit.</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you make some changes and commit again, the next commit stores a pointer to the commit
that came immediately before it. The same is true for the next commit.</simpara>
<figure>
<title>Commits and their parents</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/commits-and-parents.png"/>
</imageobject>
<textobject><phrase>Commits and their parents.</phrase></textobject>
</mediaobject>
</figure>
<simpara>A branch in Git is simply a pointer to one of these commits.
The default branch is <literal>master</literal>.
Every time you commit, <literal>master</literal> moves forward automatically to point to the
last commit you made. The illustration below shows this.</simpara>
<note>
<simpara><literal>master</literal> isn&#8217;t special.<indexterm>
<primary>master</primary>
</indexterm>
It&#8217;s exactly like any other branch.
The only reason nearly every repository has one is that <literal>git init</literal> creates it by default,
and most people don&#8217;t bother to change it.</simpara>
</note>
<figure>
<title>A branch and its commit history</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/branch-and-history.png"/>
</imageobject>
<textobject><phrase>A branch and its commit history.</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_create_new_branch">
<title>Creating a New Branch</title>
<simpara><indexterm>
<primary>branches</primary><secondary>creating</secondary>
</indexterm>
<indexterm>
<primary>creating</primary>
</indexterm>
What happens when you create a new branch?
This simply creates a new pointer.
Let&#8217;s say you create a new branch called <literal>testing</literal>
by running <literal>git branch</literal>.<indexterm>
<primary>git commands</primary><secondary>branch</secondary>
</indexterm>
<indexterm>
<primary>branch</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch testing</programlisting>
<simpara>This creates a new pointer that points to the same branch you&#8217;re currently on.</simpara>
<figure>
<title>Two branches pointing into the same series of commits</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/two-branches.png"/>
</imageobject>
<textobject><phrase>Two branches pointing into the same series of commits.</phrase></textobject>
</mediaobject>
</figure>
<simpara>How does Git know what branch you&#8217;re currently on?
Git keeps a special pointer called <literal>HEAD</literal> that points to the branch you&#8217;re currently on.
Note that this is a lot different than the concept of <literal>HEAD</literal> in other VCSs you may be used to, such as Subversion or CVS.
In this case, you&#8217;re still on <literal>master</literal>.
<literal>git branch</literal> only <emphasis>creates</emphasis> a new branch&#8201;&#8212;&#8201;it doesn&#8217;t switch you to that branch.</simpara>
<figure>
<title>HEAD pointing to a branch</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/head-to-master.png"/>
</imageobject>
<textobject><phrase>HEAD pointing to a branch.</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can easily see your current branch by running <literal>git log --oneline --decorate</literal>.
This shows where the branch pointers are pointing. (The --oneline flag makes the output easier to read).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline --decorate
f30ab (HEAD -&gt; master, testing) add feature #32 - ability to add new formats to the central interface
34ac2 Fixed bug #1328 - stack overflow under certain conditions
98ca9 The initial commit of my project</programlisting>
<simpara><literal>master</literal> and <literal>testing</literal> both point to the <literal>f30ab</literal> commit.</simpara>
</section>
<section xml:id="_switching_branches">
<title>Switching Branches</title>
<simpara><indexterm>
<primary>branches</primary><secondary>switching</secondary>
</indexterm>
<indexterm>
<primary>switching</primary>
</indexterm>
To switch branches, run <literal>git checkout</literal>.<indexterm>
<primary>git commands</primary><secondary>checkout</secondary>
</indexterm>
<indexterm>
<primary>checkout</primary>
</indexterm>
Let&#8217;s switch to <literal>testing</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout testing</programlisting>
<simpara>This makes <literal>HEAD</literal> point to <literal>testing</literal>.</simpara>
<figure>
<title>HEAD points to the current branch</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/head-to-testing.png"/>
</imageobject>
<textobject><phrase>HEAD points to the current branch.</phrase></textobject>
</mediaobject>
</figure>
<simpara>What&#8217;s the significance of that? Well, let&#8217;s make another commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ vim test.rb
$ git commit -a -m 'made a change'</programlisting>
<figure>
<title>HEAD moves forward when a commit is made</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/advance-testing.png"/>
</imageobject>
<textobject><phrase>HEAD moves forward when a commit is made.</phrase></textobject>
</mediaobject>
</figure>
<simpara>This is interesting, because now <literal>testing</literal> has moved forward, but <literal>master</literal> still points to the commit
you were on when you ran <literal>git checkout</literal> to switch branches. Let&#8217;s switch back to <literal>master</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout master</programlisting>
<figure>
<title>HEAD moves when you checkout</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/checkout-master.png"/>
</imageobject>
<textobject><phrase>HEAD moves when you checkout.</phrase></textobject>
</mediaobject>
</figure>
<simpara>That command did two things.
It moved <literal>HEAD</literal> back to point to <literal>master</literal>, and it changed the files in your working directory back
to the snapshot pointed to by <literal>master</literal>.
The work you&#8217;ve done in <literal>testing</literal> isn&#8217;t affected.</simpara>
<note>
<title>Switching branches changes files in your working directory</title>
<simpara>It&#8217;s important to note that after switching branches, your working directory now contains the files from the
latest commit in the branch you just switched to. If you have uncommitted changes in your working directory
that can&#8217;t be automatically merged into the branch you&#8217;re attempting to switch to, Git doesn&#8217;t let you switch.</simpara>
</note>
<simpara>Let&#8217;s make a few changes and commit again. Remember, your current branch is <literal>master</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ vim test.rb
$ git commit -a -m 'made other changes'</programlisting>
<simpara>Now your project history has diverged (see <xref linkend="divergent_history"/>).
You created and switched to <literal>testing</literal>, did some work on it, and then switched back to <literal>master</literal>
and did more work there.
You can switch back and forth between branches and merge them together when you&#8217;re ready.
And you did all that with simple <literal>git branch</literal>, <literal>git checkout</literal>, and <literal>git commit</literal> commands.</simpara>
<figure xml:id="divergent_history">
<title>Divergent history</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/advance-master.png"/>
</imageobject>
<textobject><phrase>Divergent history.</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can also easily see this by running <literal>git log --oneline --decorate --graph --all</literal>.
You see the history of your commits, showing where your branch pointers are and how your branches have diverged.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project</programlisting>
<simpara>Because a branch in Git is actually a small file that contains the 40-character SHA-1 hash of the
commit it points to, branches are cheap to create and destroy.
Creating a new branch is as quick and simple as writing an SHA-1 hash to a file.</simpara>
<simpara>This is in sharp contrast to the way most older VCS tools implement branches, which involves copying
all of the project&#8217;s files into a second directory.
This can take quite a while, depending on the size of the project. In Git this is always instantaneous
because only an SHA-1 hash has to be written.
This encourages developers to create and use branches often.</simpara>
<simpara>Let&#8217;s see why.</simpara>
</section>
</section>
<section xml:id="_basic_branching_and_merging">
<title>Basic Branching and Merging</title>
<simpara>Let&#8217;s go through a simple example of branching and merging using a real-world workflow.
Follow these steps.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Do some work on a website.</simpara>
</listitem>
<listitem>
<simpara>Test and then commit the work to your production branch.</simpara>
</listitem>
<listitem>
<simpara>Create a branch for a new story.</simpara>
</listitem>
<listitem>
<simpara>Do some work in the new story branch.</simpara>
</listitem>
</orderedlist>
<simpara>At this point, you receive a call saying that there&#8217;s a critical issue on the website
and you need to create a hotfix. Do the following:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Switch to your production branch.</simpara>
</listitem>
<listitem>
<simpara>Create a branch to add the hotfix.</simpara>
</listitem>
<listitem>
<simpara>After the hotfix is tested, merge the hotfix branch into the production branch.</simpara>
</listitem>
<listitem>
<simpara>Switch back to your new story branch and continue working.</simpara>
</listitem>
</orderedlist>
<section xml:id="_basic_branching">
<title>Basic Branching</title>
<simpara><indexterm>
<primary>branches</primary><secondary>basic workflow</secondary>
</indexterm>
<indexterm>
<primary>basic workflow</primary>
</indexterm>
First, let&#8217;s say you&#8217;re working on your website and have a couple of commits already on <literal>master</literal>.</simpara>
<figure>
<title>A simple commit history</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-branching-1.png"/>
</imageobject>
<textobject><phrase>A simple commit history.</phrase></textobject>
</mediaobject>
</figure>
<simpara>You&#8217;ve decided that you&#8217;re going to work on issue #53 in your issue-tracking system.
To create a branch and switch to it at the same time, run <literal>git checkout</literal> with the <literal>-b</literal> flag.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b iss53
Switched to a new branch "iss53"</programlisting>
<simpara>This is shorthand for:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch iss53
$ git checkout iss53</programlisting>
<figure>
<title>Creating a new branch pointer</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-branching-2.png"/>
</imageobject>
<textobject><phrase>Creating a new branch pointer.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Work on issue #53 and make a commit (C3).
This moves <literal>iss53</literal> forward, because that&#8217;s the branch you&#8217;re on (that is, <literal>HEAD</literal> is pointing to <literal>iss53</literal>).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'</programlisting>
<figure>
<title>The <literal>iss53</literal> branch has moved forward with your work</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-branching-3.png"/>
</imageobject>
<textobject><phrase>The `iss53` branch has moved forward with your work.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now you get a call saying that there&#8217;s an issue with the website that&#8217;s running the code from <literal>master</literal>,
and you need to fix it immediately.
When using Git you don&#8217;t have to deploy your fix along with the changes you&#8217;ve made in <literal>iss53</literal>.
You also don&#8217;t have to put a lot of effort into reverting the changes in <literal>iss53</literal> before you can work
on applying your fix to <literal>master</literal>. All you have to do is checkout <literal>master</literal>.</simpara>
<simpara>However, before doing so, note that if your working directory or staging area has uncommitted
changes that conflict with the branch you&#8217;re checking out, Git doesn&#8217;t let you switch branches.
It&#8217;s best to have a clean working directory, that is a working directory with no uncommitted changes,
when you switch branches.
There are ways to get around this (namely, stashing, and commit amending) that we&#8217;ll cover later on,
in <xref linkend="_git_stashing"/>.
For now, let&#8217;s assume you&#8217;ve committed all your changes in <literal>iss53</literal>, so you can switch to <literal>master</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout master
Switched to branch 'master'</programlisting>
<simpara>At this point, your working directory contains the state of the project that existed after you made commit <literal>C2</literal>.
This is exactly the way it was before you started working on issue #53.
This is an important point to remember. When you switch branches, Git automatically changes the content of
your working directory to look like it did the last time you committed on the branch you&#8217;re switching to.</simpara>
<simpara>Next, create the hotfix. Start by creating a hotfix branch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)</programlisting>
<figure>
<title>Hotfix branch based on <literal>master</literal></title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-branching-4.png"/>
</imageobject>
<textobject><phrase>Hotfix branch based on `master`.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Run your tests, make sure the hotfix does what you want, and merge it back into <literal>master</literal> to deploy
to your production web server. Do this by running <literal>git merge</literal>.<indexterm>
<primary>git commands</primary><secondary>merge</secondary>
</indexterm>
<indexterm>
<primary>merge</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)</programlisting>
<simpara>Notice the term <literal>Fast-forward</literal>.
Because the commit (<literal>C4</literal>) pointed to by the branch you merged in (<literal>hotfix</literal>) is an
child of the commit (<literal>C2</literal>) you&#8217;re on, Git simply moves <literal>master</literal> forward to point to
what <literal>hotfix</literal> is pointing to.
To put that another way, when merging one commit (<literal>hotfix</literal>) with another commit (<literal>master</literal>)
that can be reached by following the first commit&#8217;s (<literal>hotfix</literal>) history, Git simplifies things
by moving the pointer (<literal>master</literal>) forward to
the value of the pointer (<literal>hotfix</literal>) being merged because there&#8217;s nothing that actually needs merging&#8201;&#8212;&#8201;this
is called a <literal>fast-forward</literal> merge.</simpara>
<simpara>Your change is now pointed to by <literal>master</literal>, and you can now deploy the fix.</simpara>
<figure>
<title><literal>master</literal> is fast-forwarded to <literal>hotfix</literal></title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-branching-5.png"/>
</imageobject>
<textobject><phrase>`master` is fast-forwarded to `hotfix`.</phrase></textobject>
</mediaobject>
</figure>
<simpara>After your super-important fix is deployed, you&#8217;re ready to switch back to the work you
were doing before you were interrupted.
However, first delete <literal>hotfix</literal> because you no longer need it&#8201;&#8212;&#8201;<literal>master</literal> points at the same place.
Delete it with the <literal>-d</literal> flag to <literal>git branch</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch -d hotfix
Deleted branch hotfix (3a0874c).</programlisting>
<simpara>Remember, this just deletes a pointer&#8201;&#8212;&#8201;none of your files are changed.</simpara>
<simpara>Now you can switch back to <literal>iss53</literal> and continue working on it.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)</programlisting>
<figure>
<title>Work continues on <literal>iss53</literal></title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-branching-6.png"/>
</imageobject>
<textobject><phrase>Work continues on `iss53`.</phrase></textobject>
</mediaobject>
</figure>
<simpara>It&#8217;s worth noting here that the work you did in <literal>hotfix</literal> isn&#8217;t contained in <literal>iss53</literal>.
If you need to pull the hotfix into <literal>iss53</literal>, merge <literal>master</literal> into <literal>iss53</literal> by running <literal>git merge master</literal>,
or wait to integrate the work until you decide to merge <literal>iss53</literal> back into <literal>master</literal> later.</simpara>
</section>
<section xml:id="_basic_merging">
<title>Basic Merging</title>
<simpara><indexterm>
<primary>branches</primary><secondary>merging</secondary>
</indexterm>
<indexterm>
<primary>merging</primary>
</indexterm><indexterm>
<primary>merging</primary>
</indexterm>
Suppose you&#8217;ve decided that your work on <literal>iss53</literal> is complete and ready to be merged into <literal>master</literal>.
To do that, merge <literal>iss53</literal> into <literal>master</literal>, much like you merged <literal>hotfix</literal> into <literal>master</literal> earlier.
All you have to do is check out the branch you wish to merge into and then run <literal>git merge</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)</programlisting>
<simpara>This looks a bit different than the <literal>hotfix</literal> merge you did earlier.
In this case, the branches being merged diverged from an older common commit (<literal>C2</literal>).
Because the latest commit (<literal>C4</literal>) on the branch you&#8217;re on (<literal>master</literal>) isn&#8217;t a direct ancestor of the
latest commit (<literal>C5</literal>) on the branch you&#8217;re merging in (<literal>iss53</literal>), Git has some extra work to do.
In this case, Git does a three-way merge, using the two commits pointed to by the branch tips (<literal>C4</literal> and <literal>C5</literal>)
and their common ancestor (<literal>C2</literal>).</simpara>
<figure>
<title>Three snapshots used in a typical merge</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-merging-1.png"/>
</imageobject>
<textobject><phrase>Three snapshots used in a typical merge.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Instead of just moving <literal>master</literal> forward, Git creates a new snapshot that results
from this three-way merge and automatically creates a new commit (<literal>C6</literal>) that points to it.
This is referred to as a merge commit, and is special in that it has more than one parent.</simpara>
<figure>
<title>A merge commit</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-merging-2.png"/>
</imageobject>
<textobject><phrase>A merge commit.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now that your work is merged, you have no further need for <literal>iss53</literal>
so you can delete it.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch -d iss53</programlisting>
</section>
<section xml:id="_basic_merge_conflicts">
<title>Basic Merge Conflicts</title>
<simpara><indexterm>
<primary>merging</primary><secondary>conflicts</secondary>
</indexterm>
<indexterm>
<primary>conflicts</primary>
</indexterm>
Occasionally, this process doesn&#8217;t go smoothly.
If you changed the same part of the same file differently in the two branches you&#8217;re merging,
Git doesn&#8217;t know how to merge them cleanly.  If your fix for issue #53 modified the same part
of a file as the <literal>hotfix</literal>, you get a merge conflict that looks something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.</programlisting>
<simpara>Git didn&#8217;t automatically create a new merge commit.
It paused the process while you resolve the conflict.
To see which files are unmerged at any point after a merge conflict, run <literal>git status</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add &lt;file&gt;..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")</programlisting>
<simpara>Anything with merge conflicts that haven&#8217;t been resolved is listed as unmerged.
Git inserts standard conflict-resolution marker characters into the files containing conflicts to make it easier
to find and resolve those conflicts. Your file contains a section that looks something like</simpara>
<programlisting language="html" linenumbering="unnumbered">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
&lt;div id="footer"&gt;contact : email.support@github.com&lt;/div&gt;
=======
&lt;div id="footer"&gt;
 please contact us at support@github.com
&lt;/div&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</programlisting>
<simpara>This means the conflicts in index.html in <literal>HEAD</literal> (on <literal>master</literal>, because that was the branch
you had checked out when you ran <literal>git merge</literal>) are in the top part of that section
(everything above the <literal>=======</literal>), while the conflicts in <literal>iss53</literal> are in the bottom part.
In order to resolve the conflict, you have to either choose one side or the other,
or merge the content yourself. For instance, you might resolve this conflict by replacing
the entire block with</simpara>
<programlisting language="html" linenumbering="unnumbered">&lt;div id="footer"&gt;
please contact us at email.support@github.com
&lt;/div&gt;</programlisting>
<simpara>This resolution has a little from each section, and you&#8217;ve removed the <literal>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</literal>, <literal>=======</literal>,
and <literal>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</literal> lines. After you&#8217;ve resolved all the conflicts, run <literal>git add</literal> on each
file to put their latest content in the staging area. You still have to run <literal>git commit</literal>
to actually commit the changes.</simpara>
<simpara>To use a graphical tool to resolve conflicts, run <literal>git mergetool</literal>, which fires up a visual
merge tool and walks you through resolving the conflicts.<indexterm>
<primary>git commands</primary><secondary>mergetool</secondary>
</indexterm>
<indexterm>
<primary>mergetool</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git mergetool

This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):</programlisting>
<simpara>To use a merge tool other than the default (Git chose <literal>opendiff</literal> in this case because the command was
run on a Mac), pick one of the supported tools listed at the top after "one of the following tools."
Just type the name of the tool you&#8217;d rather use.</simpara>
<note>
<simpara>If you need more advanced tools for resolving tricky merge conflicts, we cover more on merging in <xref linkend="_advanced_merging"/>.</simpara>
</note>
<simpara>After you exit the merge tool, Git asks you if the merge was successful.
If you tell the script that it was, it stages the files for you.
Run <literal>git status</literal> again to verify that all conflicts have been resolved.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html</programlisting>
<simpara>If you&#8217;re happy with that, and you verify that everything that had conflicts has been staged,
run <literal>git commit</literal> to finalize the merge commit.
The commit message by default looks something like</simpara>
<programlisting language="console" linenumbering="unnumbered">Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#	.git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#	modified:   index.html
#</programlisting>
<simpara>If you think it would be helpful to others looking at this merge in the future, modify
this commit message to contain details about how you resolved the merge and explain why you made
the changes if it isn&#8217;t obvious.</simpara>
</section>
</section>
<section xml:id="_branch_management">
<title>Branch Management</title>
<simpara><indexterm>
<primary>branches</primary><secondary>managing</secondary>
</indexterm>
<indexterm>
<primary>managing</primary>
</indexterm>
Now that you&#8217;ve created, merged, and deleted some branches, let&#8217;s look at some branch
management techniques that come in handy when you begin using branches regularly.</simpara>
<simpara><literal>git branch</literal> does more than just create and delete branches.<indexterm>
<primary>git commands</primary><secondary>branch</secondary>
</indexterm>
<indexterm>
<primary>branch</primary>
</indexterm>
If you run it with no arguments, you see a simple listing of your branches.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch
  iss53
* master
  testing</programlisting>
<simpara>The <literal>*</literal> character that prefixes <literal>master</literal> indicates the branch that you currently have checked out (i.e.,
the branch that <literal>HEAD</literal> points to). This means that if you commit now, <literal>master</literal> moves forward.
To see the last commit on each branch, run <literal>git branch -v</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes</programlisting>
<simpara>The <literal>--merged</literal> and <literal>--no-merged</literal> flags are useful for filtering this list to contain only
branches that you have or haven&#8217;t yet merged into the branch you&#8217;re currently on.
To see which branches are already merged into the branch you&#8217;re on, run <literal>git branch --merged</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch --merged
  iss53
* master</programlisting>
<simpara>Because you already merged in <literal>iss53</literal> earlier, you see it in the output.
Branches in this list without the <literal>*</literal> in front of them are generally fine to delete
by running <literal>git branch -d</literal>. You&#8217;ve already merged them into another branch,
so you&#8217;re not going to lose anything.</simpara>
<simpara>To see all the branches that contain changes you haven&#8217;t yet merged in, run <literal>git branch --no-merged</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch --no-merged
  testing</programlisting>
<simpara>Any branches it shows contain changes that haven&#8217;t been merged in yet.
Trying to delete them with <literal>git branch -d</literal> fails.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch -d testing
error: The branch 'testing' is not fully merged.
If you are sure you want to delete it, run 'git branch -D testing'.</programlisting>
<simpara>If you really do want to delete the branch and lose any unmerged changes, you can force the deletion with the <literal>-D</literal> flag, as the helpful message points out.</simpara>
<simpara>The options described above, <literal>--merged</literal> and <literal>--no-merged</literal>, if not given a commit or
branch name as an argument, show what is, respectively, merged or not merged into your
<emphasis>current</emphasis> branch.</simpara>
<simpara>You can always provide an additional argument to show the merge state with respect
to some other branch without checking out that other branch first. For example, to show
what isn&#8217;t merged into <literal>master</literal></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout testing
$ git branch --no-merged master
  topicA
  featureB</programlisting>
</section>
<section xml:id="_branching_workflows">
<title>Branching Workflows</title>
<simpara>You now have the basics of branching and merging down. In this section, we cover some common ways
lightweight branching can make your job easier.</simpara>
<section xml:id="_long_running_branches">
<title>Long-Running Branches</title>
<simpara><indexterm>
<primary>branches</primary><secondary>long-running</secondary>
</indexterm>
<indexterm>
<primary>long-running</primary>
</indexterm>
Because Git uses a simple three-way merge, frequent merging of one branch into another is generally easy to do.
This means you can have several active branches for different stages of your development cycle,
and merge regularly as your cycle progresses.</simpara>
<simpara>Many Git developers embrace this approach, and only have production code in <literal>master</literal>&#8201;&#8212;&#8201;possibly
only code that has been or is about to be released. They have another branch named <literal>develop</literal> or <literal>next</literal>
that they work from to test stability. It isn&#8217;t necessarily always stable, but whenever it
gets to a stable state, it can be merged into <literal>master</literal>. This test branch is used to pull in topic
branches (short-lived branches, like your earlier <literal>iss53</literal>) when they&#8217;re ready, to make sure they
pass all tests and don&#8217;t introduce bugs.</simpara>
<simpara>In reality, we&#8217;re talking about pointers moving along the line of commits you&#8217;re making.
The stable branches are farther to the left in your commit history, and the bleeding-edge branches
are farther to the right.</simpara>
<figure>
<title>A linear view of progressive-stability branching</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/lr-branches-1.png"/>
</imageobject>
<textobject><phrase>A linear view of progressive-stability branching.</phrase></textobject>
</mediaobject>
</figure>
<simpara>It&#8217;s generally easier to think about them as paths, where commits graduate to a more stable
path when they&#8217;re fully tested.</simpara>
<figure xml:id="lrbranch_b">
<title>A path view of progressive-stability branching</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/lr-branches-2.png"/>
</imageobject>
<textobject><phrase>A path view of progressive-stability branching.</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can follow this approach for several levels of stability.
Some larger projects have a <literal>proposed</literal> or <literal>pu</literal> (proposed updates) branch that contains merged
branches that may not be ready to go into <literal>next</literal> or <literal>master</literal>. The idea is that your branches are
at various levels of stability. When they reach a more stable level, they&#8217;re merged into the branch above them.
Again, having multiple long-running branches isn&#8217;t necessary, but it&#8217;s often helpful,
especially when you&#8217;re dealing with very large or complex projects.</simpara>
</section>
<section xml:id="_topic_branch">
<title>Topic Branches</title>
<simpara><indexterm>
<primary>branches</primary><secondary>topic</secondary>
</indexterm>
<indexterm>
<primary>topic</primary>
</indexterm>
Topic branches, however, are useful in projects of any size.
A topic branch is a short-lived branch that you create for a single particular purpose, such as
fixing a bug or adding a feature. This is something you&#8217;ve likely never done with a VCS before
because it&#8217;s generally too expensive to create and merge branches. But in Git it&#8217;s common to create, work on,
merge, and delete branches several times a day.</simpara>
<simpara>You saw this in the last section with <literal>iss53</literal> and <literal>hotfix</literal>.
You deleted these branches right after merging them into your main branch.
This technique allows you to context-switch quickly and completely&#8201;&#8212;&#8201;because your work is
separated into paths where all the changes for the branch&#8217;s goal are done.
You can keep the changes there for minutes, days, or months, and merge them when they&#8217;re ready,
regardless of the order in which they were created or worked on.</simpara>
<simpara>Consider an example of doing some work on <literal>master</literal>, creating <literal>iss91</literal> for an issue, working on it for a bit,
creating <literal>iss91v2</literal> to try another way of handling the same thing, going back to <literal>master</literal> and working there
for a while, and then creating <literal>dumbidea</literal> to do some work that you&#8217;re not sure is a good idea. Your commit history
looks something like</simpara>
<figure>
<title>Multiple topic branches</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topic-branches-1.png"/>
</imageobject>
<textobject><phrase>Multiple topic branches.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now, let&#8217;s say you decide you like the solution in <literal>iss91v2</literal> best. You also showed <literal>dumbidea</literal> to your coworkers and they
think it&#8217;s great. You can throw away the original <literal>iss91</literal> (losing commits <literal>C5</literal> and <literal>C6</literal>) and merge
in the other two branches. Your history then looks like</simpara>
<figure>
<title>History after merging <literal>dumbidea</literal> and <literal>iss91v2</literal></title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topic-branches-2.png"/>
</imageobject>
<textobject><phrase>History after merging `dumbidea` and `iss91v2`.</phrase></textobject>
</mediaobject>
</figure>
<simpara>We go into more detail about the various possible workflows in
<xref linkend="ch05-distributed-git"/>, so before you decide which branching
scheme your next project uses, be sure to read that chapter.</simpara>
<simpara>It&#8217;s important to remember that all these branches are completely local.
When you&#8217;re branching and merging, everything is being done only in your Git repository&#8201;&#8212;&#8201;no
communication with other servers is happening.</simpara>
</section>
</section>
<section xml:id="_remote_branches">
<title>Remote References and Remote Branches</title>
<simpara><indexterm>
<primary>branches</primary><secondary>remote</secondary>
</indexterm>
<indexterm>
<primary>remote</primary>
</indexterm><indexterm>
<primary>references</primary><secondary>remote</secondary>
</indexterm>
<indexterm>
<primary>remote</primary>
</indexterm>
Remote references are references (pointers) in a local repository that point to branches, tags,
and other things in remote repositories. You see a full list of remote references explicitly by
running <literal>git ls-remote [remote]</literal>, or <literal>git remote show [remote]</literal> for only remote branches.
These commands require online access because they contact remote repositories
to retrieve the information the commands display.</simpara>
<simpara>Another way of dealing with remote references is by using remote-tracking branches,
which are references to remote branches.
They appear as local branches that you can&#8217;t move. Instead, they&#8217;re updated automatically whenever
you reference the remote branch. Remote-tracking branches act as bookmarks to remind you where the
branches in your remote repositories were the last time you contacted them.</simpara>
<simpara>They have names of the form <literal>(remote)/(branch)</literal>. For instance, to see what <literal>master</literal> on your <literal>origin</literal> remote
looked like the last time you contacted it, checkout <literal>origin/master</literal>. If you were working on an issue with
a partner and they made a change to <literal>iss53</literal> on the <literal>origin</literal> remote, you might have your own local <literal>iss53</literal>,
but the remote-tracking branch on the server would point to the commit at <literal>origin/iss53</literal>.</simpara>
<simpara>This may be a bit confusing, so let&#8217;s look at an example.
Let&#8217;s say you have a Git server on your network called <literal>git.ourcompany.com</literal>.
If you clone a repository from it, Git automatically creates an <literal>origin</literal> remote reference, copies all the data
from the remote repository into a local repository, and creates a local pointer called <literal>origin/master</literal> pointing
to <literal>master</literal> on the remote repository. Git also creates your own local <literal>master</literal> starting at
the same commit as origin&#8217;s <literal>master</literal>, so you have something to work from.</simpara>
<note>
<title><literal>origin</literal> isn&#8217;t a special name</title>
<simpara>Just like the branch name <literal>master</literal> doesn&#8217;t have any special meaning in Git, neither does <literal>origin</literal>. <literal>master</literal> is
the default name for the initial branch created when you run <literal>git init</literal>, which is the reason it&#8217;s widely
used. <literal>origin</literal> is the default name for a remote branch when you run <literal>git clone</literal>. If you run
<literal>git clone -o booyah</literal> instead, then <literal>booyah/master</literal> is your default remote branch.<indexterm>
<primary>origin</primary>
</indexterm></simpara>
</note>
<figure>
<title>Server and local repositories after cloning</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/remote-branches-1.png"/>
</imageobject>
<textobject><phrase>Server and local repositories after cloning.</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you do some work on your local <literal>master</literal>, and, in the meantime, someone else modifies <literal>master</literal>
on <literal>git.ourcompany.com</literal>, then the two <literal>master</literal> branches move forward independently.
Also, as long as you don&#8217;t contact your origin server, your <literal>origin/master</literal> doesn&#8217;t move.</simpara>
<figure>
<title>Local and remote work can diverge</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/remote-branches-2.png"/>
</imageobject>
<textobject><phrase>Local and remote work can diverge.</phrase></textobject>
</mediaobject>
</figure>
<simpara>To synchronize your repository with the remote repository, run <literal>git fetch origin</literal>.
This command fetches any commits from <literal>origin/master</literal> that you don&#8217;t already have, and updates
your local repository, moving your <literal>origin/master</literal> pointer to its up-to-date position.</simpara>
<figure>
<title><literal>git fetch</literal> updates your remote references</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/remote-branches-3.png"/>
</imageobject>
<textobject><phrase>`git fetch` updates your remote references.</phrase></textobject>
</mediaobject>
</figure>
<simpara>To demonstrate what having multiple remote branches looks like, let&#8217;s assume you have another internal Git
server that&#8217;s used only for development by one of your sprint teams.
This server is at <literal>git.team1.ourcompany.com</literal>.
Add it as a new remote reference to the project you&#8217;re currently working on by running
<literal>git remote add</literal>, as we described in <xref linkend="ch02-git-basics-chapter"/>.
Name this remote <literal>teamone</literal>, which is your shortname for that remote repository.</simpara>
<figure>
<title>Adding another server as a remote</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/remote-branches-4.png"/>
</imageobject>
<textobject><phrase>Adding another server as a remote.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now, run <literal>git fetch teamone</literal> to fetch everything on the remote <literal>teamone</literal> server that you don&#8217;t have yet on your computer.
Because <literal>teamone</literal> has a subset of the data on your <literal>origin</literal> server, Git fetches no data but instead creates
a remote-tracking branch called <literal>teamone/master</literal> and points it to the commit that <literal>teamone</literal> has as its <literal>master</literal>.</simpara>
<figure>
<title>Remote-tracking branch for <literal>teamone/master</literal></title>
<mediaobject>
<imageobject>
<imagedata fileref="images/remote-branches-5.png"/>
</imageobject>
<textobject><phrase>Remote tracking branch for `teamone/master`.</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_pushing_branches">
<title>Pushing</title>
<simpara><indexterm>
<primary>pushing</primary>
</indexterm>
To share a branch with the world, push it to a remote server that you have write access to
and the rest of the world can read from.
Even after pushing, your local branches aren&#8217;t automatically synchronized with the remote server you write to.
You have to explicitly push the local branches you want to share.</simpara>
<simpara>If you have a branch named <literal>serverfix</literal> that you want to share, push it the same way you pushed
your first branch. Run <literal>git push &lt;remote&gt; &lt;branch&gt;</literal>.<indexterm>
<primary>git commands</primary><secondary>push</secondary>
</indexterm>
<indexterm>
<primary>push</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -&gt; serverfix</programlisting>
<simpara>This is a bit of a shortcut.
This means take my <literal>serverfix</literal> local branch and sync it with the origin&#8217;s <literal>serverfix</literal> branch.
You can also run <literal>git push origin serverfix:serverfix</literal>, which does the same thing. It says, take my
<literal>serverfix</literal> local branch and sync it with the remote&#8217;s <literal>serverfix</literal> branch. Use this form to push a local branch
to a remote branch that has a different name than the local branch.
If you don&#8217;t want the remote branch to be called <literal>serverfix</literal>, you could instead run
<literal>git push origin serverfix:awesomebranch</literal> to push your local <literal>serverfix</literal> to the remote <literal>awesomebranch</literal>.</simpara>
<note>
<title>Don&#8217;t enter your password every time</title>
<simpara>If you&#8217;re using an HTTPS URL in the remote name, the Git server on the remote server prompts you for your
username and password.</simpara>
<simpara>If you don&#8217;t want to enter them every time you push, set up a credential cache.
The simplest configuration is just to keep the cache in memory for a few minutes,
which you can easily do by running <literal>git config --global credential.helper cache</literal>.</simpara>
<simpara>For more information on the various credential caching options available, see <xref linkend="_credential_caching"/>.</simpara>
</note>
<simpara>The next time one of your collaborators fetches from the remote server,
they get a reference to where the server&#8217;s
version of <literal>serverfix</literal> is. This reference is the remote branch <literal>origin/serverfix</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -&gt; origin/serverfix</programlisting>
<simpara>It&#8217;s important to note that fetching new remote-tracking branches doesn&#8217;t automatically create local,
editable copies of the files in the remote branches.
In the example above, for example, you don&#8217;t get a new <literal>serverfix</literal> branch&#8201;&#8212;&#8201;you only have
an <literal>origin/serverfix</literal> pointer that you can&#8217;t modify.</simpara>
<simpara>To merge this work into your current working directory, run <literal>git merge origin/serverfix</literal>.
If you want your own <literal>serverfix</literal> branch that you can work on, base it off your remote-tracking branch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</programlisting>
<simpara>This gives you a local branch that you can work on that starts where <literal>origin/serverfix</literal> points.</simpara>
</section>
<section xml:id="_tracking_branches">
<title>Tracking Branches</title>
<simpara><indexterm>
<primary>branches</primary><secondary>tracking</secondary>
</indexterm>
<indexterm>
<primary>tracking</primary>
</indexterm><indexterm>
<primary>branches</primary><secondary>upstream</secondary>
</indexterm>
<indexterm>
<primary>upstream</primary>
</indexterm>
Checking out a local branch from a remote-tracking branch automatically creates
what&#8217;s called a <literal>tracking branch</literal> (and the branch it tracks is called an upstream branch).
Tracking branches are local branches that have a direct relationship to a remote branch.
If you&#8217;re on a tracking branch and run <literal>git pull</literal>, Git automatically knows which server to fetch
from and which branch to merge into.</simpara>
<simpara>When you clone a repository, this generally automatically creates <literal>master</literal> that tracks <literal>origin/master</literal>.
However, you can set up other tracking branches&#8201;&#8212;&#8201;ones that track branches on other remotes, or don&#8217;t track <literal>master</literal>.
The simple case is the example you just saw: running <literal>git checkout -b [branch] [remotename]/[branch]</literal>.
This is a common enough operation that Git provides the <literal>--track</literal> flag.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</programlisting>
<simpara>In fact, this is so common that there&#8217;s even a shortcut for that shortcut.
If the branch name you&#8217;re trying to checkout doesn&#8217;t exist and exactly matches the name of only one remote,
Git creates a tracking branch for you.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</programlisting>
<simpara>To set up a local branch with a different name than the remote branch,
you can easily use a different local branch name.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'</programlisting>
<simpara>Now, your local <literal>sf</literal> automatically pulls from <literal>origin/serverfix</literal>.</simpara>
<simpara>If you already have a local branch and want to set it to a remote branch you just pulled, or want to
change the upstream branch you&#8217;re tracking, use the <literal>-u</literal> or <literal>--set-upstream-to</literal> flag
to <literal>git branch</literal> to explicitly set what you&#8217;re tracking.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.</programlisting>
<note>
<title>Upstream shorthand</title>
<simpara>When you have a tracking branch set up, you can reference its upstream branch with
the <literal>@{upstream}</literal> or <literal>@{u}</literal> shorthand. So if you&#8217;re on <literal>master</literal> and it&#8217;s tracking <literal>origin/master</literal>,
run something like <literal>git merge @{u}</literal> instead of <literal>git merge origin/master</literal>.<indexterm>
<primary>@{u}</primary>
</indexterm><indexterm>
<primary>@{upstream}</primary>
</indexterm></simpara>
</note>
<simpara>To see what tracking branches you have set up, add the <literal>-vv</literal> flag to <literal>git branch</literal>.
This lists your local branches with extra information, including what each branch is tracking and if
your local branch is ahead, behind, or both compared to what you&#8217;re tracking.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new</programlisting>
<simpara>Here we see that <literal>iss53</literal> is tracking <literal>origin/iss53</literal> and is <literal>ahead</literal> by two, meaning that we have two
local commits that aren&#8217;t pushed to the server. We also see that <literal>master</literal> is tracking <literal>origin/master</literal>
and is up to date. Next, we see that <literal>serverfix</literal> is tracking <literal>server-fix-good</literal> on the <literal>teamone</literal> server
and is ahead by three and behind by one, meaning there&#8217;s one commit on the remote server we haven&#8217;t merged in
yet and three local commits that we haven&#8217;t pushed. Finally, we see that <literal>testing</literal> isn&#8217;t
tracking any remote branch.</simpara>
<simpara>It&#8217;s important to note that these numbers reflect what existed the last time you fetched from each server.
<literal>git branch -vv</literal> doesn&#8217;t connect to the servers. It&#8217;s showing what it has cached from these servers locally.
If you want totally up to date ahead and behind numbers, fetch from all your remotes before running this.
Do that by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch --all; git branch -vv</programlisting>
</section>
<section xml:id="_pulling">
<title>Pulling</title>
<simpara><indexterm>
<primary>pulling</primary>
</indexterm></simpara>
<simpara>While <literal>git fetch</literal> fetches all the changes on the server that you don&#8217;t have yet, it doesn&#8217;t modify your
working directory in any way.  It simply gets the data for you to merge yourself.
However, <literal>git pull</literal> is essentially <literal>git fetch</literal> immediately followed by <literal>git merge</literal>.
If you have a tracking branch set up as in the last section, either by explicitly setting it or by
creating it using <literal>git clone</literal> or <literal>git checkout</literal>, <literal>git pull</literal> looks up the server and branch your current
branch is tracking, fetches from that server, and then tries to merge that remote branch into your current branch.</simpara>
<simpara>Generally it&#8217;s better to simply run <literal>git fetch</literal> and <literal>git merge</literal> explicitly as the magic of <literal>git pull</literal> can be confusing.</simpara>
</section>
<section xml:id="_delete_branches">
<title>Deleting Remote Branches</title>
<simpara><indexterm>
<primary>branches</primary><secondary>deleting remote</secondary>
</indexterm>
<indexterm>
<primary>deleting remote</primary>
</indexterm>
Suppose you&#8217;re done with a remote branch&#8201;&#8212;&#8201;say you and your collaborators are finished with a feature
and have merged it into your remote&#8217;s <literal>master</literal> branch. Delete a remote branch using the <literal>--delete</literal> flag
to <literal>git push</literal>. To delete <literal>serverfix</literal> from the server, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix</programlisting>
<simpara>All this does is remove the remote branch from the server. The Git server generally keeps the data for
a while until garbage collection runs, so if the branch was accidentally deleted, it&#8217;s easy to recover.</simpara>
</section>
</section>
<section xml:id="_rebasing">
<title>Rebasing</title>
<simpara><indexterm>
<primary>rebasing</primary>
</indexterm>
In Git, there are two main ways to incorporate changes from one branch into another: merging and rebasing.
In this section you learn what rebasing is, how to do it, why it&#8217;s an amazing tool, and when to not do it.</simpara>
<section xml:id="_the_basic_rebase">
<title>The Basic Rebase</title>
<simpara>If you go back to an earlier example from <xref linkend="_basic_merging"/>, you see that your work diverged and you made
commits on two different branches.</simpara>
<figure>
<title>Simple divergent history</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-rebase-1.png"/>
</imageobject>
<textobject><phrase>Simple divergent history.</phrase></textobject>
</mediaobject>
</figure>
<simpara>The easiest way to combine the branches, as we&#8217;ve already seen, is by running <literal>git merge</literal>.
It performs a three-way merge of the two latest branch snapshots (<literal>C3</literal> and <literal>C4</literal>) and the most
recent common ancestor of the two (<literal>C2</literal>), creating a new commit (<literal>C5</literal>).</simpara>
<figure>
<title>Merging to integrate diverged work history</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-rebase-2.png"/>
</imageobject>
<textobject><phrase>Merging to integrate diverged work history.</phrase></textobject>
</mediaobject>
</figure>
<simpara>However, there&#8217;s another way. You can take the changes introduced in <literal>C4</literal> and reapply them on top of <literal>C3</literal>.
Git calls this <emphasis>rebasing</emphasis>.
With <literal>git rebase</literal>, all the changes that were committed on one branch are replayed on another
branch.<indexterm>
<primary>git commands</primary><secondary>rebase</secondary>
</indexterm>
<indexterm>
<primary>rebase</primary>
</indexterm></simpara>
<simpara>In this example, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command</programlisting>
<simpara>This works by going to the common ancestor (<literal>C2</literal>) of the two branches (your current
branch (<literal>experiment</literal>) and the one you&#8217;re rebasing onto (<literal>master</literal>)),
getting the changes introduced by each commit (<literal>C4</literal>) of the branch you&#8217;re on,
saving those changes to temporary files, resetting the current branch to the branch you&#8217;re
rebasing onto (<literal>master</literal>), and finally applying each change in turn, resulting in <literal>C4'</literal>.</simpara>
<figure>
<title>Rebasing the change introduced in <literal>C4</literal> onto <literal>C3</literal></title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-rebase-3.png"/>
</imageobject>
<textobject><phrase>Rebasing the change introduced in `C4` onto `C3`.</phrase></textobject>
</mediaobject>
</figure>
<simpara>At this point, go back to <literal>master</literal> and do a fast-forward merge.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout master
$ git merge experiment</programlisting>
<figure>
<title>Fast-forwarding the master branch</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/basic-rebase-4.png"/>
</imageobject>
<textobject><phrase>Fast-forwarding the master branch.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now the snapshot in <literal>C4'</literal> is exactly the same as the one in <literal>C5</literal> in the merge example.
There&#8217;s no difference in the end result, but rebasing makes a cleaner history.
If you run <literal>git log</literal> on a rebased branch, it looks like all the commits happened in series,
even when they originally happened in parallel.</simpara>
<simpara>You often do this to make sure your commits apply cleanly on a remote branch&#8201;&#8212;&#8201;perhaps in a project
to which you contribute but you don&#8217;t maintain. In this case, you do your work in a branch and then
rebase your work onto <literal>origin/master</literal> when you&#8217;re ready to submit your patches to the main project.
That way, the maintainer doesn&#8217;t have to do any integration work&#8201;&#8212;&#8201;just a fast-forward merge.</simpara>
<simpara>Note that the snapshot in the final commit you end up with, whether it&#8217;s the last of the commits
for a rebase or the final merge commit after a merge, is the same&#8201;&#8212;&#8201;it&#8217;s only the history that&#8217;s different.
Rebasing replays changes from one branch onto another in the order they were introduced,
whereas merging takes the endpoints and merges them together.</simpara>
</section>
<section xml:id="_more_interesting_rebases">
<title>More Interesting Rebases</title>
<simpara>You can also have your rebase replay onto something other than the rebase target branch.
Take a history like <xref linkend="rbdiag_e"/>, for example.
You created a topic branch (<literal>server</literal>) to add some server-side features to your project,
and made a commit (<literal>C3</literal>). Then, you created a branch (<literal>client</literal>) to make some client-side
changes and committed a few times (<literal>C8</literal> and <literal>C9</literal>).
Finally, you went back to <literal>server</literal> and made a few more commits (<literal>C4</literal> and <literal>C10</literal>).</simpara>
<figure xml:id="rbdiag_e">
<title>A history with a topic branch off another topic branch</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/interesting-rebase-1.png"/>
</imageobject>
<textobject><phrase>A history with a topic branch off another topic branch.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Suppose you decide to merge your client-side changes into your mainline, but you want to hold off on the
server-side changes until they&#8217;ve been tested further.
You can take the changes on <literal>client</literal> that aren&#8217;t on <literal>server</literal> (<literal>C8</literal> and <literal>C9</literal>) and replay them
onto <literal>master</literal> by using the <literal>--onto</literal> flag of <literal>git rebase</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rebase --onto master server client</programlisting>
<simpara>This says check out <literal>client</literal>, figure out the patches from the common ancestor
of <literal>client</literal> and <literal>server</literal> (<literal>C3</literal>), and then replay them onto <literal>master</literal>.
It&#8217;s a bit complex, but the result is pretty cool.</simpara>
<figure>
<title>Rebasing a topic branch off another topic branch</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/interesting-rebase-2.png"/>
</imageobject>
<textobject><phrase>Rebasing a topic branch off another topic branch.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now fast-forward <literal>master</literal> (see <xref linkend="rbdiag_g"/>).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout master
$ git merge client</programlisting>
<figure xml:id="rbdiag_g">
<title>Fast-forwarding <literal>master</literal> to include the <literal>client</literal> changes</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/interesting-rebase-3.png"/>
</imageobject>
<textobject><phrase>Fast-forwarding `master` to include the `client` changes.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Let&#8217;s say you decide to merge in <literal>server</literal> as well.
Rebase <literal>server</literal> onto <literal>master</literal> without checking out <literal>server</literal> first by running
<literal>git rebase [basebranch] [topicbranch]</literal>&#8201;&#8212;&#8201;which checks out the topic branch (<literal>server</literal>)
and replays it onto the base branch (<literal>master</literal>).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rebase master server</programlisting>
<simpara>This replays <literal>server</literal> on top of <literal>master</literal>, as shown in <xref linkend="rbdiag_h"/>.</simpara>
<figure xml:id="rbdiag_h">
<title>Rebasing <literal>server</literal> on top of <literal>master</literal></title>
<mediaobject>
<imageobject>
<imagedata fileref="images/interesting-rebase-4.png"/>
</imageobject>
<textobject><phrase>Rebasing `server` on top of `master`.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Then, fast-forward the base branch (<literal>master</literal>).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout master
$ git merge server</programlisting>
<simpara>You can remove <literal>client</literal> and <literal>server</literal> because their content is integrated and you don&#8217;t need them anymore,
leaving your history for this entire process looking like <xref linkend="rbdiag_i"/>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch -d client
$ git branch -d server</programlisting>
<figure xml:id="rbdiag_i">
<title>Final commit history</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/interesting-rebase-5.png"/>
</imageobject>
<textobject><phrase>Final commit history.</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_rebase_peril">
<title>The Perils of Rebasing</title>
<simpara><indexterm>
<primary>rebasing</primary><secondary>perils of</secondary>
</indexterm>
<indexterm>
<primary>perils of</primary>
</indexterm>
Ahh, but the bliss of rebasing isn&#8217;t without drawbacks, which can be summed up in a single line:</simpara>
<simpara><emphasis role="strong">Do not rebase commits that exist outside your repository.</emphasis></simpara>
<simpara>If you follow that guideline, you&#8217;ll be fine.
If you don&#8217;t, people will hate you, and you&#8217;ll be scorned by friends and family.</simpara>
<simpara>When you rebase, you&#8217;re abandoning existing commits and creating new ones that are similar but different.
If you push commits somewhere and others pull them and base work on them, and then you rewrite those commits
with <literal>git rebase</literal> and push them again, your collaborators have to re-merge their work and things get messy
when you try to pull their work back into yours.</simpara>
<simpara>Let&#8217;s look at an example of how rebasing that you&#8217;ve made public can cause problems.
Suppose you clone from a server and then do some work on the cloned repository.
Your commit history looks like</simpara>
<figure>
<title>Clone a repository, and base some work on it</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/perils-of-rebasing-1.png"/>
</imageobject>
<textobject><phrase>Clone a repository, and base some work on it.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now, someone else does more work that includes a commit on master (<emphasis>C4</emphasis>), a branch (<literal>C5</literal>),
and a merge (<literal>C6</literal>), and then pushes that work to the server.
You fetch it and merge the new remote branch into your work as <literal>C7</literal>,
making your history look something like</simpara>
<figure>
<title>Fetch more commits, and merge them into your work</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/perils-of-rebasing-2.png"/>
</imageobject>
<textobject><phrase>Fetch more commits, and merge them into your work.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Next, the person who pushed the merged work (<literal>C6</literal>) decides to go back and rebase their work instead.
They run <literal>git push --force</literal> to overwrite the history on the server.
You then fetch from that server, bringing down the new commits.</simpara>
<figure xml:id="_pre_merge_rebase_work">
<title>Someone pushes rebased commits, abandoning commits you&#8217;ve based your work on</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/perils-of-rebasing-3.png"/>
</imageobject>
<textobject><phrase>Someone pushes rebased commits, abandoning commits you&#8217;ve based your work on.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now you&#8217;re both in a pickle.
If you run <literal>git pull</literal>, you create a merge commit which includes both lines of history, and your repository looks like</simpara>
<figure xml:id="_merge_rebase_work">
<title>You merge in the same work again into a new merge commit</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/perils-of-rebasing-4.png"/>
</imageobject>
<textobject><phrase>You merge in the same work again into a new merge commit.</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you run <literal>git log</literal> when your history looks like this, you see two commits (<literal>C4'</literal> and <literal>C8</literal>) that have the same author,
date, and message, which is confusing. Furthermore, if you push this history back to the server, you reintroduce
all those rebased commits, which can further confuse people. It&#8217;s pretty safe to assume that the
other developer doesn&#8217;t want <literal>C4</literal> and <literal>C6</literal> to be in the history. That&#8217;s why they rebased in the first place.</simpara>
</section>
<section xml:id="_rebase_rebase">
<title>Rebase When You Rebase</title>
<simpara>If you <emphasis role="strong">do</emphasis> find yourself in a situation like this, Git has some magic powers that might help you.
If someone on your team force pushes changes that overwrite work that you&#8217;ve based work on,
the challenge is to figure out what&#8217;s yours and what they&#8217;ve rewritten.</simpara>
<simpara>It turns out that in addition to the commit SHA-1 hash, Git also calculates a checksum that&#8217;s based on just
the patch introduced with the commit. This is called a <literal>patch-id</literal>.</simpara>
<simpara>If you pull work that was rewritten and rebase it on top of the new commits from your partner,
Git can often successfully figure out what&#8217;s uniquely yours and apply the changes back on top of the new branch.</simpara>
<simpara>For instance, in the previous scenario, if instead of doing a merge when we&#8217;re at <xref linkend="_pre_merge_rebase_work"/> we
run <literal>git rebase teamone/master</literal>, Git</simpara>
<itemizedlist>
<listitem>
<simpara>Determines which are unique to your branch (<literal>C2</literal>, <literal>C3</literal>, <literal>C4</literal>, <literal>C6</literal>, <literal>C7</literal>)</simpara>
</listitem>
<listitem>
<simpara>Determines which aren&#8217;t merge commits (<literal>C2</literal>, <literal>C3</literal>, <literal>C4</literal>)</simpara>
</listitem>
<listitem>
<simpara>Determines which haven&#8217;t been rewritten into the target branch (just <literal>C2</literal> and <literal>C3</literal>, since <literal>C4</literal> is the same patch as <literal>C4'</literal>)</simpara>
</listitem>
<listitem>
<simpara>Applies those commits to the top of <literal>teamone/master</literal></simpara>
</listitem>
</itemizedlist>
<simpara>So instead of the result we see in <xref linkend="_merge_rebase_work"/>, you&#8217;d end up with something more like <xref linkend="_rebase_rebase_work"/>.</simpara>
<figure xml:id="_rebase_rebase_work">
<title>Rebase on top of force-pushed rebase work.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/perils-of-rebasing-5.png"/>
</imageobject>
<textobject><phrase>Rebase on top of force-pushed rebase work.</phrase></textobject>
</mediaobject>
</figure>
<simpara>This only works if the <literal>C4</literal> and <literal>C4'</literal> commits your partner made are almost exactly the same patch.
Otherwise <literal>git rebase</literal> isn&#8217;t able to tell that they&#8217;re duplicates and adds another C4-like patch (which
probably fails to apply cleanly, since the changes would already be at least somewhat there).</simpara>
<simpara>You can also simplify this by running <literal>git pull --rebase</literal> instead of a normal <literal>git pull</literal>. Or, you could do
it manually by running <literal>git fetch</literal> followed by <literal>git rebase teamone/master</literal> in this case.</simpara>
<simpara>If you&#8217;re running <literal>git pull</literal> and want to make <literal>--rebase</literal> the default, set the <literal>pull.rebase</literal> config value by
running <literal>git config --global pull.rebase true</literal>.</simpara>
<simpara>If you treat rebasing as a way to clean up commits before you push them, and if you
only rebase commits that have never been pushed to a remote server, then you&#8217;re fine.
If you rebase commits that have already been pushed publicly, and people may have based work
on those commits, then you may be in trouble.</simpara>
<simpara>If you have to go against this advice, make sure everyone knows to run <literal>git pull --rebase</literal> to
try to reduce the pain.</simpara>
</section>
<section xml:id="_rebase_vs_merge">
<title>Rebase vs. Merge</title>
<simpara><indexterm>
<primary>rebasing</primary><secondary>vs. merging</secondary>
</indexterm>
<indexterm>
<primary>vs. merging</primary>
</indexterm><indexterm>
<primary>merging</primary><secondary>vs. rebasing</secondary>
</indexterm>
<indexterm>
<primary>vs. rebasing</primary>
</indexterm>
Now that you&#8217;ve seen rebasing and merging in action, you may be wondering which is better.
Before answering this, let&#8217;s step back a bit and talk about what history means.</simpara>
<simpara>One point of view is that your repository&#8217;s commit history is a <emphasis role="strong">record of what actually happened.</emphasis>
It&#8217;s an historical document, valuable in its own right, and shouldn&#8217;t be tampered with.
If you accept this, changing the commit history is almost blasphemous.
You&#8217;re <emphasis>lying</emphasis> about what actually transpired. So what if there was a messy series of merge commits?
That&#8217;s how it happened, and the repository should preserve that for posterity.</simpara>
<simpara>The opposing point of view is that the commit history is the <emphasis role="strong">story of how your project was made.</emphasis>
You wouldn&#8217;t publish the first draft of a book since it deserves careful editing before being published.
This is the camp that uses tools like rebase to tell the story in the way that&#8217;s best for future readers.</simpara>
<simpara>Now, to the question of whether merging or rebasing is better. Hopefully you see that it&#8217;s not that simple.
Git is a powerful tool, and allows you to do many things to your history, but every team and every project is different.
Now that you know how both of these things work, it&#8217;s up to you to decide which is best in your particular situation.</simpara>
</section>
</section>
<section xml:id="_summary_3">
<title>Summary</title>
<simpara>We&#8217;ve covered basic branching and merging in Git.
You should feel comfortable creating and switching to new branches, switching between branches, and merging
local branches together.
You should also be able to share your branches by pushing them to a shared server, working with others
on shared branches, and rebasing your branches before they are shared.
Next, we cover what you need to run your own Git repository-hosting server.</simpara>
</section>
</chapter>
<chapter xml:id="ch04-git-on-the-server">
<title>Git on the Server</title>
<simpara><indexterm>
<primary>serving repositories</primary>
</indexterm>
At this point, you should be able to use Git for most daily tasks.
However, using Git for collaboration requires a remote Git repository located
on a central server that all collaborators agree to use.
Although you can technically push changes to and pull changes from collaborator&#8217;s repositories,
assuming you&#8217;re granted access, this can easily confuse the owner of the repository.
Therefore, the preferred method for collaborating is to set up a central repository that all collaborators
have access to, and push to and pull from that.
Furthermore, since your collaborators must be able to access the central repository at all times,
it&#8217;s worth the effort to put energy into creating a more reliable server to use to house the central repository.</simpara>
<simpara>Remember that the decision to treat one repository as the central repository is merely
a convention. There are no technical differences between the central repository and those
on collaborators' workstations.</simpara>
<simpara>Running Git on a server is fairly straightforward.
First, choose which access protocols you want your server to support.
The first section of this chapter covers the available protocols and their pros and cons.
The next sections explain typical setups for using those protocols.
Last, we go over a few hosted options, if you don&#8217;t mind hosting your code on someone else&#8217;s server and don&#8217;t
want to go through the hassle of setting up and maintaining your own server.</simpara>
<simpara>If you have no interest in running your own server, skip to the last section of the chapter for options for
setting up a hosted account and then move on to the next chapter, where we discuss the various ins and outs of
working in a distributed version control environment.</simpara>
<simpara>A remote repository is generally a <emphasis>bare repository</emphasis>&#8201;&#8212;&#8201;a Git repository without a working directory.
Because the repository is only used for collaborating, there&#8217;s no reason to have a
working directory on the remote server&#8217;s disk.
In the simplest terms, a bare repository is the content of a project&#8217;s <literal>.git</literal> directory and nothing else.</simpara>
<section xml:id="_the_protocols">
<title>The Protocols</title>
<simpara>Git supports four protocols for transferring data: Local, HTTP, Secure Shell (SSH), and Git.
Here we discuss what they are and when you&#8217;d want (or not want) to use them.</simpara>
<section xml:id="_local_protocol">
<title>Local Protocol</title>
<simpara><indexterm>
<primary>protocols</primary><secondary>local</secondary>
</indexterm>
<indexterm>
<primary>local</primary>
</indexterm>
The most basic is the <emphasis>Local</emphasis> protocol, in which the repository you want to access is
on a local disk or on a remote filesystem that&#8217;s mounted on a local directory.
The local disk approach isn&#8217;t a very good idea because all your repositories would reside on the same computer,
making a catastrophic loss much more likely and painful.</simpara>
<simpara>If you have a repository on a remote filesystem mounted locally, then you can clone, push to, and pull from it the
same way you would if it were physically on a local disk. To clone a local repository or to add one as a remote to an
existing project, use the path to the repository as the URL. For example, to clone a local repository, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone /srv/git/project.git</programlisting>
<simpara>Or</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone file:///srv/git/project.git</programlisting>
<simpara>Git does something different if you specify <literal>file://</literal> at the beginning of the repository path.
If you just specify the path, Git tries to use hardlinks or directly copy the files it needs.
If you specify <literal>file://</literal>, Git uses the same technique that it normally uses to transfer data over a network,
which is generally a lot less efficient. The main reason to specify <literal>file://</literal> is when you want a
clean copy of the repository with extraneous references or objects left out&#8201;&#8212;&#8201;generally after an import from
another VCS or something similar (see <xref linkend="_git_internals"/> for maintenance tasks). We use simple paths because
this is almost always faster.</simpara>
<simpara>To add a local repository as a remote to an existing Git project, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add local_proj /srv/git/project.git</programlisting>
<simpara>Then, push to and pull from that remote as though it were on the network.</simpara>
<section xml:id="_the_pros">
<title>The Pros</title>
<simpara>The pros of local repositories are that they&#8217;re simple and use existing file permissions.
If you already have a shared filesystem your whole team can access, setting up a local repository is very easy.
Stick the bare repository somewhere everyone can access and set the read/write permissions as you would for any
other shared directory. We discuss how to export a bare repository for this purpose in
<xref linkend="_getting_git_on_a_server"/>.</simpara>
<simpara>Local repositories are also a nice way for quickly grabbing work from someone else&#8217;s repository.
If you and a co-worker are working on the same project and they want you to check something out,
running a command like <literal>git pull /home/john/project</literal> is often easier than the co-worker pushing
to a remote server and asking you to pull from there.</simpara>
</section>
<section xml:id="_the_cons">
<title>The Cons</title>
<simpara>The largest con of this method is that shared access is generally more difficult to set up and reach from multiple
locations than the other Git network access protocols. To access a remote filesystem on your laptop from home,
you have to mount the remote disk, which can be difficult and slow compared to other network-based Git access protocols.</simpara>
<simpara>A local repository is fast only if you have fast access to the repository.
Accessing a repository mounted via NFS is often slower than accessing the same repository over SSH.</simpara>
<simpara>Finally, this protocol doesn&#8217;t protect the repository against accidental damage. Every user has full access
to the repository directory, with nothing preventing them from changing or removing critical files
and corrupting the repository.</simpara>
</section>
</section>
<section xml:id="_the_http_protocols">
<title>The HTTP Protocols</title>
<simpara>Git can communicate over HTTP in two ways.
Prior to Git 1.6.6 the only way was a very simple and generally read-only method.
In version 1.6.6 a new smarter HTTP-based protocol was introduced that allows Git to intelligently negotiate data transfer
in a manner similar to what it does over SSH. In the last few years, this new protocol has become very
popular since it&#8217;s simpler for the user and smarter about how it communicates. The newer way is often referred to as
Smart HTTP and the old way as Dumb HTTP. We cover the newer Smart HTTP protocol first.</simpara>
<section xml:id="_smart_http">
<title>Smart HTTP</title>
<simpara><indexterm>
<primary>protocols</primary><secondary>smart HTTP</secondary>
</indexterm>
<indexterm>
<primary>smart HTTP</primary>
</indexterm>
The Smart HTTP protocol is very similar to the SSH or Git protocols but runs over standard HTTP/S and can
use HTTP authentication. It&#8217;s often easier to use than something like SSH, since you can use things like
username/password basic authentication rather than having to set up SSH keys.</simpara>
<simpara>It&#8217;s probably become the most popular Git access protocol, since it can be set up to both serve Git repositories
anonymously (like the <literal>git://</literal> protocol), and can also be used for pushing, with appropriate authentication and
encryption, like the SSH protocol. Instead of having to use different URLs for pushing and pulling, you now use
the same URL for both. If you try to push and the repository requires authentication (which it normally should),
the server can prompt for a username and password. The same goes for read access.</simpara>
<simpara>In fact, for services like GitHub, the URL you use to view the repository (for example,
<literal>https://github.com/schacon/simplegit[]</literal>) is the same URL you use to clone from and, if you have access, to push to.</simpara>
</section>
<section xml:id="_dumb_http">
<title>Dumb HTTP</title>
<simpara><indexterm>
<primary>protocols</primary><secondary>dumb HTTP</secondary>
</indexterm>
<indexterm>
<primary>dumb HTTP</primary>
</indexterm>
If the server doesn&#8217;t respond showing it supports Smart HTTP, the Git client falls back to the simpler Dumb HTTP protocol.
The Dumb protocol serves the files in the Git repository like any other files on the server.
The beauty of the Dumb HTTP protocol is that it&#8217;s so simple to set up.
Basically, all you have to do is put a bare Git repository under your web server&#8217;s document root,
set up a specific <literal>post-update</literal> hook, and you&#8217;re done (See <xref linkend="_git_hooks"/>).
At that point, anyone who can access the web server can also clone your repository.</simpara>
<simpara>To configure read access to your repository over Dumb HTTP, assuming a standard Apache server, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update</programlisting>
<simpara>That&#8217;s it.<indexterm>
<primary>hooks</primary><secondary>post-update</secondary>
</indexterm>
<indexterm>
<primary>post-update</primary>
</indexterm>
The <literal>post-update</literal> hook that comes with Git by default runs the appropriate command (<literal>e.g. git update-server-info</literal>)
to make fetching and cloning over HTTP work properly. Then, anybody can clone the repository by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone https://example.com/gitproject.git</programlisting>
<simpara>In this case, we&#8217;re using the <literal>/var/www/htdocs</literal> path that&#8217;s the default document root for Apache,
but you can use any web server that can serve static files&#8201;&#8212;&#8201;just put the bare repository in its default
document root location.</simpara>
<simpara>Generally you&#8217;d either choose to run a read/write web server using the Smart HTTP protocol or simply have the
Git repository accessible read-only using the Dumb HTTP protocol. There&#8217;s no reason to run both protocols.</simpara>
</section>
<section xml:id="_the_pros_2">
<title>The Pros</title>
<simpara>Having a single web server for all types of access and having it prompt only
when authentication is needed makes things very simple. Being able to authenticate with a username and password
is also a big advantage compared to SSH, since users don&#8217;t have to generate SSH keys and upload their public key
to the server before accessing it. For less sophisticated users, or users in environments where SSH is less common,
this is a major advantage.  It&#8217;s also a very fast and efficient protocol, similar to SSH.</simpara>
<simpara>You can also serve your repositories read-only over HTTPS, which means the content of your repositories is encrypted
when it&#8217;s transferred over the network. You can go so far as to force clients to use specific signed SSL certificates.</simpara>
<simpara>Another nice thing is that HTTP and HTTP/S are such commonly used protocols that corporate firewalls often allow them.</simpara>
</section>
<section xml:id="_the_cons_2">
<title>The Cons</title>
<simpara>Git over HTTP/S can be a little more tricky to set up compared to SSH.
Other than that, there&#8217;s very little advantage that other protocols have over the Smart HTTP protocol for serving Git.</simpara>
<simpara>If you&#8217;re using HTTP for authenticated pushing, providing your credentials is sometimes more complicated than using
SSH keys. There are, however, several credential caching tools you can use, including Keychain on OSX and Credential
Manager on Windows, to make this less painful. Read <xref linkend="_credential_caching"/> to see how to set up secure
HTTP password caching.</simpara>
</section>
</section>
<section xml:id="_the_ssh_protocol">
<title>The SSH Protocol</title>
<simpara><indexterm>
<primary>protocols</primary><secondary>SSH</secondary>
</indexterm>
<indexterm>
<primary>SSH</primary>
</indexterm>
A common transport protocol for Git when self-hosting is SSH.
This is because, like HTTP(S), incoming SSH access is already allowed in most places&#8201;&#8212;&#8201;and if it isn&#8217;t,
it&#8217;s easy to add. SSH is also an authenticated network protocol.</simpara>
<simpara>To clone a Git repository over SSH, specify an ssh:// URL.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone ssh://[user@]server/project.git</programlisting>
<simpara>Or use the shorter scp-like syntax.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone [user@]server:project.git</programlisting>
<simpara>You can also leave out the username, in which case Git uses your current username.</simpara>
<section xml:id="_the_pros_3">
<title>The Pros</title>
<simpara>The pros of using SSH are many.
First, SSH is relatively easy to set up&#8201;&#8212;&#8201;SSH daemons are commonplace, many network admins
have experience with them, and many OS distributions are set up with them or have tools to manage them.
Next, access over SSH is secure&#8201;&#8212;&#8201;all data transfer is encrypted and authenticated.
Last, like the HTTPS, Git, and Local protocols, SSH is efficient, making the data as compact
as possible before transferring it.</simpara>
</section>
<section xml:id="_the_cons_3">
<title>The Cons</title>
<simpara>The only negative of SSH is that it can&#8217;t provide anonymous access to your repository.
People must be able to login to your machine over SSH to access a repository, even in read-only mode,
which doesn&#8217;t make SSH access conducive to open source projects. If you&#8217;re using it only within your corporate network,
SSH may be the only protocol you need to deal with. To allow anonymous read-only access to your projects and also use
SSH, you have to set up SSH for pushing but something else for pulling.</simpara>
</section>
</section>
<section xml:id="_the_git_protocol">
<title>The Git Protocol</title>
<simpara><indexterm>
<primary>protocols</primary><secondary>git</secondary>
</indexterm>
<indexterm>
<primary>git</primary>
</indexterm>
Next is the Git protocol.
This is implemented in a special daemon that comes with Git. The daemon listens on a dedicated port (9418)
that provides a service similar to SSH, but with absolutely no authentication. For a repository to be served using the
Git protocol, you must create the <literal>git-daemon-export-ok</literal> file&#8201;&#8212;&#8201;the daemon doesn&#8217;t serve a repository without it.
Either a Git repository is available for everyone to clone or it&#8217;s unavailable for everyone.
This means that there&#8217;s generally no pushing using this protocol. You can enable push access, but given its lack
of authentication, anyone on the internet who finds your project&#8217;s URL could push to your project.
This is rare.</simpara>
<section xml:id="_the_pros_4">
<title>The Pros</title>
<simpara>The Git protocol is often the fastest network transfer protocol available for sharing Git repositories.
If you’re serving a lot of traffic for a public project or serving a very large project that doesn&#8217;t require
user authentication for read access, it’s likely that you want to set up a Git daemon.
It uses the same data-transfer mechanism as the SSH protocol but without the encryption and authentication overhead.</simpara>
</section>
<section xml:id="_the_cons_4">
<title>The Cons</title>
<simpara>The downside of the Git protocol is the lack of authentication.
It&#8217;s generally undesirable for the Git protocol to be the only way to access your project.
Generally, you pair it with SSH or HTTP(S) access for the few developers who need push access, and have everyone
else use <literal>git://</literal> for read-only access. It&#8217;s also probably the most difficult protocol to set up.
It must run its own daemon, which requires <literal>xinetd</literal> configuration or the like, which isn&#8217;t always a walk in the park.
It also requires firewalls to allow access to port 9418, which isn&#8217;t a standard port that corporate firewalls usually allow.</simpara>
</section>
</section>
</section>
<section xml:id="_getting_git_on_a_server">
<title>Getting Git on a Server</title>
<simpara>Now we cover setting up Git on a server.</simpara>
<note>
<simpara>Here we demonstrate the steps needed to do a basic installation on a Linux-based server.
It&#8217;s also possible to run a Git service on Mac or Windows servers.
Setting up an actual production Git service can differ in the security measures you must incorporate,
or in what operating system tools are available, but hopefully this gives a general idea of what&#8217;s involved.</simpara>
</note>
<simpara>In order to initially set up a Git server, place the content of an existing repository into a new bare
repository&#8201;&#8212;&#8201;a repository that doesn&#8217;t contain a working directory.
This is generally straightforward to do.
In order to clone your repository to create a new bare repository, run <literal>git clone --bare</literal>.<indexterm>
<primary>git commands</primary><secondary>clone</secondary><tertiary>bare</tertiary>
</indexterm>
<indexterm>
<primary>clone</primary><secondary>bare</secondary>
</indexterm>
<indexterm>
<primary>bare</primary>
</indexterm>
By convention, a bare repository directory name ends in <literal>.git</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone --bare my_project my_project.git
Cloning into bare repository 'my_project.git'...
done.</programlisting>
<simpara>You now have a copy of the my_project Git repository in <literal>my_project.git</literal>.</simpara>
<simpara>This is roughly equivalent to</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cp -Rf my_project/.git my_project.git</programlisting>
<simpara>There are a couple of minor differences between the two methods but for your purposes, they do the same thing.</simpara>
<section xml:id="_bare_repo">
<title>Putting the Bare Repository on a Server</title>
<simpara>Now that you have a bare repository, all you need to do is put it on a server and set up the access protocols.
Let&#8217;s say you&#8217;ve set up a server called <literal>git.example.com</literal> that you have SSH access to,
and you want to store all your Git repositories under <literal>/opt/git</literal>.
Assuming that <literal>/opt/git</literal> exists on that server, set up your new repository by copying your bare repository to the server.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ scp -r my_project.git user@git.example.com:/srv/git</programlisting>
<simpara>At this point, users who have SSH access to the server, and who have read-access to the <literal>/opt/git</literal> directory,
can clone your repository by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone user@git.example.com:/srv/git/my_project.git</programlisting>
<simpara>If a user can SSH into a server and has write access to the <literal>/opt/git/my_project.git</literal> directory,
they also automatically have push access.</simpara>
<simpara>Git automatically adds group write permissions to a repository if you run
<literal>git init --bare --shared</literal>.<indexterm>
<primary>git commands</primary><secondary>init</secondary><tertiary>bare</tertiary>
</indexterm>
<indexterm>
<primary>init</primary><secondary>bare</secondary>
</indexterm>
<indexterm>
<primary>bare</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ ssh user@git.example.com
$ cd /srv/git/my_project.git
$ git init --bare --shared</programlisting>
<simpara>Now you&#8217;re ready to collaborate.</simpara>
<simpara>It&#8217;s important to note that this is literally all you need to do to run a usable Git server to which several
people have access&#8201;&#8212;&#8201;just add SSH-able accounts on a server, and stick a bare repository somewhere that all
those users have read and write access to. You&#8217;re ready to go&#8201;&#8212;&#8201;nothing else is needed.</simpara>
<simpara>The next few sections cover how to configure more sophisticated setups.
This discussion includes how to avoid creating individual user accounts, how to add public read access to repositories,
set up web UIs, and more. However, keep in mind collaborating with a couple of people on a private project only
requires an SSH server and a bare repository.</simpara>
</section>
<section xml:id="_small_setups">
<title>Small Setups</title>
<simpara>If you&#8217;re a small outfit just trying out Git with only a few developers, things can be simple.
One of the most complicated aspects of setting up a Git server is user management.
Making some repositories read-only for certain users and read/write for others can be a bit more difficult to arrange.</simpara>
<section xml:id="_ssh_access">
<title>SSH Access</title>
<simpara>If you already have a server all your developers can SSH into, it&#8217;s generally easiest to set up your first
repository there, because you have to do almost no work (as we covered in the last section).
For more complex access controls to your repositories, use normal filesystem permissions provided by your
server&#8217;s operating system. <indexterm>
<primary>serving repositories</primary><secondary>SSH</secondary>
</indexterm>
<indexterm>
<primary>SSH</primary>
</indexterm></simpara>
<simpara>To place your repositories on a server that doesn&#8217;t have accounts for everyone who should have write access,
then you must set up SSH access for them. We assume that you have a server for this that already has an SSH
daemon running, and you&#8217;ve logged in to it using SSH.</simpara>
<simpara>There are several ways to give access to everyone on your team.
The first is to set up accounts for everybody, which is straightforward but can be cumbersome.
You may not want to run <literal>adduser</literal> and set temporary passwords for every user.</simpara>
<simpara>A second method is to create a single <literal>git</literal> user on the server, ask every user who needs write access to send
you their SSH public key, and add that key to the <literal>git</literal> user&#8217;s <literal>~/.ssh/authorized_keys</literal> file.
At that point, everyone is able to access that machine as the <literal>git</literal> user.
This doesn&#8217;t affect commits in any way&#8201;&#8212;&#8201;the SSH user you connect as doesn&#8217;t affect the commits you&#8217;ve recorded.</simpara>
<simpara>Another way to do it is to have your SSH server authenticate from an LDAP server or some other centralized
authentication source that you may already have set up. As long as each user can login to the server,
any SSH authentication mechanism you can think of should work.</simpara>
</section>
</section>
</section>
<section xml:id="_generate_ssh_key">
<title>Generating Your SSH Public Key</title>
<simpara><indexterm>
<primary>SSH keys</primary>
</indexterm>
That being said, many Git server users authenticate using an SSH public key
which they must generate if they don&#8217;t already have one.
This process is similar across all operating systems.
First, check to make sure you don&#8217;t already have a public key.
By default, SSH keys are stored in a user&#8217;s <literal>~/.ssh</literal> directory.
You can easily check to see if you have a public key already by going to that directory and listing the files.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd ~/.ssh
$ ls
authorized_keys2  id_dsa       known_hosts
config            id_dsa.pub</programlisting>
<simpara>You&#8217;re looking for a pair of files named something like <literal>id_dsa</literal> or <literal>id_rsa</literal>, and a matching file with a <literal>.pub</literal> extension.
The <literal>.pub</literal> file is your public key, and the other file is your private key.
If you don&#8217;t have these files (or you don&#8217;t even have a <literal>.ssh</literal> directory), create them by running <literal>ssh-keygen</literal>,
which is provided with the SSH package on Linux and Mac systems, and comes with Git for Windows.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ ssh-keygen -o
Generating public/private rsa key pair.
Enter file in which to save the key (/home/schacon/.ssh/id_rsa):
Created directory '/home/schacon/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/schacon/.ssh/id_rsa.
Your public key has been saved in /home/schacon/.ssh/id_rsa.pub.
The key fingerprint is:
d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local</programlisting>
<simpara>It first confirms where to save the private key (<literal>/home/schacon/.ssh/id_rsa</literal>), and then it asks twice
for a passphrase, which you can leave empty if you don&#8217;t want to enter a passphrase when you use the key.
However, if you do use a passphrase, make sure to add the <literal>-o</literal> flag. This saves the private key in a format
that&#8217;s more resistant to brute-force cracking than the default format.
You can also use the <literal>ssh-agent</literal> tool to prevent having to enter the password each time.
Your public key is saved in the same directory as your private key.</simpara>
<simpara>Now, each user has to copy their public key and email it to whoever administers the Git server.
A public key looks something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
NrRFi9wrf+M7Q== schacon@mylaptop.local</programlisting>
<simpara>For a more in-depth tutorial on creating SSH keys on multiple operating systems, see the GitHub guide
at <link xl:href="https://help.github.com/articles/generating-ssh-keys">https://help.github.com/articles/generating-ssh-keys</link>.</simpara>
</section>
<section xml:id="_setting_up_server">
<title>Setting Up the Server</title>
<simpara>Let&#8217;s walk through setting up SSH access to the server.
This example uses the <literal>authorized_keys</literal> method for authenticating users.
We also assume you&#8217;re running a standard Linux distribution like Ubuntu.</simpara>
<simpara>First, login to the server, and create a <literal>git</literal> user and a <literal>.ssh</literal> directory for that user.</simpara>
<note>
<simpara>A good deal of what is described here can be automated by using the <literal>ssh-copy-id</literal> command,
rather than manually copying and installing public keys.</simpara>
</note>
<programlisting language="console" linenumbering="unnumbered">$ sudo adduser git
$ su git
$ cd
$ mkdir .ssh &amp;&amp; chmod 700 .ssh
$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys</programlisting>
<simpara>John, Josie, and Jessica are your developers. Next, add their SSH public keys
to the <literal>git</literal> user&#8217;s <literal>authorized_keys</literal> file.
Let&#8217;s assume you have their public keys stored in files in <literal>/tmp</literal>.</simpara>
<simpara>Again, public keys look something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat /tmp/id_rsa.john.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
dAv8JggJICUvax2T9va5 gsg-keypair</programlisting>
<simpara>Just append the public keys to the <literal>git</literal> user&#8217;s <literal>authorized_keys</literal> file in their <literal>.ssh</literal> directory.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.jessica.pub &gt;&gt; ~/.ssh/authorized_keys</programlisting>
<simpara>Now, set up an empty repository by running <literal>git init --bare</literal>, which initializes the repository
without a working directory.<indexterm>
<primary>git commands</primary><secondary>init</secondary><tertiary>bare</tertiary>
</indexterm>
<indexterm>
<primary>init</primary><secondary>bare</secondary>
</indexterm>
<indexterm>
<primary>bare</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd /srv/git
$ mkdir project.git
$ cd project.git
$ git init --bare
Initialized empty Git repository in /srv/git/project.git/</programlisting>
<simpara>Then, one of your developers (<literal>John</literal>) can push the first version of his project into the new repository
by adding it as a remote and pushing from his local Git repository.
For example, let&#8217;s use <literal>gitserver</literal> as the DNS hostname of the server on which you&#8217;ve set up your <literal>git</literal> user and repository.
Run the following commands pretty much as is (assuming <literal>myproject</literal> is an existing directory containing project files):</simpara>
<programlisting language="console" linenumbering="unnumbered"># on John's computer
$ cd myproject
$ git init
$ git add .
$ git commit -m 'initial commit'
$ git remote add origin git@gitserver:/srv/git/project.git
$ git push origin master</programlisting>
<simpara>At this point, the other developers can clone the new repository and push changes.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone git@gitserver:/srv/git/project.git
$ cd project
$ vim README
$ git commit -am 'fix for the README file'
$ git push origin master</programlisting>
<simpara>With this method, you can quickly get a read/write Git server up and running for the developers whose SSH keys you added.</simpara>
<simpara>You should also note that currently all these developers have shell access into the server as the <literal>git</literal> user.
To prevent that, change the <literal>git</literal> user&#8217;s shell entry in the <literal>passwd</literal> file
to a limited shell called <literal>git-shell</literal> that comes with Git.
To do this, first add <literal>git-shell</literal> to <literal>/etc/shells</literal> if it&#8217;s not already there.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat /etc/shells   # see if `git-shell` is already in there.  If not...
$ which git-shell   # make sure git-shell is installed on your system.
$ sudo vim /etc/shells  # and add the path to git-shell from last command</programlisting>
<simpara>Now change the <literal>git</literal> user&#8217;s default shell by running <literal>chsh git</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo chsh git -s $(which git-shell)</programlisting>
<simpara>Now, the <literal>git</literal> user can only use the SSH protocol to push and pull Git repositories and can&#8217;t login to the machine.
If they try, they see a login rejection like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ ssh git@gitserver
fatal: Interactive git shell is not enabled.
hint: ~/git-shell-commands should exist and have read and execute access.
Connection to gitserver closed.</programlisting>
<simpara>Git network commands still work just fine but users aren&#8217;t able to login.
As the output states, you can also set up a directory in the <literal>git</literal> user&#8217;s home directory that customizes
the <literal>git-shell</literal> command.</simpara>
</section>
<section xml:id="_git_daemon">
<title>Git Daemon</title>
<simpara><indexterm>
<primary>serving repositories</primary><secondary>git protocol</secondary>
</indexterm>
<indexterm>
<primary>git protocol</primary>
</indexterm></simpara>
<simpara>Next we set up a daemon serving repositories using the <literal>Git</literal> protocol. This is a common choice for fast,
unauthenticated access to Git repositories. If you&#8217;re running this on a server outside your firewall,
it should only be used for projects that are intended to be publicly visible to the world.
If the server you&#8217;re running it on is inside your firewall, you might use it for projects that a large number of
people or computers (continuous integration or build servers) have read-only access to, when you don&#8217;t want to
add individual SSH keys.</simpara>
<simpara>In any case, the Git protocol is relatively easy to set up. Basically, run<indexterm>
<primary>git commands</primary><secondary>daemon</secondary>
</indexterm>
<indexterm>
<primary>daemon</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git daemon --reuseaddr --base-path=/srv/git/ /srv/git/</programlisting>
<simpara><literal>--reuseaddr</literal> allows the server to restart without waiting for old connections to time out,
<literal>--base-path</literal> allows cloning projects without specifying the entire path, and the path at the end tells the Git
daemon where to look for repositories to export.</simpara>
<simpara>If you&#8217;re running a firewall, you also need to open a hole for port 9418 to the box you&#8217;re setting this up on.</simpara>
<simpara>You can daemonize this process a number of ways, depending on the operating system you&#8217;re running.
Since <literal>systemd</literal> is the most common init system among modern Linux distributions, you can use it for that purpose.
Simply place a file in <literal>/etc/systemd/system/git-daemon.service</literal> containing</simpara>
<programlisting language="console" linenumbering="unnumbered">[Unit]
Description=Start Git Daemon

[Service]
ExecStart=/usr/bin/git daemon --reuseaddr --base-path=/srv/git/ /srv/git/

Restart=always
RestartSec=500ms

StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=git-daemon

User=git
Group=git

[Install]
WantedBy=multi-user.target</programlisting>
<simpara>You might have noticed that Git daemon is started here with <literal>git</literal> as both the user and group.
Modify it to fit your needs and make sure the provided user exists on the server.
Also, check that the Git binary is indeed located at <literal>/usr/bin/git</literal> and change the path if necessary.</simpara>
<simpara>Finally, run <literal>systemctl enable git-daemon</literal> to automatically start the service when the server is booted.
The service can be started or stopped, respectively, by running <literal>systemctl start git-daemon</literal> or <literal>systemctl stop git-daemon</literal>.</simpara>
<simpara>Ubuntu 14.04 LTS and earlier used the Upstart service configuration method.
So, on those systems, in the following file</simpara>
<programlisting language="console" linenumbering="unnumbered">/etc/init/local-git-daemon.conf</programlisting>
<simpara>put this script</simpara>
<programlisting language="console" linenumbering="unnumbered">start on startup
stop on shutdown
exec /usr/bin/git daemon \
    --user=git --group=git \
    --reuseaddr \
    --base-path=/srv/git/ \
    /srv/git/
respawn</programlisting>
<simpara>For security reasons, it&#8217;s strongly encouraged to have this daemon run as a user with read-only permissions
to the repositories being served, which you can easily do by creating the user <literal>git-ro</literal> and running the
daemon as this user. For the sake of simplicity, we simply run it as the same <literal>git</literal> user that <literal>git-shell</literal> is running as.</simpara>
<simpara>When you restart your server, the Git daemon starts automatically, and respawns if it goes down.
To start it without having to reboot, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ initctl start local-git-daemon</programlisting>
<simpara>On other systems, you may want to use <literal>xinetd</literal>, a script in your <literal>sysvinit</literal> system, or something else&#8201;&#8212;&#8201;anything
that can daemonize <literal>git</literal> somehow.</simpara>
<simpara>Next, tell Git which repositories to allow unauthenticated Git server-based access to.
Do this in each repository by creating a file named <literal>git-daemon-export-ok</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd /path/to/project.git
$ touch git-daemon-export-ok</programlisting>
<simpara>The presence of that file tells Git that it&#8217;s OK to serve this repository without authentication.</simpara>
</section>
<section xml:id="_smart_http_2">
<title>Smart HTTP</title>
<simpara><indexterm>
<primary>serving repositories</primary><secondary>HTTP</secondary>
</indexterm>
<indexterm>
<primary>HTTP</primary>
</indexterm></simpara>
<simpara>We now have authenticated access through SSH and unauthenticated access through <literal>git://</literal>,
but Smart HTTP can do both at the same time.
Setting it up is basically just enabling a CGI script that&#8217;s provided with Git on the server called <literal>git-http-backend</literal>.<indexterm>
<primary>git commands</primary><secondary>http-backend</secondary>
</indexterm>
<indexterm>
<primary>http-backend</primary>
</indexterm>
This script reads the path and HTTP headers sent by <literal>git fetch</literal> or <literal>git push</literal> to a web server and determines
which HTTP-based protocol the client can use.
If the script recognizes a smart client, it communicates smartly with it, otherwise it falls back to the dumb
behavior (so it&#8217;s backward compatible for reads with older clients).</simpara>
<simpara>Let&#8217;s walk through a very basic setup. We set this up with Apache running the CGI script.
If you don&#8217;t have Apache set up, you can do so on an Ubuntu Linux box by running something like<indexterm>
<primary>Apache</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo apt-get install apache2 apache2-utils
$ a2enmod cgi alias env</programlisting>
<simpara>This also enables the <literal>mod_cgi</literal>, <literal>mod_alias</literal>, and <literal>mod_env</literal> modules, which are all needed for Smart HTTP to work properly.</simpara>
<simpara>Also set the Unix user group of the <literal>/srv/git</literal> directory, and any subdirectories, to <literal>www-data</literal> so your web
server has read and write access the repositories.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ chgrp -R www-data /srv/git</programlisting>
<simpara>Next, modify the Apache configuration file so that Apache runs <literal>git-http-backend</literal> as the handler for anything
coming into the <literal>/git</literal> directory.</simpara>
<programlisting language="console" linenumbering="unnumbered">SetEnv GIT_PROJECT_ROOT /srv/git
SetEnv GIT_HTTP_EXPORT_ALL
ScriptAlias /git/ /usr/lib/git-core/git-http-backend/</programlisting>
<simpara>If you leave out the <literal>GIT_HTTP_EXPORT_ALL</literal> environment variable, then Apache only serves the repositories
with the <literal>git-daemon-export-ok</literal> file in them to unauthenticated clients, just like the Git daemon did.</simpara>
<simpara>Finally tell Apache to allow requests to <literal>git-http-backend</literal> and to require writes be authenticated with an Auth block like</simpara>
<programlisting language="console" linenumbering="unnumbered">&lt;Files "git-http-backend"&gt;
    AuthType Basic
    AuthName "Git Access"
    AuthUserFile /srv/git/.htpasswd
    Require expr !(%{QUERY_STRING} -strmatch '*service=git-receive-pack*' || %{REQUEST_URI} =~ m#/git-receive-pack$#)
    Require valid-user
&lt;/Files&gt;</programlisting>
<simpara>That requires you to create a <literal>.htpasswd</literal> file containing the passwords of all the valid users.
Here&#8217;s an example of adding a "schacon" user.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ htpasswd -c /srv/git/.htpasswd schacon</programlisting>
<simpara>There are tons of ways Apache can authenticate users. You have to choose one of them.
This is just the simplest example we could come up with. You also almost certainly want to set this up over SSL
so all the transferred data is encrypted.</simpara>
<simpara>We don&#8217;t want to go too far down the rabbit hole of Apache configuration, since you might be using a
different web server or have different authentication needs.
The idea is that Git comes with a CGI script called <literal>git-http-backend</literal> that, when invoked,
does all the negotiation to send and receive data over HTTP. It doesn&#8217;t implement any authentication itself,
but that can easily be controlled by the web server that invokes it.
You can do this with nearly any CGI-capable web server, so go with the one that you know best.</simpara>
<note>
<simpara>For more information on configuring authentication in Apache, check out the Apache docs: <link xl:href="http://httpd.apache.org/docs/current/howto/auth.html">http://httpd.apache.org/docs/current/howto/auth.html</link></simpara>
</note>
</section>
<section xml:id="_gitweb">
<title>GitWeb</title>
<simpara><indexterm>
<primary>serving repositories</primary><secondary>GitWeb</secondary>
</indexterm>
<indexterm>
<primary>GitWeb</primary>
</indexterm><indexterm>
<primary>GitWeb</primary>
</indexterm>
Now that you have basic read/write and read-only access to your repository, you may want to set up a simple
web-based interface.
Git comes with a CGI script called GitWeb for this.</simpara>
<figure xml:id="gitweb">
<title>The GitWeb web-based user interface.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/git-instaweb.png"/>
</imageobject>
<textobject><phrase>The GitWeb web-based user interface.</phrase></textobject>
</mediaobject>
</figure>
<simpara>To check out what GitWeb looks like, Git comes with a command that starts it temporarily if you have a
lightweight web server on your Git server, like <literal>lighttpd</literal> or <literal>webrick</literal>.
On Linux machines, <literal>lighttpd</literal> is often installed, so you may be able to start GitWeb by running <literal>git instaweb</literal>
in your project working directory.
Macs often come with Ruby preinstalled, so <literal>webrick</literal> may be your best bet.
To start <literal>instaweb</literal> with a non-lighttpd server, run <literal>git instaweb</literal> with the <literal>--httpd</literal> flag.<indexterm>
<primary>git commands</primary><secondary>instaweb</secondary>
</indexterm>
<indexterm>
<primary>instaweb</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git instaweb --httpd=webrick
[2009-02-21 10:02:21] INFO  WEBrick 1.3.1
[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]</programlisting>
<simpara>That starts a web server on port 1234 and then automatically starts a web browser that opens the page shown above.
It&#8217;s pretty easy.
When you&#8217;re done and want to shut down the server, run the same command with the <literal>--stop</literal> flag.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git instaweb --httpd=webrick --stop</programlisting>
<simpara>To run GitWeb all the time, set up the GitWeb CGI script to be run by your standard web server.
Some Linux distributions have a <literal>gitweb</literal> package that you may be able to install via <literal>apt</literal>, <literal>yum</literal>, or <literal>dnf</literal>,
so try that first. We walk through quickly installing GitWeb manually.</simpara>
<simpara>First, get the Git source code, which includes GitWeb, and generate the custom CGI script.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone git://git.kernel.org/pub/scm/git/git.git
$ cd git/
$ make GITWEB_PROJECTROOT="/srv/git" prefix=/usr gitweb
    SUBDIR gitweb
    SUBDIR ../
make[2]: `GIT-VERSION-FILE' is up to date.
    GEN gitweb.cgi
    GEN static/gitweb.js
$ sudo cp -Rf gitweb /var/www/</programlisting>
<simpara>Notice that you have to specify where to find your Git repositories with the <literal>GITWEB_PROJECTROOT</literal> variable.
Now, make Apache run CGI for that script by adding a VirtualHost.</simpara>
<programlisting language="console" linenumbering="unnumbered">&lt;VirtualHost *:80&gt;
    ServerName gitserver
    DocumentRoot /var/www/gitweb
    &lt;Directory /var/www/gitweb&gt;
        Options +ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
        AllowOverride All
        order allow,deny
        Allow from all
        AddHandler cgi-script cgi
        DirectoryIndex gitweb.cgi
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;</programlisting>
<simpara>Again, GitWeb can be served with any CGI or Perl capable web server. If you prefer to use something else,
it shouldn&#8217;t be difficult to set up.
At this point, you should be able to visit <literal>http://gitserver/</literal> to view your repositories.</simpara>
</section>
<section xml:id="_gitlab">
<title>GitLab</title>
<simpara><indexterm>
<primary>serving repositories</primary><secondary>GitLab</secondary>
</indexterm>
<indexterm>
<primary>GitLab</primary>
</indexterm><indexterm>
<primary>GitLab</primary>
</indexterm>
GitWeb is pretty simplistic though.
For a more modern, fully featured Git server, there are several open source solutions available.
GitLab is one of the more popular ones, so we cover installing and using it.
It&#8217;s a bit more complex than GitWeb and likely requires more maintenance, but it&#8217;s a much more fully featured option.</simpara>
<section xml:id="_installation">
<title>Installation</title>
<simpara>GitLab is a database-backed web application, so its installation is a bit more involved than most other Git servers.
Fortunately, this process is very well-documented.</simpara>
<simpara>There are several ways to install GitLab.
To get something up and running quickly, download a virtual machine image or a one-click installer
from <link xl:href="https://bitnami.com/stack/gitlab">https://bitnami.com/stack/gitlab</link>, and tweak the configuration to match your particular environment.<indexterm>
<primary>bitnami</primary>
</indexterm>
One nice touch Bitnami has included is the login page (accessed by typing alt+→) which shows the IP address,
the default username, and password for the installed GitLab.</simpara>
<figure xml:id="bitnami">
<title>The Bitnami GitLab virtual machine login screen.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/bitnami.png"/>
</imageobject>
<textobject><phrase>The Bitnami GitLab virtual machine login screen.</phrase></textobject>
</mediaobject>
</figure>
<simpara>For anything else, follow the guidance in the GitLab Community Edition readme
at <link xl:href="https://gitlab.com/gitlab-org/gitlab-ce/tree/master">https://gitlab.com/gitlab-org/gitlab-ce/tree/master</link>.
There you find assistance for installing GitLab using Chef recipes, a virtual machine on Digital Ocean,
and RPM and DEB packages.
There&#8217;s also guidance on getting GitLab running with non-standard operating systems and databases,
a fully-manual installation script, and many other topics.</simpara>
</section>
<section xml:id="_administration">
<title>Administration</title>
<simpara>GitLab administration is done over the web.
Simply point your browser to the hostname or IP address where GitLab is installed, and log in as an admin user.
The default username is <literal>admin@local.host</literal>, and the default password is <literal>5iveL!fe</literal> (which
you&#8217;re prompted to change as soon as you enter it).
Once logged in, click the <literal>Admin area</literal> icon in the menu at the top right.</simpara>
<figure xml:id="gitlab_menu">
<title>The <literal>Admin area</literal> item in the GitLab menu.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/gitlab-menu.png"/>
</imageobject>
<textobject><phrase>The `Admin area` item in the GitLab menu.</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_users">
<title>Users</title>
<simpara>A user in GitLab is an account for a single person.
User accounts don&#8217;t have a lot of complexity. They&#8217;re mainly a collection of personal information.
Each user account comes with a <emphasis role="strong">namespace</emphasis>, which is a grouping of projects that belong to that user.
If the user <literal>jane</literal> had a project named <literal>project</literal>, that project&#8217;s URL would be <link xl:href="http://server/jane/project">http://server/jane/project</link>.</simpara>
<figure xml:id="gitlab_users">
<title>The GitLab user administration screen.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/gitlab-users.png"/>
</imageobject>
<textobject><phrase>The GitLab user administration screen.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Removing a user can be done in two ways.
<literal>Blocking</literal> a user prevents them from logging into GitLab, but all of the data in that user&#8217;s namespace
is preserved, and commits signed with that user&#8217;s email address still link back to their account.</simpara>
<simpara><literal>Destroying</literal> a user, on the other hand, completely removes them from the database and filesystem.
All projects and data in their namespace are removed, and any groups they own are also removed.
This is obviously a much more permanent and destructive action, and it&#8217;s rarely used.</simpara>
</section>
<section xml:id="_gitlab_groups_section">
<title>Groups</title>
<simpara>A GitLab group is a collection of projects, along with data about which users can access those projects, and how.
Each group has a project namespace (the same way that users do), so if the group <literal>training</literal> has a project <literal>materials</literal>,
its URL would be <link xl:href="http://server/training/materials">http://server/training/materials</link>.</simpara>
<figure xml:id="gitlab_groups">
<title>The GitLab group administration screen.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/gitlab-groups.png"/>
</imageobject>
<textobject><phrase>The GitLab group administration screen.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Each group is associated with a number of users, and each user has a level of permissions for the group&#8217;s projects
and the group itself. These permissions range from <literal>Guest</literal> (issues and chat only) to <literal>Owner</literal> (full control of the group,
its members, and its projects). The types of permissions are too numerous to list here,
but GitLab has a helpful link on the administration page.</simpara>
</section>
<section xml:id="_projects">
<title>Projects</title>
<simpara>A GitLab project roughly corresponds to a single Git repository.
Every project belongs to a single namespace, either a user or a group namespace.
If the project belongs to a user, the user who owns the project has direct control over who has access to the project.
If the project belongs to a group, the group&#8217;s user-level permissions also take effect.</simpara>
<simpara>Every project also has a visibility level, which controls who has read access to that project&#8217;s pages and repository.
If a project is <emphasis>Private</emphasis>, the project&#8217;s owner must explicitly grant access to specific users.
An <emphasis>Internal</emphasis> project is visible to any logged-in user, and a <emphasis>Public</emphasis> project is visible to anyone.
Note that this controls both <literal>git fetch</literal> access as well as access to the web UI for that project.</simpara>
</section>
<section xml:id="_hooks">
<title>Hooks</title>
<simpara>GitLab includes support for hooks, both at a project or system level.
In either case, the GitLab server performs an HTTP POST request, with some descriptive JSON, whenever relevant events occur.
This is a great way to connect your Git repositories and GitLab instance to the rest of your development automation tools,
such as CI servers, chat rooms, and deployment tools.</simpara>
</section>
</section>
<section xml:id="_basic_usage">
<title>Basic Usage</title>
<simpara>The first thing to do with GitLab is to create a new project
by clicking the <literal>+</literal> icon on the toolbar.
You&#8217;re asked for the project&#8217;s name, which namespace it should belong to, and what its visibility level should be.
Most of what you specify here isn&#8217;t permanent, and can be changed later using the settings interface.
Click <literal>Create Project</literal> and you&#8217;re done.</simpara>
<simpara>Once the project exists, connect it with a local Git repository.
Each project is accessible over HTTPS or SSH, either of which can be used to specify a Git remote.
The URLs are visible at the top of the project&#8217;s home page.
For an existing local repository, this command creates a remote named <literal>gitlab</literal> on the hosted location.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add gitlab https://server/namespace/project.git</programlisting>
<simpara>If you don&#8217;t have a local copy of the repository, simply run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone https://server/namespace/project.git</programlisting>
<simpara>The web UI provides access to several useful views of the repository itself.
Each project&#8217;s home page shows recent activity, and links along the top leads you to views of the project&#8217;s files
and commit log.</simpara>
</section>
<section xml:id="_working_together">
<title>Working Together</title>
<simpara>The simplest way of working together on a GitLab project is by giving another user push access to the Git repository.
Add a user to a project by going to the <literal>Members</literal> section of that project&#8217;s settings, and associating the new
user with an access level (the different access levels are discussed a bit in <xref linkend="_gitlab_groups_section"/>).
By giving a user an access level of <literal>Developer</literal> or above, that user can push commits and branches directly to the repository.</simpara>
<simpara>Another, more decoupled, way of collaboration is by using merge requests.
This feature enables any user that can see a project to contribute to it in a controlled way.
Users with direct access can simply create a branch, push commits to it, and open a merge request from their
branch back into <literal>master</literal> or any other branch on the GitLab server.
Users who don&#8217;t have push permission for a repository can <literal>fork</literal> it (create their own copy), push commits to <emphasis>that</emphasis> copy,
and open a merge request from their fork back to the main project.
This model allows the owner to be in full control of what goes into the repository and when, while allowing
contributions from untrusted users.</simpara>
<simpara>Merge requests and issues are the main units of long-lived discussions in GitLab.
Each merge request allows a line-by-line discussion of the proposed change (which supports a lightweight kind
of code review), as well as a general overall discussion thread.
Both can be assigned to users, or organized into milestones.</simpara>
<simpara>This section is focused mainly on the Git-related features of GitLab, but as a mature project,
it provides many other features to help your team work together, such as project wikis and system maintenance tools.
One benefit to GitLab is that, once the server is set up and running, you rarely need to tweak a configuration
file or access the server via SSH. Most administration and general usage can be accomplished through the web UI.</simpara>
</section>
</section>
<section xml:id="_third_party_hosted_options">
<title>Third Party Hosted Options</title>
<simpara>If you don&#8217;t want to bother setting up your own Git server, there are several options for hosting Git
projects on a dedicated hosting site. These offer a number of advantages: you can start using a hosting site quickly,
and no hardware maintenance is required. Even if you set up and run your own server internally, you may still
want to use a public hosting site for your open source code. It&#8217;s generally easier for the open source community
to access and contribute to.</simpara>
<simpara>These days, there are a huge number of hosting options to choose from, each with different advantages and disadvantages.
To see an up-to-date list, check out the GitHosting page on the main Git wiki at
<link xl:href="https://git.wiki.kernel.org/index.php/GitHosting">https://git.wiki.kernel.org/index.php/GitHosting</link></simpara>
<simpara>We cover using GitHub in detail in <xref linkend="ch06-github"/>. It&#8217;s the largest Git host out there and you may need
to interact with projects hosted on it, but there are dozens more to choose from should you not want to set up your own
Git server.</simpara>
</section>
<section xml:id="_summary_4">
<title>Summary</title>
<simpara>You have several options to get a remote Git repository up and running to collaborate with others.</simpara>
<simpara>Running your own server gives you complete control and allows you to run the server inside your own firewall,
but such a server generally requires a fair amount of time to set up and maintain.
If you place your data on a hosted server, it&#8217;s easy to set up and maintain. However, you have to be willing to
keep your code on someone else&#8217;s servers, and some organizations don&#8217;t allow that.</simpara>
<simpara>It should be fairly straightforward to determine which solution or combination of solutions is appropriate
for you and your organization.</simpara>
</section>
</chapter>
<chapter xml:id="ch05-distributed-git">
<title>Distributed Git</title>
<simpara><indexterm>
<primary>distributed git</primary>
</indexterm>
Now that you&#8217;ve set up a remote Git repository for your developers to share code, and you&#8217;re familiar with the
basic Git commands that work on local repositories, we now look at how to utilize some of the distributed workflows
that Git allows.</simpara>
<simpara>In this chapter, you see how to work with Git in a distributed environment as a contributor and as an integrator.
That is, you learn how to contribute code to a project while making it as easy on you and the project maintainer
as possible, and also how to maintain a project that a number of developers contribute to.</simpara>
<section xml:id="_distributed_workflows">
<title>Distributed Workflows</title>
<simpara><indexterm>
<primary>workflows</primary>
</indexterm>
Unlike Centralized VCSs (CVCSs), Git&#8217;s distributed orientation allows developers to be far more
flexible in how they collaborate. In CVCSs, every developer is a client working more or less equally on a central server.
With Git, however, every developer is potentially both a client and a server&#8201;&#8212;&#8201;that is, every developer can both
contribute code to other repositories, and maintain a public repository on which others can base their work and
to which they can contribute. This opens a vast range of workflow possibiliti,s for your project and your team.
We cover a few common workflows that take advantage of this flexibility and go over possible strengths and
weaknesses of each option. You can choose a single one to use, or you can mix and match features from each.</simpara>
<section xml:id="_centralized_workflow">
<title>Centralized Workflow</title>
<simpara><indexterm>
<primary>workflows</primary><secondary>centralized</secondary>
</indexterm>
<indexterm>
<primary>centralized</primary>
</indexterm>
In CVCSs, there&#8217;s generally a single collaboration model&#8201;&#8212;&#8201;the centralized workflow.
One server contains the central repository, and everyone synchronizes their work with it.
Developers are clients of that server&#8201;&#8212;&#8201;and synchronize with that one repository.</simpara>
<figure>
<title>Centralized workflow.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/centralized_workflow.png"/>
</imageobject>
<textobject><phrase>Centralized workflow.</phrase></textobject>
</mediaobject>
</figure>
<simpara>This means that if two developers clone from the server and both make changes, the first developer to push their
changes can do so with no conflicts. The second developer must merge the first developer&#8217;s changes into their working
directory before pushing their changes, so that the changes don&#8217;t overwrite the first developer&#8217;s changes.
This is as true in Git as it is in Subversion<indexterm>
<primary>Subversion</primary>
</indexterm> (or any CVCS), and this model works perfectly well in Git.</simpara>
<simpara>If you&#8217;re already comfortable with a centralized workflow, you can easily continue using it with Git.
Simply set up a single repository, and give everyone on your team write access to it. Git doesn&#8217;t let users overwrite
each other&#8217;s changes. Say John and Jessica both start working at the same time.
John finishes his changes and pushes them to the server. Then Jessica tries to push her changes. The server rejects them.
She&#8217;s told that she&#8217;s trying to push non-fast-forward changes and that she can&#8217;t do so until she fetches
the latest changes and merges them into her working directory. This workflow is attractive to a lot of people because
it&#8217;s a paradigm that many are familiar and comfortable with.</simpara>
<simpara>This is also not limited to small teams. With Git&#8217;s branching model, it&#8217;s possible for hundreds of developers to successfully work on a single project containing dozens of branches simultaneously.</simpara>
</section>
<section xml:id="_integration_manager">
<title>Integration-Manager Workflow</title>
<simpara><indexterm>
<primary>workflows</primary><secondary>integration manager</secondary>
</indexterm>
<indexterm>
<primary>integration manager</primary>
</indexterm>
Because Git allows multiple remote repositories, it&#8217;s possible to have a workflow where each developer has write
access to their own public repository and read access to everyone else&#8217;s.
This scenario often includes a central repository that represents the official project sources.
To contribute to that project, you create your own public clone of the project and push your changes to it.
Then, you send a request to the integration manager of the central repository to pull your changes.
The manager then adds your repository as a remote on their private repository, pulls your changes, tests them locally,
merges them into their branch, and pushes them to the central repository.
The process works as follows (see <xref linkend="wfdiag_b"/>):</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The integration manager pushes to the blessed repository.</simpara>
</listitem>
<listitem>
<simpara>A developer clones that repository and makes changes to their private copy.</simpara>
</listitem>
<listitem>
<simpara>The developer pushes to their public copy.</simpara>
</listitem>
<listitem>
<simpara>The developer sends the integration manager a message asking them to pull changes.</simpara>
</listitem>
<listitem>
<simpara>The integration manager adds the contributor&#8217;s repo as a remote and merges locally.</simpara>
</listitem>
<listitem>
<simpara>The integration manager pushes merged changes to the blessed repository.</simpara>
</listitem>
</orderedlist>
<figure xml:id="wfdiag_b">
<title>Integration-manager workflow.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/integration-manager.png"/>
</imageobject>
<textobject><phrase>Integration-manager workflow.</phrase></textobject>
</mediaobject>
</figure>
<simpara><indexterm>
<primary>forking</primary>
</indexterm>
This is a very common workflow with hub-based tools like GitHub or GitLab, where it&#8217;s easy to fork a project and
push your changes into your fork for everyone to see.
One of the main advantages of this approach is that you can continue to work after you send the message
to the integration manager, who can pull your changes at any time.</simpara>
</section>
<section xml:id="_dictator_and_lieutenants_workflow">
<title>Dictator and Lieutenants Workflow</title>
<simpara><indexterm>
<primary>workflows</primary><secondary>dictator and lieutenants</secondary>
</indexterm>
<indexterm>
<primary>dictator and lieutenants</primary>
</indexterm>
This is a variant of a multiple-repository workflow.
It&#8217;s generally used by huge projects with hundreds of collaborators. One famous example is the Linux kernel.
Various integration managers, called lieutenants, are in charge of certain parts of the repository.
The project has one integration manager, known as the benevolent dictator.
The benevolent dictator pushes from his directory to a reference repository from which all collaborators need to pull.
The process works like this (see <xref linkend="wfdiag_c"/>):</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Regular developers work on their topic branch and rebase their work on top of the dictator&#8217;s <literal>master</literal> branch in their public repository.</simpara>
</listitem>
<listitem>
<simpara>Lieutenants merge the developers' topic branches into their <literal>master</literal> branch in their public repository.</simpara>
</listitem>
<listitem>
<simpara>The dictator merges the lieutenants' <literal>master</literal> branches into his <literal>master</literal> branch in their public repository.</simpara>
</listitem>
<listitem>
<simpara>The dictator pushes their <literal>master</literal> to the reference repository so the other developers can use it.</simpara>
</listitem>
</orderedlist>
<figure xml:id="wfdiag_c">
<title>Benevolent dictator workflow.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/benevolent-dictator.png"/>
</imageobject>
<textobject><phrase>Benevolent dictator workflow.</phrase></textobject>
</mediaobject>
</figure>
<simpara>This kind of workflow isn&#8217;t common, but can be useful in very big projects, or in highly hierarchical environments.
It allows the project leader (the dictator) to delegate much of the work and to collect large amounts of code
changes at multiple points before integrating them.</simpara>
</section>
<section xml:id="_workflows_summary">
<title>Workflows Summary</title>
<simpara>These are some commonly used workflows that are possible with a distributed system like Git, but you can see that
many variations are possible. Now that you can (hopefully) determine which workflow combination may work for you,
we cover some more specific examples of how to accomplish the main tasks that make up the different workflows.
In the next section, you learn a few common patterns for contributing to a project.</simpara>
</section>
</section>
<section xml:id="_contributing_project">
<title>Contributing to a Project</title>
<simpara><indexterm>
<primary>contributing</primary>
</indexterm>
The main difficulty with describing how to contribute to a project is that there are a huge number of ways to do it.
Because Git is very flexible, people can and do work together in many ways, and it&#8217;s difficult to describe how
to contribute&#8201;&#8212;&#8201;every project is different.
Some of the relevant considerations are active contributor count, chosen workflow, commit access permissions,
and possibly the external contribution method.</simpara>
<simpara>The first consideration is active contributor count&#8201;&#8212;&#8201;how many users actively contribute to this project, and how often?
You often have two or three developers making a few commits a day, or possibly fewer for dormant projects.
For larger projects, the number of developers could be in the thousands, with hundreds or thousands of commits each day.
This is important because with more and more developers, you run into more issues making sure changes
can be easily merged. Changes you submit may be rendered obsolete or severely broken by work that was
merged in while you were working, while your changes were waiting for approval, or while they were waiting to be applied.
How can you keep your code consistently up to date and your commits valid?</simpara>
<simpara>The next consideration is the project&#8217;s workflow.
Is it centralized, with each developer having write access to the main codeline?
Does the project have a maintainer or integration manager who checks all the patches?
Are all the patches peer-reviewed and approved?
Are you involved in that process?
Is a lieutenants workflow being used, and do you have to submit your work to them first?</simpara>
<simpara>The next consideration is commit access.
The workflow required to contribute to a project is much different if you have write access than if you don&#8217;t.
If you don&#8217;t have write access, how does the project prefer to accept contributed work?
Does it even have a policy? How much work do you contribute at a time? How often do you contribute?</simpara>
<simpara>All these questions can affect how you contribute effectively to a project and what workflows are preferred
or available to you. We cover aspects of each of these in a series of use cases,
moving from simple to more complex.
You should be able to construct the specific workflows you need in practice from these examples.</simpara>
<section xml:id="_commit_guidelines">
<title>Commit Guidelines</title>
<simpara>Before we start looking at specific use cases, here&#8217;s a quick note about commits.
Having a good guideline for making commits and sticking to it makes working with Git and
collaborating with others a lot easier.
The Git project provides a document that lays out a number of good tips for making commits.
Read it in the Git source code in <literal>Documentation/SubmittingPatches</literal>.</simpara>
<simpara><indexterm>
<primary>git commands</primary><secondary>diff</secondary><tertiary>check</tertiary>
</indexterm>
<indexterm>
<primary>diff</primary><secondary>check</secondary>
</indexterm>
<indexterm>
<primary>check</primary>
</indexterm>
First, don&#8217;t submit any whitespace errors.
Git provides an easy way to check for them. Before you commit, run <literal>git diff --check</literal>,
which identifies possible whitespace errors.</simpara>
<figure>
<title>Output of <literal>git diff --check</literal>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/git-diff-check.png"/>
</imageobject>
<textobject><phrase>Output of `git diff --check`.</phrase></textobject>
</mediaobject>
</figure>
<simpara>By running that command before committing, you can tell if your commit contains whitespace
issues that may annoy other developers.</simpara>
<simpara>Next, try to make each commit logically separate.
If you can, try to make your changes digestible. Don&#8217;t code for a whole weekend on five different
issues and then submit all the changes as one massive commit on Monday.
Even if you don&#8217;t commit during the weekend, use the staging area on Monday to split your work into
at least one commit per issue, with a useful message per commit.
If some of the changes modify the same file, try to run <literal>git add --patch</literal> to partially stage files
(covered in detail in <xref linkend="_interactive_staging"/>).
The latest version of the project is identical whether you make one commit or five, as long
as all the changes are added at some point, so try to make things easier on your fellow developers
when they review your changes.</simpara>
<simpara>This approach also makes it easier to revert one of the commits later.
<xref linkend="_rewriting_history"/> describes a number of useful Git tricks for rewriting history
and interactively staging files. Use these to help craft a clean and understandable history before
sending the work to someone else.</simpara>
<simpara>The last thing to keep in mind is the commit message.
Getting in the habit of creating quality commit messages makes collaborating with Git a lot easier.
As a general rule, your messages should start with a single line that&#8217;s no more than about 50
characters long that describes the change concisely, followed by a blank line, followed by a
more detailed explanation. The Git project requires that the more detailed explanation include your
motivation for the change and that you contrast its implementation with previous behavior.
This is a good guideline to follow.
It&#8217;s also a good idea to use the imperative present tense in these messages.
Instead of <literal>I added tests for</literal> or <literal>Adding tests for,</literal> use <literal>Add tests for.</literal>
Here&#8217;s a <link xl:href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">sample commit comment originally
written by Tim Pope</link>:</simpara>
<programlisting language="text" linenumbering="unnumbered">Short (50 chars or less) summary of changes

More detailed explanatory text, if necessary.  Wrap it to
about 72 characters or so.  In some contexts, the first
line is treated as the subject of an email and the rest of
the text as the body.  The blank line separating the
summary from the body is critical (unless you omit the body
entirely); tools like rebase can get confused if you run
the two together.

Further paragraphs come after blank lines.

  - Bullet points are okay, too

  - Typically a hyphen or asterisk is used for the bullet,
    preceded by a single space, with blank lines in
    between, but conventions vary here</programlisting>
<simpara>If all your commit messages look like this, things are a lot easier for you and the developers you work with.
The Git project has well-formatted commit messages. Run <literal>git log --no-merges</literal> in the
Git source repository to see what a nicely formatted project commit history looks like.</simpara>
<note>
<title>Do as we say, not as we do.</title>
<simpara>For the sake of brevity, many of the examples in this book don&#8217;t have nicely-formatted commit
messages like this. Instead, we simply use the <literal>-m</literal> flag to <literal>git commit</literal>.</simpara>
<simpara>In short, do as we say, not as we do.</simpara>
</note>
</section>
<section xml:id="_private_team">
<title>Private Small Team</title>
<simpara><indexterm>
<primary>contributing</primary><secondary>private small team</secondary>
</indexterm>
<indexterm>
<primary>private small team</primary>
</indexterm>
The simplest setup you&#8217;re likely to encounter is a private project with one or two other developers.
Private, in this case, means closed-source&#8201;&#8212;&#8201;not accessible to the outside world.
You and the other developers all have push access to the repository.</simpara>
<simpara>In this environment, you can follow a workflow similar to when using Subversion or other CVCS.
You still enjoy the advantages of Git for things like offline commits and vastly simpler branching and merging,
but the workflow can be very similar. The main difference is that merges happen at commit
time on the client rather than on the server.
Let&#8217;s see what might happen when two developers start to work together with a shared repository.
The first developer, John, clones the repository, makes a change, and commits locally.
(The protocol messages have been replaced with <literal>...</literal> in these examples to shorten them.)</simpara>
<programlisting language="console" linenumbering="unnumbered"># John's Machine
$ git clone john@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'remove invalid default value'
[master 738ee87] remove invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)</programlisting>
<simpara>The second developer, Jessica, does the same thing&#8201;&#8212;&#8201;clones the repository, makes a change,
and commits locally.</simpara>
<programlisting language="console" linenumbering="unnumbered"># Jessica's Machine
$ git clone jessica@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)</programlisting>
<simpara>Now, Jessica pushes her work to the server.</simpara>
<programlisting language="console" linenumbering="unnumbered"># Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&gt; master</programlisting>
<simpara>John tries to push his change too.</simpara>
<programlisting language="console" linenumbering="unnumbered"># John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&gt; master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'</programlisting>
<simpara>John isn&#8217;t allowed to push because Jessica pushed first.
This is especially important to understand if you&#8217;re used to Subversion, because notice
that the two developers didn&#8217;t edit the same file.
Although Subversion automatically does such a merge on the server if different files are edited,
in Git you must first merge the commits locally.
John has to fetch Jessica&#8217;s changes and merge them before he&#8217;s allowed to push.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -&gt; origin/master</programlisting>
<simpara>At this point, John&#8217;s local repository looks something like</simpara>
<figure>
<title>John&#8217;s divergent history.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/small-team-1.png"/>
</imageobject>
<textobject><phrase>John&#8217;s divergent history.</phrase></textobject>
</mediaobject>
</figure>
<simpara>John has a reference to the changes Jessica pushed, but he has to merge them into his own work
before he is allowed to push.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge origin/master
Merge made by the 'recursive' strategy.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)</programlisting>
<simpara>The merge goes smoothly. John&#8217;s commit history now looks like</simpara>
<figure>
<title>John&#8217;s repository after merging <literal>origin/master</literal>.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/small-team-2.png"/>
</imageobject>
<textobject><phrase>John&#8217;s repository after merging `origin/master`.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now, John can test his code to make sure it still works properly, and then he can push
his new merged commits to the server.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&gt; master</programlisting>
<simpara>Finally, John&#8217;s commit history looks like</simpara>
<figure>
<title>John&#8217;s history after pushing to the <literal>origin</literal> server.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/small-team-3.png"/>
</imageobject>
<textobject><phrase>John&#8217;s history after pushing to the `origin` server.</phrase></textobject>
</mediaobject>
</figure>
<simpara>In the meantime, Jessica has been working on a topic branch
called <literal>issue54</literal> and has made three commits.
She hasn&#8217;t fetched John&#8217;s changes yet, so her commit history looks like</simpara>
<figure>
<title>Jessica&#8217;s topic branch.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/small-team-4.png"/>
</imageobject>
<textobject><phrase>Jessica&#8217;s topic branch.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Jessica wants to sync with John, so she fetches from the server.</simpara>
<programlisting language="console" linenumbering="unnumbered"># Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -&gt; origin/master</programlisting>
<simpara>That pulls the work John has pushed in the meantime.
Jessica&#8217;s history now looks like this:</simpara>
<figure>
<title>Jessica&#8217;s history after fetching John&#8217;s changes.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/small-team-5.png"/>
</imageobject>
<textobject><phrase>Jessica&#8217;s history after fetching John&#8217;s changes.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Jessica thinks her topic branch is ready, but she wants to know what she has to merge into her work
so that she can push. She runs <literal>git log</literal> to find out.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 16:01:27 2009 -0700

   remove invalid default value</programlisting>
<simpara>The <literal>issue54..origin/master</literal> syntax is a log filter that tells Git to only show the commits
that are on the latter branch (in this case <literal>origin/master</literal>) that aren&#8217;t on the first branch
(in this case <literal>issue54</literal>). We go over this syntax in detail in <xref linkend="_commit_ranges"/>.</simpara>
<simpara>For now, we see from the output that there&#8217;s a single commit that John made that Jessica hasn&#8217;t merged.
If she merges <literal>origin/master</literal>, that&#8217;s the single commit that modifies her local work.</simpara>
<simpara>Now, Jessica can merge her topic work into her <literal>master</literal>, merge John&#8217;s work (<literal>origin/master</literal>) into
her <literal>master</literal>, and then push to the server again.</simpara>
<simpara>First, she switches back to her <literal>master</literal> to integrate all this work.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.</programlisting>
<simpara>Jessica can merge either <literal>origin/master</literal> or <literal>issue54</literal> first&#8201;&#8212;&#8201;they&#8217;re both on the remote,
so the order doesn&#8217;t matter. The end result should be identical no matter which order she chooses.
Only the history is slightly different. She chooses to merge <literal>issue54</literal> first.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)</programlisting>
<simpara>No problems occur. As you see, it was a simple fast-forward merge.
Now Jessica merges in John&#8217;s work (<literal>origin/master</literal>).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)</programlisting>
<simpara>Everything merges cleanly, and Jessica&#8217;s history now looks like</simpara>
<figure>
<title>Jessica&#8217;s history after merging John&#8217;s changes.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/small-team-6.png"/>
</imageobject>
<textobject><phrase>Jessica&#8217;s history after merging John&#8217;s changes.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now <literal>origin/master</literal> is reachable from Jessica&#8217;s <literal>master</literal>, so she should be able to successfully
push (assuming John hasn&#8217;t pushed again in the meantime).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&gt; master</programlisting>
<simpara>Each developer has committed a few times and merged each other&#8217;s work successfully.</simpara>
<figure>
<title>Jessica&#8217;s history after pushing all changes back to the server.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/small-team-7.png"/>
</imageobject>
<textobject><phrase>Jessica&#8217;s history after pushing all changes back to the server.</phrase></textobject>
</mediaobject>
</figure>
<simpara>That&#8217;s one of the simplest workflows.
Work for a while, generally in a topic branch, and merge into your <literal>master</literal> when the topic branch is ready to be integrated.
Then, to share that work, fetch and merge <literal>origin/master</literal> if
it has changed, and then push to <literal>master</literal> on the server. The general sequence is something like</simpara>
<figure>
<title>General sequence of events for a simple multiple-developer Git workflow.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/small-team-flow.png"/>
</imageobject>
<textobject><phrase>General sequence of events for a simple multiple-developer Git workflow.</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_private_managed_team">
<title>Private Managed Team</title>
<simpara><indexterm>
<primary>contributing</primary><secondary>private managed team</secondary>
</indexterm>
<indexterm>
<primary>private managed team</primary>
</indexterm>
In this next scenario, we look at contributor roles in a larger private group.
You learn how to work in an environment where small groups collaborate on features, and then
those team-based contributions are integrated by someone else.</simpara>
<simpara>Let&#8217;s say that John and Jessica are working together on one feature, while Jessica and Josie
are working on a second. In this case, the company is using a type of integration-manager workflow
where the work of the individual groups is integrated only by certain engineers, and <literal>master</literal> in
the main repo can be updated only by those engineers.
In this scenario, all work is done in team-based branches and pulled together by integrators later.</simpara>
<simpara>Let&#8217;s follow Jessica&#8217;s workflow as she works on her two features, collaborating in parallel
with two different developers. Assuming she already has cloned the repository she&#8217;s going to work on,
she decides to work on <literal>featureA</literal> first.
She creates a new branch for the feature and does some work on it there.</simpara>
<programlisting language="console" linenumbering="unnumbered"># Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)</programlisting>
<simpara>At this point, she needs to share her work with John, so she pushes her <literal>featureA</literal> commits to the server.
Jessica doesn&#8217;t have push access to <literal>master</literal>&#8201;&#8212;&#8201;only the integrators do&#8201;&#8212;&#8201;so she has to push
to another branch in order to collaborate with John.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -&gt; featureA</programlisting>
<simpara>Jessica emails John to tell him that she&#8217;s pushed some work that&#8217;s ready for him to review into a
branch named <literal>featureA</literal>. While she waits for feedback from John, Jessica decides to start
working on <literal>featureB</literal> with Josie. To begin, she again creates a new feature branch,
basing it off the server&#8217;s <literal>master</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered"># Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'</programlisting>
<simpara>Now, Jessica makes a couple of commits on <literal>featureB</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)</programlisting>
<simpara>Jessica&#8217;s repository now looks like</simpara>
<figure>
<title>Jessica&#8217;s initial commit history.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/managed-team-1.png"/>
</imageobject>
<textobject><phrase>Jessica&#8217;s initial commit history.</phrase></textobject>
</mediaobject>
</figure>
<simpara>She&#8217;s ready to push her work, but she gets an email message from Josie saying that a branch
with some initial work on it was already pushed to the server as <literal>featureBee</literal>.
Jessica first needs to merge those changes with her own before she can push to the server.
She can then fetch Josie&#8217;s changes by running <literal>git fetch</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -&gt; origin/featureBee</programlisting>
<simpara>Assuming Jessica is still on <literal>featureB</literal>, she can now merge Josie&#8217;s work into <literal>featureB</literal> by running <literal>git merge</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)</programlisting>
<simpara>There&#8217;s a bit of a problem&#8201;&#8212;&#8201;she needs to push the merged work in her <literal>featureB</literal> to <literal>featureBee</literal> on the server.
She can do so by specifying the local branch followed by a colon (:), followed by the remote branch
to <literal>git push</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&gt; featureBee</programlisting>
<simpara>This is called a <emphasis>refspec</emphasis>.
See <xref linkend="_refspec"/> for a more detailed discussion of refspecs and the
things you can do with them. Also notice the <literal>-u</literal> flag. This is short for <literal>--set-upstream</literal>,
which configures the branches for easier pushing and pulling later.</simpara>
<simpara>Next, John emails Jessica to say he&#8217;s pushed some changes to <literal>featureA</literal> and asks her to verify them.
She runs <literal>git fetch</literal> to pull those changes.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -&gt; origin/featureA</programlisting>
<simpara>Then, Jessica sees what&#8217;s been changed by running <literal>git log</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25</programlisting>
<simpara>Finally, she merges John&#8217;s work into her own <literal>featureA</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)</programlisting>
<simpara>Jessica wants to tweak something, so she commits again and then pushes to the server.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -&gt; featureA</programlisting>
<simpara>Jessica&#8217;s commit history now looks something like</simpara>
<figure>
<title>Jessica&#8217;s history after committing on a feature branch.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/managed-team-2.png"/>
</imageobject>
<textobject><phrase>Jessica&#8217;s history after committing on a feature branch.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Jessica, Josie, and John inform the integrators that <literal>featureA</literal> and <literal>featureBee</literal> on the server
are ready for integration into the mainline. After the integrators merge these branches into the mainline,
a fetch brings the new merge commit, making the history look like</simpara>
<figure>
<title>Jessica&#8217;s history after merging both her topic branches.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/managed-team-3.png"/>
</imageobject>
<textobject><phrase>Jessica&#8217;s history after merging both her topic branches.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Many groups switch to Git because of this ability to have multiple teams working in parallel,
merging different lines of work late in the process. The ability of smaller subgroups
to collaborate via remote branches without necessarily having to involve or impede the entire team
is a huge benefit of Git. The sequence for the workflow you saw here is something like</simpara>
<figure>
<title>Basic sequence of this managed-team workflow.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/managed-team-flow.png"/>
</imageobject>
<textobject><phrase>Basic sequence of this managed-team workflow.</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_public_project">
<title>Forked Public Project</title>
<simpara><indexterm>
<primary>contributing</primary><secondary>public small project</secondary>
</indexterm>
<indexterm>
<primary>public small project</primary>
</indexterm>
Contributing to public projects is a bit different.
Because you don&#8217;t have permission to directly update branches in the project repository, you have to make the
work available to the maintainers some other way. This first example describes contributing via forking.
Many hosting sites support this (including GitHub, BitBucket, repo.or.cz, and others), and many
project maintainers expect this style of contribution.
The next section deals with projects that prefer to accept contributed patches via email.</simpara>
<simpara>First, clone the main repository, create a topic branch for the patch you&#8217;re
planning to contribute, and do your work there. The sequence looks basically like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone &lt;url&gt;
$ cd project
$ git checkout -b featureA
  ... work ...
$ git commit
  ... work ...
$ git commit</programlisting>
<note>
<simpara>You may want to run <literal>git rebase -i</literal> to squash your work into a single commit, or rearrange the work
in the commits to make the patch easier for the maintainer to
review&#8201;&#8212;&#8201;see <xref linkend="_rewriting_history"/> for more information about interactive rebasing.</simpara>
</note>
<simpara>When your work is finished and you&#8217;re ready to contribute it back to the maintainers,
go to the original project page and click the <literal>Fork</literal> button, creating your own writable fork of the project.
Then, add this new repository URL as a second remote, in this case <literal>myfork</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add myfork &lt;url&gt;</programlisting>
<simpara>Then, push your work to it.
It&#8217;s easiest to push the topic branch you&#8217;re working on to your repository,
rather than merging into your <literal>master</literal> and pushing. The reason is that if the work isn&#8217;t
accepted, you don&#8217;t have to rewind your <literal>master</literal>.
If the maintainers <literal>merge</literal> or <literal>rebase</literal> your work, you eventually get it
back by pulling from their repository anyhow.</simpara>
<simpara>In any event, push your work by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push -u myfork featureA</programlisting>
<simpara><indexterm>
<primary>git commands</primary><secondary>request-pull</secondary>
</indexterm>
<indexterm>
<primary>request-pull</primary>
</indexterm>
When your work has been pushed to your fork, notify the maintainer.
This is often called a pull request. GitHub has its own Pull Request mechanism that we
go over in <xref linkend="ch06-github"/>, or run <literal>git request-pull</literal> and email the output to the project maintainer manually.</simpara>
<simpara><literal>git request-pull</literal> takes the name of the base branch into which you want your topic branch pulled and the
Git repository URL you want the maintainer to pull from, and outputs a summary of all the changes
you&#8217;re asking to be pulled in. For instance, if Jessica wants to send John a pull request,
and she&#8217;s made two commits on the topic branch she just pushed, she runs</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
Jessica Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)</programlisting>
<simpara>The output can be emailed to the maintainer. It tells them where the work was branched from,
summarizes the commits, and tells where to pull this work from.</simpara>
<simpara>On a project for which you&#8217;re not the maintainer, it&#8217;s generally easier to have a branch
like <literal>master</literal> always track <literal>origin/master</literal> and to do your work in topic branches that you can easily
discard if they&#8217;re rejected. Having work themes isolated into topic branches also makes it
easier to rebase your work if the tip of the main repository has moved in the meantime and your
commits no longer apply cleanly. For example, to submit a second topic to the project,
don&#8217;t continue working on the topic branch you just pushed. Start over from the main repository&#8217;s <literal>master</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b featureB origin/master
  ... work ...
$ git commit
$ git push myfork featureB
$ git request-pull origin/master myfork
  ... email generated request pull to maintainer ...
$ git fetch origin</programlisting>
<simpara>Now, each of your topics is contained within a silo, similar to a patch queue, that you can rewrite,
rebase, and modify without the topics interfering or interdepending on each other, like</simpara>
<figure>
<title>Initial commit history with <literal>featureB</literal> work.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/public-small-1.png"/>
</imageobject>
<textobject><phrase>Initial commit history with `featureB` work.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Let&#8217;s say the project maintainer has pulled a bunch of other patches and tried your first branch,
but it no longer cleanly merges. In this case, try to rebase that branch on top of <literal>origin/master</literal>,
resolve the conflicts for the maintainer, and then resubmit your changes.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA</programlisting>
<simpara>This rewrites your history to now look like <xref linkend="psp_b"/>.</simpara>
<figure xml:id="psp_b">
<title>Commit history after <literal>featureA</literal> work.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/public-small-2.png"/>
</imageobject>
<textobject><phrase>Commit history after `featureA` work.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Because you rebased the branch, you have to specify <literal>-f</literal> to <literal>git push</literal> in order to replace <literal>featureA</literal>
on the server with a commit that isn&#8217;t a descendant of it.
An alternative would be to push this new work to a different branch on the server
(perhaps called <literal>featureAv2</literal>).</simpara>
<simpara>Let&#8217;s look at one more possible scenario. The maintainer has looked at work in your second branch and
likes the concept but would like you to change an implementation detail.
You also take this opportunity to move the work to be based off the project&#8217;s current <literal>master</literal> branch.
You start a new branch based off the current <literal>origin/master</literal> branch, squash the <literal>featureB</literal> changes there,
resolve any conflicts, make the implementation change, and then push that as a new branch:</simpara>
<simpara><indexterm>
<primary>git commands</primary><secondary>merge</secondary><tertiary>squash</tertiary>
</indexterm>
<indexterm>
<primary>merge</primary><secondary>squash</secondary>
</indexterm>
<indexterm>
<primary>squash</primary>
</indexterm></simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b featureBv2 origin/master
$ git merge --squash featureB
  ... change implementation ...
$ git commit
$ git push myfork featureBv2</programlisting>
<simpara>The <literal>--squash</literal> flag takes all the work on the merged branch and squashes it into one commit
producing the repository state as if a real merge happened, without actually making a merge commit.
This means your future commit has only one parent which allows you to introduce all the changes
from another branch and then make more changes before recording the new commit.
Also the <literal>--no-commit</literal> flag can be used to delay the merge commit in the default merge process.</simpara>
<simpara>Now you can send the maintainer a message that you&#8217;ve made the requested changes and they can find
those changes in <literal>featureBv2</literal>.</simpara>
<figure>
<title>Commit history after <literal>featureBv2</literal> work.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/public-small-3.png"/>
</imageobject>
<textobject><phrase>Commit history after `featureBv2` work.</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_project_over_email">
<title>Public Project over Email</title>
<simpara><indexterm>
<primary>contributing</primary><secondary>public large project</secondary>
</indexterm>
<indexterm>
<primary>public large project</primary>
</indexterm></simpara>
<simpara>Many projects have established procedures for accepting patches. Check the specific rules for each project,
because they might differ. Since several older larger projects accept patches via a developer mailing list,
we go over an example of that now.</simpara>
<simpara>The workflow is similar to the previous use case. Create topic branches for each collection of patches
you work on. The difference is how you submit the patches to the project.
Instead of forking the project and pushing to your own writable repository, generate email versions
of each patch collection and email them to the developer mailing list.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b topicA
  ... work ...
$ git commit
  ... work ...
$ git commit</programlisting>
<simpara><indexterm>
<primary>git commands</primary><secondary>format-patch</secondary>
</indexterm>
<indexterm>
<primary>format-patch</primary>
</indexterm>
Say you have two commits that you want to send to the mailing list.
Run <literal>git format-patch</literal> to generate the mbox-formatted files that you email to the list.
This turns each commit into an email message with the first line of the commit message as the subject
and the rest of the message plus the patch that the commit introduces as the body.
The nice thing about this is that applying a patch from an email generated with <literal>git format-patch</literal>
preserves all the commit information properly.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch</programlisting>
<simpara>Running <literal>git format-patch</literal> shows the names of the patch files it creates.
The <literal>-M</literal> flag tells Git to look for renames. The files end up looking like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0</programlisting>
<simpara>You can also edit these patch files to add more information for the email list that you don&#8217;t
want to appear in the commit message.
If you add text between the <literal>---</literal> line and the beginning of the patch (the <literal>diff --git</literal> line),
then developers can read it but applying the patch excludes it.</simpara>
<simpara>If you send this to a mailing list, sometimes
pasting the text into a GUI-based email client causes formatting issues, especially with smarter
clients that don&#8217;t preserve newlines and other whitespace appropriately.
Luckily, Git provides a tool to help send properly formatted patches via IMAP, which might be easier.
We demonstrate how to send a patch via Gmail, which happens to be the email method we know best.
You can find detailed instructions for a number of mail programs at the end of the
aforementioned <literal>Documentation/SubmittingPatches</literal> file in the Git source code.</simpara>
<simpara><indexterm>
<primary>git commands</primary><secondary>config</secondary>
</indexterm>
<indexterm>
<primary>config</primary>
</indexterm><indexterm>
<primary>email</primary>
</indexterm>
First, set up the imap section in <literal>~/.gitconfig</literal>.
Set each value separately with a series of <literal>git config</literal> commands, or add them manually,
but in the end <literal>~/.gitconfig</literal> should contain something like</simpara>
<programlisting language="ini" linenumbering="unnumbered">[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = YX]8g76G_2^sFbd
  port = 993
  sslverify = false</programlisting>
<simpara>If your IMAP server doesn&#8217;t use SSL, the last two lines aren&#8217;t necessary,
and the host value should be <literal>imap://</literal> instead of <literal>imaps://</literal>.
When that&#8217;s done, run <literal>git imap-send</literal> to place the patch files in the Drafts folder for
your account on the specified IMAP server.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done</programlisting>
<simpara>At this point, you should be able to go to your Drafts folder, change the To field to the
mailing list you&#8217;re sending the patch to, possibly CCing the maintainer or person responsible for that section,
and send the patch off.</simpara>
<simpara>You can also send the patch through an SMTP server. As before, set each value separately
with a series of <literal>git config</literal> commands, or add them manually in the sendemail section in
<literal>~/.gitconfig</literal>.</simpara>
<programlisting language="ini" linenumbering="unnumbered">[sendemail]
  smtpencryption = tls
  smtpserver = smtp.gmail.com
  smtpuser = user@gmail.com
  smtpserverport = 587</programlisting>
<simpara>After this is done, run <literal>git send-email</literal> to send your patch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;]
Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y</programlisting>
<simpara>Then, Git outputs a bunch of log information looking something like this for each patch you&#8217;re sending.</simpara>
<programlisting language="text" linenumbering="unnumbered">(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from
  \line 'From: Jessica Smith &lt;jessica@example.com&gt;'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith &lt;jessica@example.com&gt;
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &lt;y&gt;
References: &lt;y&gt;

Result: OK</programlisting>
</section>
<section xml:id="_summary_5">
<title>Summary</title>
<simpara>This section covered a number of common workflows for dealing with several very different types of
projects, and introduced a couple of new tools to help manage this process.
Next, you see how to work the other side of the coin: maintaining a Git project.
You learn how to be a benevolent dictator or integration manager.</simpara>
</section>
</section>
<section xml:id="_maintaining_a_project">
<title>Maintaining a Project</title>
<simpara><indexterm>
<primary>maintaining a project</primary>
</indexterm>
In addition to knowing how to effectively contribute to a project, you likely need to know how to maintain one.
This can consist of accepting and applying patches generated by <literal>git format-patch</literal> that are emailed to you,
or integrating changes in remote branches for repositories you&#8217;ve added as remotes.
Whether you maintain a canonical repository or want to help by verifying or approving patches,
you need to know how to accept work in a way that&#8217;s clearest for other contributors and sustainable over
the long run.</simpara>
<section xml:id="_working_in_topic_branches">
<title>Working in Topic Branches</title>
<simpara><indexterm>
<primary>branches</primary><secondary>topic</secondary>
</indexterm>
<indexterm>
<primary>topic</primary>
</indexterm>
When you&#8217;re thinking of integrating new work, it&#8217;s generally a good idea to try it out in a <emphasis>topic
branch</emphasis>&#8201;&#8212;&#8201;a temporary branch specifically created to try out that new work.
This way, it&#8217;s easy to concentrate on a patch and leave it if it&#8217;s not working. Later, when you have time,
go back to it to resolve the problem.
If you create a branch name based on the theme of the work, you can easily remember what the work is about.
The maintainer of the Git project tends to name these branches using a name such as <literal>sc/ruby_client</literal>,
where <literal>sc</literal> are the initials of the person who contributed the work.
Remember, create the branch based off <literal>master</literal> by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch sc/ruby_client master</programlisting>
<simpara>Or, to create it and also switch to it immediately, run <literal>git checkout -b</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b sc/ruby_client master</programlisting>
<simpara>Now you&#8217;re ready to add the contributed work you received into this topic branch and determine if
you want to merge it into your longer-term branches.</simpara>
</section>
<section xml:id="_patches_from_email">
<title>Applying Patches from Email</title>
<simpara><indexterm>
<primary>email</primary><secondary>applying patches from</secondary>
</indexterm>
<indexterm>
<primary>applying patches from</primary>
</indexterm>
If you receive a patch over email to integrate into your project, apply the patch in your
topic branch to evaluate the work.
There are two ways to apply an emailed patch: by running <literal>git apply</literal> or <literal>git am</literal>.</simpara>
<section xml:id="_applying_a_patch_by_running_literal_git_apply_literal">
<title>Applying a Patch By Running <literal>git apply</literal></title>
<simpara><indexterm>
<primary>git commands</primary><secondary>apply</secondary>
</indexterm>
<indexterm>
<primary>apply</primary>
</indexterm>
If you receive a patch generated by the <literal>git diff</literal> or a Unix <literal>diff</literal> command (which isn&#8217;t recommended;
see the next section), apply the patch by running <literal>git apply</literal>.
Assuming you saved the patch in <literal>/tmp/patch-ruby-client.patch</literal>, apply the patch by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git apply /tmp/patch-ruby-client.patch</programlisting>
<simpara>This modifies the files in your working directory.
It&#8217;s almost identical to running <literal>patch -p1</literal> to apply the patch, although it&#8217;s more paranoid
and accepts fewer fuzzy matches than <literal>patch</literal>. It also handles file adds, deletes, and renames if
they&#8217;re described in <literal>git diff</literal> format, which <literal>patch</literal> doesn&#8217;t do.
Finally, <literal>git apply</literal> is an <literal>apply all or abort all</literal> model where either everything is applied or nothing is,
whereas <literal>patch</literal> can partially apply patchfiles, leaving your working directory in an incomplete state.
<literal>git apply</literal> is overall much more conservative than <literal>patch</literal>.
It doesn&#8217;t create a commit so after running it, you must manually stage and commit the changes it introduced.</simpara>
<simpara>You can also check if a patch applies cleanly without making any changes by
running <literal>git apply --check</literal> along with the patch filename.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply</programlisting>
<simpara>If there&#8217;s no output, then the patch applies cleanly.
This command also exits with a non-zero status if the check fails, so you can use it in scripts.</simpara>
</section>
<section xml:id="_git_am">
<title>Applying a Patch with <literal>git am</literal></title>
<simpara><indexterm>
<primary>git commands</primary><secondary>am</secondary>
</indexterm>
<indexterm>
<primary>am</primary>
</indexterm>
If the contributor is a Git user who was good enough to run <literal>git format-patch</literal> to generate their patch,
then your job is easier because the patch contains author information and a commit message.
If you can, encourage your contributors to run <literal>git format-patch</literal> instead of <literal>diff</literal> to generate patches.
You should only have to run <literal>git apply</literal> for legacy patches.</simpara>
<simpara>To apply a patch generated by <literal>git format-patch</literal>, run <literal>git am</literal>.
Technically, <literal>git am</literal> is built to read an mbox file, which is a simple, plain-text format for
storing email messages in one text file. It looks something like</simpara>
<programlisting language="console" linenumbering="unnumbered">From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20</programlisting>
<simpara>This is the beginning of the output of <literal>git format-patch</literal> that you saw in the previous section.
This is also a valid mbox email format.
If someone has emailed you the patch properly by running <literal>git send-email</literal>, and you download
that into an mbox format file, then you can point <literal>git am</literal> to that mbox file, and it starts
applying all the patches it sees. If you run an email client that can save several email messages
in mbox format, you can save entire collection of patches into a file and then run <literal>git am</literal> to apply
the patches one at a time.</simpara>
<simpara>However, if someone uploaded a patch file generated via <literal>git format-patch</literal> to a ticketing system
or something similar, you can save the file locally and then pass that file saved on your disk
to <literal>git am</literal> to apply it.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git am 0001-limit-log-function.patch
Applying: add limit to log function</programlisting>
<simpara>You can see that the patch applied cleanly and the command automatically created the new commit.
The author information is taken from the email&#8217;s <literal>From</literal> and <literal>Date</literal> headers, and the commit message
is taken from the <literal>Subject</literal> and body (the part before the patch) of the email.
For example, if this patch were applied from the mbox example above, the commit generated would
look something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &lt;jessica@example.com&gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20</programlisting>
<simpara>The <literal>Commit</literal> information indicates the person who applied the patch and the time it was applied.
The <literal>Author</literal> information is the individual who originally created the patch and when it was originally created.</simpara>
<simpara>But it&#8217;s possible that the patch doesn&#8217;t apply cleanly.
Perhaps your main branch has diverged too far from the branch the patch was built from, or the
patch depends on another patch you haven&#8217;t applied yet.
In that case, <literal>git am</literal> fails and asks what to do.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".</programlisting>
<simpara>This command puts conflict markers in any files it has issues with, much like a conflicted merge
or rebase operation. Solve this issue much the same way&#8201;&#8212;&#8201;edit the file to resolve the conflict,
stage the new file, and then run <literal>git am --resolved</literal> to continue to the next patch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ (fix the file)
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem</programlisting>
<simpara>For Git to try a bit more intelligently to resolve the conflict, try running <literal>git am</literal> with the <literal>-3</literal> flag,
which makes Git attempt a three-way merge. This method isn&#8217;t the default because it doesn&#8217;t work if
the commit the patch says it was based on isn&#8217;t in your repository. If that commit is in your
repository&#8201;&#8212;&#8201;if the patch was based on a public commit&#8201;&#8212;&#8201;then the <literal>-3</literal> flag is generally much
smarter about applying a conflicting patch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.</programlisting>
<simpara>In this case, this patch had already been applied.
Without the <literal>-3</literal> flag, you see what looks like a conflict.</simpara>
<simpara>If you&#8217;re applying a number of patches from an mbox file, run <literal>git am</literal> in interactive mode,
which stops at each patch it finds and asks if you want to apply it.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</programlisting>
<simpara>This is nice if you have a number of patches to apply, because you can view the patch first if you don&#8217;t
remember what it is, or decline to apply the patch if you&#8217;ve already done so.</simpara>
<simpara>When all the patches for your topic are applied and committed into your branch, choose whether
and how to integrate them into a longer-running branch.</simpara>
</section>
</section>
<section xml:id="_checking_out_remotes">
<title>Checking Out Remote Branches</title>
<simpara><indexterm>
<primary>branches</primary><secondary>remote</secondary>
</indexterm>
<indexterm>
<primary>remote</primary>
</indexterm>
If a contribution comes from a Git user who set up their own repository, pushed a number of changes into it,
and then sent you the URL to the repository and the name of the remote branch the changes are in,
add the remote repository as a remote and do merges locally.</simpara>
<simpara>For instance, if Jessica sends an email message saying that she has a great new feature in the
<literal>ruby-client</literal> branch of her repository, test it by adding the remote and checking out that branch locally.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client</programlisting>
<simpara>If she emails you again later with another branch containing another great feature, you can easily
fetch from that branch because you already have the remote set up.</simpara>
<simpara>This is most useful if you&#8217;re working with a person consistently.
If someone only has a single patch to contribute once in a while, then accepting it over email may be
less time consuming than requiring everyone to run their own server and having to continually add
and remove remotes to get a few patches.
You&#8217;re also unlikely to have hundreds of remotes, each for someone who contributes only
a patch or two. However, scripts and hosted services may make this easier&#8201;&#8212;&#8201;it depends
largely on how you and your contributors develop.</simpara>
<simpara>The other advantage of this approach is that you get the history of the commits as well.
Although you may have legitimate merge issues, you know where in your history their work is based.
A proper three-way merge is the default rather than having to add the <literal>-3</literal> flag to <literal>git merge</literal> and hope the patch
was generated off a public commit to which you have access.</simpara>
<simpara>If you aren&#8217;t working with a person consistently but still want to pull from them this way,
provide the URL of the remote repository to <literal>git pull</literal>.
This does a one-time pull and doesn&#8217;t save the URL as a remote reference.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -&gt; FETCH_HEAD
Merge made by the 'recursive' strategy.</programlisting>
</section>
<section xml:id="_what_is_introduced">
<title>Determining What&#8217;s Introduced</title>
<simpara><indexterm>
<primary>branches</primary><secondary>diffing</secondary>
</indexterm>
<indexterm>
<primary>diffing</primary>
</indexterm>
Now you have a topic branch that contains contributed work.
At this point, you can determine what you&#8217;d like to do with it.
This section revisits a couple of commands to show how to review exactly what you&#8217;re
introducing if you merge the topic branch into your main branch.</simpara>
<simpara>It&#8217;s often helpful to get a review of all the commits in this branch but not in <literal>master</literal>.
You can exclude commits in <literal>master</literal> by adding the <literal>--not</literal> flag before the branch name.
This does the same thing as the <literal>master..contrib</literal> format that we used earlier.
For example, if your contributor sends two patches and you create a branch called <literal>contrib</literal> and apply
those patches there, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better</programlisting>
<simpara>To see what changes each commit introduces, remember to include the <literal>-p</literal> flag to <literal>git log</literal> to
append the diff introduced to each commit.</simpara>
<simpara>To see a full diff of what would happen if you were to merge this topic branch with another branch,
you may have to use a weird trick to get the correct results. You may think of running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff master</programlisting>
<simpara>This command shows a diff, but it may be misleading.
If <literal>master</literal> has moved forward since you created the topic branch from it, you get seemingly strange results.
This happens because Git directly compares the last commit of the topic branch you&#8217;re
on and the last commit on <literal>master</literal>.
For example, if you&#8217;ve added a line to a file on <literal>master</literal>, a direct comparison looks
like the topic branch is going to remove that line.</simpara>
<simpara>If <literal>master</literal> is a direct ancestor of your topic branch, this isn&#8217;t a problem. But if the two
histories have diverged, the diff looks like you&#8217;re adding all the new stuff in your topic
branch and removing everything unique to <literal>master</literal>.</simpara>
<simpara>What you really want is to see the changes added to the topic branch&#8201;&#8212;&#8201;the work you introduce
if you merge this branch with <literal>master</literal>. Do that by having Git compare the last commit on your topic
branch with the first common ancestor it has with <literal>master</literal>.</simpara>
<simpara>Technically, you do that by explicitly figuring out the common ancestor and then running your diff on it.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db</programlisting>
<simpara>or, more concisely</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff $(git merge-base contrib master)</programlisting>
<simpara>However, that isn&#8217;t convenient, so Git provides another shorthand for doing the same
thing: the triple-dot syntax.
In the context of <literal>git diff</literal>, you can put three periods after another branch to do a <literal>diff</literal> between
the last commit of the branch you&#8217;re on and its common ancestor with another branch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff master...contrib</programlisting>
<simpara>This command shows only the work your current topic branch has introduced since its common
ancestor with <literal>master</literal>. That&#8217;s a very useful syntax to remember.</simpara>
</section>
<section xml:id="_integrating_contributed_work">
<title>Integrating Contributed Work</title>
<simpara><indexterm>
<primary>integrating work</primary>
</indexterm>
When all the work in your topic branch is ready to be integrated into a more mainline branch,
the question is how to do it. Furthermore, what overall workflow do you want to use to maintain your project?
You have a number of choices, so we cover a few of them.</simpara>
<section xml:id="_merging_workflows">
<title>Merging Workflows</title>
<simpara><indexterm>
<primary>workflows</primary><secondary>merging</secondary>
</indexterm>
<indexterm>
<primary>merging</primary>
</indexterm>
One simple workflow merges your work into <literal>master</literal>.
In this scenario, <literal>master</literal> contains basically stable code.
When you have work in a topic branch that you&#8217;ve done or that someone has contributed and you&#8217;ve verified,
merge it into <literal>master</literal>, delete the topic branch, and then continue the process.
If we have a repository with work in two branches named <literal>ruby_client</literal> and <literal>php_client</literal> that looks like
<xref linkend="merwf_a"/>, and we merge <literal>ruby_client</literal> first and then <literal>php_client</literal> next,
your history ends up looking like <xref linkend="merwf_b"/></simpara>
<figure xml:id="merwf_a">
<title>History with several topic branches.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/merging-workflows-1.png"/>
</imageobject>
<textobject><phrase>History with several topic branches.</phrase></textobject>
</mediaobject>
</figure>
<figure xml:id="merwf_b">
<title>After a topic branch merge.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/merging-workflows-2.png"/>
</imageobject>
<textobject><phrase>After a topic branch merge.</phrase></textobject>
</mediaobject>
</figure>
<simpara>That&#8217;s probably the simplest workflow, but it can be a problem if you&#8217;re dealing with larger
or more stable projects where you want to be really careful about what you introduce.</simpara>
<simpara>If you have a more important project, you might want to use a two-phase merge cycle.
In this scenario, you have two long-running branches, <literal>master</literal> and <literal>develop</literal>.
You decide that <literal>master</literal> is updated only when a very stable release is cut. All new code
is integrated into <literal>develop</literal>. You regularly push both of these branches to the public repository.
Each time you have a new topic branch to merge in (<xref linkend="merwf_c"/>), you merge it into <literal>develop</literal> (<xref linkend="merwf_d"/>).
Then, when you tag a release, you fast-forward <literal>master</literal> to wherever the now-stable <literal>develop</literal> is (<xref linkend="merwf_e"/>).</simpara>
<figure xml:id="merwf_c">
<title>Before a topic branch merge.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/merging-workflows-3.png"/>
</imageobject>
<textobject><phrase>Before a topic branch merge.</phrase></textobject>
</mediaobject>
</figure>
<figure xml:id="merwf_d">
<title>After a topic branch merge.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/merging-workflows-4.png"/>
</imageobject>
<textobject><phrase>After a topic branch merge.</phrase></textobject>
</mediaobject>
</figure>
<figure xml:id="merwf_e">
<title>After a project release.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/merging-workflows-5.png"/>
</imageobject>
<textobject><phrase>After a topic branch release.</phrase></textobject>
</mediaobject>
</figure>
<simpara>This way, when people clone your project&#8217;s repository, they can either check out <literal>master</literal> to
build the latest stable version and easily keep up to date, or they can check out develop,
which is more cutting-edge. You can also continue this concept, having an integration branch where
all the work is merged together. Then, when the codebase on that branch is stable and passes tests,
merge it into a develop branch. When that branch has proven stable for a while, fast-forward <literal>master</literal>.</simpara>
</section>
<section xml:id="_large_merging_workflows">
<title>Large-Merging Workflows</title>
<simpara><indexterm>
<primary>workflows</primary><secondary>merging (large)</secondary>
</indexterm>
<indexterm>
<primary>merging (large)</primary>
</indexterm>
The Git project has four long-running branches: <literal>master</literal>, <literal>next</literal>, <literal>pu</literal> (proposed updates) for new work,
and <literal>maint</literal> for maintenance backports. When new work is introduced by contributors, it&#8217;s collected
into topic branches in the maintainer&#8217;s repository in a manner similar to what we&#8217;ve described
(see <xref linkend="merwf_f"/>). At this point, the topics are evaluated to determine whether they&#8217;re safe
and ready for consumption or whether they need more work. If they&#8217;re safe, they&#8217;re merged into <literal>next</literal>,
and that branch is pushed so everyone can try the integrated topics.</simpara>
<figure xml:id="merwf_f">
<title>Managing a complex series of parallel contributed topic branches.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/large-merges-1.png"/>
</imageobject>
<textobject><phrase>Managing a complex series of parallel contributed topic branches.</phrase></textobject>
</mediaobject>
</figure>
<simpara>If the topics still need work, they&#8217;re merged into <literal>pu</literal> instead.
When it&#8217;s determined that they&#8217;re totally stable, the topics are re-merged into <literal>master</literal> and are
then rebuilt from the topics that were in <literal>next</literal> but didn&#8217;t yet graduate to <literal>master</literal>.
This means <literal>master</literal> almost always moves forward, <literal>next</literal> is rebased occasionally, and <literal>pu</literal> is
rebased even more often.</simpara>
<figure>
<title>Merging contributed topic branches into long-term integration branches.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/large-merges-2.png"/>
</imageobject>
<textobject><phrase>Merging contributed topic branches into long-term integration branches.</phrase></textobject>
</mediaobject>
</figure>
<simpara>When a topic branch has finally been merged into <literal>master</literal>, it&#8217;s removed from the repository.
The Git project also has a <literal>maint</literal> branch that&#8217;s forked off from the last release to provide
backported patches in case a maintenance release is required. Thus, when you clone the Git repository,
you have four branches that you can check out to evaluate the project in different stages of development,
depending on how cutting edge you want to be or how you want to contribute. The maintainer has a
structured workflow to help them vet new contributions. The Git project&#8217;s workflow is unusual.
To clearly understand it, study the
<link xl:href="https://github.com/git/git/blob/master/Documentation/howto/maintain-git.txt">Git Maintainer&#8217;s guide</link>.</simpara>
</section>
<section xml:id="_rebase_cherry_pick">
<title>Rebasing and Cherry-Picking Workflows</title>
<simpara><indexterm>
<primary>workflows</primary><secondary>rebasing and cherry-picking</secondary>
</indexterm>
<indexterm>
<primary>rebasing and cherry-picking</primary>
</indexterm>
Other maintainers prefer to rebase contributed work on top of their <literal>master</literal>,
rather than merging it in, to keep a mostly linear history.
When you have work in a topic branch and want to integrate it, move to that branch and
run <literal>git rebase</literal> to rebuild the changes on top of <literal>master</literal> (or <literal>develop</literal>, and so on).
If that works well, you can fast-forward <literal>master</literal>, and you end up with a linear project history.</simpara>
<simpara><indexterm>
<primary>git commands</primary><secondary>cherry-pick</secondary>
</indexterm>
<indexterm>
<primary>cherry-pick</primary>
</indexterm>
The other way to move introduced work from one branch to another is to cherry-pick the work.
A cherry-pick in Git is like a rebase for a single commit.
It takes the patch that was introduced in a commit and tries to reapply it on the branch you&#8217;re currently on.
This is useful if you have a number of commits on a topic branch and you want to integrate only one of them,
or if you only have one commit on a topic branch and you&#8217;d prefer to cherry-pick it rather than rebasing.
For example, suppose you have a project that looks like</simpara>
<figure>
<title>Example history before a cherry-pick.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/rebasing-1.png"/>
</imageobject>
<textobject><phrase>Example history before a cherry-pick.</phrase></textobject>
</mediaobject>
</figure>
<simpara>To pull commit <literal>e43a6</literal> into <literal>master</literal>, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cherry-pick e43a6
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)</programlisting>
<simpara>This pulls the same change introduced in <literal>e43a6</literal>, but you get a new commit hash,
because the date applied is different. Now your history looks like</simpara>
<figure>
<title>History after cherry-picking a commit on a topic branch.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/rebasing-2.png"/>
</imageobject>
<textobject><phrase>History after cherry-picking a commit on a topic branch.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now you can remove your topic branch and drop the commits you didn&#8217;t want to pull.</simpara>
</section>
<section xml:id="_rerere">
<title>Rerere</title>
<simpara><indexterm>
<primary>git commands</primary><secondary>rerere</secondary>
</indexterm>
<indexterm>
<primary>rerere</primary>
</indexterm><indexterm>
<primary>rerere</primary>
</indexterm>
If you&#8217;re doing lots of merging and rebasing, or you&#8217;re maintaining a long-lived topic branch,
Git has a feature called <literal>rerere</literal> that can help.</simpara>
<simpara>Rerere stands for <literal>reuse recorded resolution</literal>. It&#8217;s a way of shortcutting manual conflict resolution.
When rerere is enabled, Git keeps a set of pre- and post-images from successful merges,
and if it notices that there&#8217;s a conflict that looks exactly like one you&#8217;ve already fixed,
it just uses the fix from last time, without bothering you to do it again.</simpara>
<simpara>This feature comes in two parts: a configuration setting and a command.
The configuration setting is <literal>rerere.enabled</literal>, and it&#8217;s handy enough to put in your global config.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global rerere.enabled true</programlisting>
<simpara>Now, whenever you do a merge that resolves conflicts, the resolution is recorded in the cache in
case you need it in the future.</simpara>
<simpara>You interact with the rerere cache by running <literal>git rerere</literal>.
Git checks its database of resolutions and tries to find a match with any current merge
conflicts and resolve them (this is done automatically if <literal>rerere.enabled</literal> is <literal>true</literal>).
There are also options to see what&#8217;s recorded, to erase specific resolutions from the cache,
and to clear the entire cache.
We cover rerere in more detail in <xref linkend="ref_rerere"/>.</simpara>
</section>
</section>
<section xml:id="_tagging_releases">
<title>Tagging Your Releases</title>
<simpara><indexterm>
<primary>tags</primary>
</indexterm><indexterm>
<primary>tags</primary><secondary>signing</secondary>
</indexterm>
<indexterm>
<primary>signing</primary>
</indexterm>
When you&#8217;ve decided to cut a release, you probably want to create a tag so you can re-create
that release at any point in the future.
You can create a new tag as discussed in <xref linkend="ch02-git-basics-chapter"/>.
If you decide to sign the tag as the maintainer, this may look something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon &lt;schacon@gmail.com&gt;"
1024-bit DSA key, ID F721C45A, created 2009-02-09</programlisting>
<simpara>If you do sign your tags, you may have the problem of distributing the public PGP key you used.
The maintainer of the Git project has solved this issue by including his public key
in the repository and then adding a tag that points directly to it.
You can figure out which key you want by running <literal>gpg --list-keys</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &lt;schacon@gmail.com&gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</programlisting>
<simpara>Then, you can directly import the key into Git by exporting it and piping that
through <literal>git hash-object</literal>, which writes a new entry in the Git repository with that content
and returns the SHA-1 hash of the entry.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92</programlisting>
<simpara>Now that your key is in Git, you can create a tag that points directly to it by specifying the
SHA-1 hash that <literal>git hash-object</literal> showed.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</programlisting>
<simpara>If you run <literal>git push --tags</literal>, the <literal>maintainer-pgp-pub</literal> tag is shared with everyone.
If anyone wants to verify a tag, they can directly import your PGP key by pulling it directly
out of Git and importing it into GPG.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show maintainer-pgp-pub | gpg --import</programlisting>
<simpara>They can use that key to verify all your signed tags.
Also, if you include instructions in the tag message, running <literal>git show &lt;tag&gt;</literal> shows the end user
more specific instructions about tag verification.</simpara>
</section>
<section xml:id="_build_number">
<title>Generating a Build Number</title>
<simpara><indexterm>
<primary>build numbers</primary>
</indexterm><indexterm>
<primary>git commands</primary><secondary>describe</secondary>
</indexterm>
<indexterm>
<primary>describe</primary>
</indexterm>
Because Git doesn&#8217;t assign monotonically increasing numbers like <emphasis>v123</emphasis> to each commit,
to have a human-readable name to go with a commit, run <literal>git describe</literal> on that commit.
Git shows the name of the nearest tag with the number of commits on top of that tag and a
partial SHA-1 hash of the commit you&#8217;re describing.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git describe master
v1.6.2-rc1-20-g8c5b85c</programlisting>
<simpara>This way, you can export a build and name it something understandable to people.
In fact, if you build Git from source code cloned from the Git repository,
<literal>git --version</literal> shows something that looks like this.
If you&#8217;re describing a commit that you&#8217;ve directly tagged, it gives the tag name.</simpara>
<simpara><literal>git describe</literal> favors annotated tags (tags created with the <literal>-a</literal> or <literal>-s</literal> flag),
so release tags should be created this way to ensure the commit is named properly.
You can also pass this string to a <literal>git checkout</literal> or <literal>git show</literal> command,
although it relies on the abbreviated SHA-1 hash at the end, so it may not be valid forever.
For instance, the Linux kernel recently jumped from 8 to 10 characters to ensure SHA-1 hash uniqueness,
so older <literal>git describe</literal> output names are no longer valid.</simpara>
</section>
<section xml:id="_preparing_release">
<title>Preparing a Release</title>
<simpara><indexterm>
<primary>releasing</primary>
</indexterm><indexterm>
<primary>git commands</primary><secondary>archive</secondary>
</indexterm>
<indexterm>
<primary>archive</primary>
</indexterm>
Now you want to release a build.
One thing to do is create an archive of the latest working directory of your code for those
poor souls who don&#8217;t use Git. The command to run is <literal>git archive</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git archive master --prefix='project/' | gzip &gt; `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz</programlisting>
<simpara>The resulting tarball now contains the latest version of your project under a directory named <literal>project</literal>.
You can also create a zip archive in much the same way by passing the <literal>--format=zip</literal> flag
to <literal>git archive</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git archive master --prefix='project/' --format=zip &gt; `git describe master`.zip</programlisting>
<simpara>You now have a nice tarball and a zip archive of your project release that you can upload to your website or email to people.</simpara>
</section>
<section xml:id="_the_shortlog">
<title>The Shortlog</title>
<simpara><indexterm>
<primary>git commands</primary><secondary>shortlog</secondary>
</indexterm>
<indexterm>
<primary>shortlog</primary>
</indexterm>
It&#8217;s time to email your mailing list of people who want to know what&#8217;s happening in your project.
A nice way of quickly getting a sort of changelog of what&#8217;s changed in your project since your last
release is to run <literal>git shortlog</literal>. It summarizes all the commits in the range provide.
For example, the following gives a summary of all the commits since your last release,
if your last release was named v1.0.1.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2</programlisting>
<simpara>You get a clean summary of all the commits since v1.0.1, grouped by author, that you can email to your list.</simpara>
</section>
</section>
<section xml:id="_summary_6">
<title>Summary</title>
<simpara>You should feel fairly comfortable contributing to a Git project as well as maintaining your own project or integrating
other users' contributions. Congratulations on being an effective Git developer!
In the next chapter, you learn how to use the largest and most popular Git hosting service, GitHub.</simpara>
</section>
</chapter>
<chapter xml:id="ch06-github">
<title>GitHub</title>
<simpara><indexterm>
<primary>GitHub</primary>
</indexterm></simpara>
<simpara>GitHub is one of the largest Git hosting sites, and is the central point of collaboration
for millions of developers and projects. A large percentage of all Git repositories are hosted on GitHub.
Many open-source projects use it for Git hosting, issue tracking, code review, and other things.
So while it&#8217;s not an actual part of the Git open source project, there&#8217;s a good chance that you interact
with GitHub.</simpara>
<simpara>This chapter is about using GitHub effectively.
We cover signing up for and managing an account, creating and using Git repositories,
common workflows to contribute to projects, workflows for accepting contributions to your projects,
GitHub&#8217;s programmatic interface, and lots of little tips to make your life easier.</simpara>
<simpara>If you&#8217;re not interested in using GitHub to host your own projects or to collaborate with other projects, you can safely skip to <xref linkend="ch07-git-tools"/>.</simpara>
<warning>
<title>Interfaces Change</title>
<simpara>It&#8217;s important to note that like many active websites, the UI elements in these screenshots are bound
to change over time. Hopefully the general idea of what we&#8217;re trying to accomplish still exists.</simpara>
</warning>
<section xml:id="_account_setup_and_configuration">
<title>Account Setup and Configuration</title>
<simpara><indexterm>
<primary>GitHub</primary><secondary>user accounts</secondary>
</indexterm>
<indexterm>
<primary>user accounts</primary>
</indexterm>
The first thing to do is set up a free user account.
Simply visit <link xl:href="https://github.com">https://github.com</link>, choose a user name that isn&#8217;t already taken,
provide an email address and a password, and click the big green <literal>Sign up for GitHub</literal> button.</simpara>
<figure>
<title>The GitHub sign-up form.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/signup.png"/>
</imageobject>
<textobject><phrase>The GitHub sign-up form.</phrase></textobject>
</mediaobject>
</figure>
<simpara>The next thing you see is the pricing page for paid plans, but it&#8217;s safe to ignore this for now.
GitHub sends you an email message to verify the address you provided.
Go ahead and do what it says. This is pretty important, as we see later.</simpara>
<note>
<simpara>GitHub provides all of its features with free accounts, with the limitation that all of your projects
are fully public (everyone has read access). GitHub&#8217;s paid plans include a set number of private projects,
but we aren&#8217;t covering this option in this book.</simpara>
</note>
<simpara>Clicking the Octocat logo at the top-left of the page takes you to your dashboard.
You&#8217;re now ready to use GitHub.</simpara>
<section xml:id="_ssh_access_2">
<title>SSH Access</title>
<simpara><indexterm>
<primary>SSH keys</primary><secondary>with GitHub</secondary>
</indexterm>
<indexterm>
<primary>with GitHub</primary>
</indexterm>
As of right now, can access Git repositories using the <literal>https://</literal> protocol,
authenticating with the username and password you just provided. However, to simply clone public projects,
you don&#8217;t even need to sign up. We use the account we just created when we fork projects and push
to these forks a bit later.</simpara>
<simpara>To access remotes using SSH, configure a public key.
(If you don&#8217;t already have one, see <xref linkend="_generate_ssh_key"/>.)
Open up your account settings using the icon at the top-right of the window.</simpara>
<figure>
<title>The <literal>Account settings</literal> icon.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/account-settings.png"/>
</imageobject>
<textobject><phrase>The `Account settings` link.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Then select the <literal>SSH keys</literal> section along the left-hand side.</simpara>
<figure>
<title>The <literal>SSH keys</literal> link.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ssh-keys.png"/>
</imageobject>
<textobject><phrase>The `SSH keys` link.</phrase></textobject>
</mediaobject>
</figure>
<simpara>From there, click the "<literal>Add SSH key</literal>" button, give your key a name, paste the content of
your <literal>~/.ssh/id_rsa.pub</literal> (or whatever you named it) public-key file into the text area, and click <literal>Add key</literal>.</simpara>
<note>
<simpara>Be sure to name your SSH key something you can remember. You can name each of your
keys (e.g. "My Laptop" or "Work Account") so that if you need to revoke a key later,
you can easily tell which one you&#8217;re looking for.</simpara>
</note>
</section>
<section xml:id="_personal_avatar">
<title>Your Avatar</title>
<simpara>Next, if you wish, replace the avatar that&#8217;s generated for you with an image of your choosing.
First go to the <literal>Profile</literal> tab (above the SSH Keys tab) and click <literal>Upload new picture</literal>.</simpara>
<figure>
<title>The <literal>Profile</literal> link.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/your-profile.png"/>
</imageobject>
<textobject><phrase>The `Profile` link.</phrase></textobject>
</mediaobject>
</figure>
<simpara>We choose a copy of the Git logo that&#8217;s on our hard drive. Then we crop it.</simpara>
<figure>
<title>Crop your avatar</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/avatar-crop.png"/>
</imageobject>
<textobject><phrase>Crop your uploaded avatar.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now people see your avatar next to your username.</simpara>
<simpara>If you happen to have uploaded an avatar to the popular Gravatar service (often used for Wordpress accounts),
that avatar is used by default and you don&#8217;t need to do this step.</simpara>
</section>
<section xml:id="_your_email_addresses">
<title>Your Email Addresses</title>
<simpara>The way that GitHub maps your commits to your account is by email address.
If you use multiple email addresses in your commits and you want GitHub to handle them properly,
add all the email addresses you&#8217;ve used to the Email section.</simpara>
<figure xml:id="_add_email_addresses">
<title>Add email addresses</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/email-settings.png"/>
</imageobject>
<textobject><phrase>Add all your email addresses.</phrase></textobject>
</mediaobject>
</figure>
<simpara>In <xref linkend="_add_email_addresses"/> we see some of the possible states. The top address is verified
and set as the primary address, meaning that&#8217;s where you get any notifications and receipts.
The second address is verified so it can be set as primary.
The final address is unverified, meaning that it can&#8217;t be your primary address.
If GitHub sees any of these in commit messages in any repository on the site,
they&#8217;re associated with your account.</simpara>
</section>
<section xml:id="_two_factor_authentication">
<title>Two-Factor Authentication</title>
<simpara>Finally, for extra security, you should definitely set up Two-factor authentication or <literal>2FA</literal>.
Two-factor authentication is an authentication mechanism that&#8217;s become more and more popular
recently to mitigate the risk of your account being compromised if your password is stolen.
Turning it on makes GitHub ask for two different methods of authentication, so that if one
of them is compromised, an attacker still can&#8217;t access your account.</simpara>
<simpara>You can find the Two-factor authentication setup under the Security tab of your Account settings.</simpara>
<figure>
<title>2FA in the Security Tab</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/2fa-1.png"/>
</imageobject>
<textobject><phrase>2FA in the Security Tab</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you click the <literal>Set up two-factor authentication</literal> button, it takes you to a configuration page
where you can choose to use a phone app to generate your secondary code (a <literal>time based one-time password</literal>),
or you can have GitHub send you a code via SMS each time you need to log in.</simpara>
<simpara>After you choose a method and follow the instructions, your account is then a little more secure and you
have to provide a code in addition to your password whenever you log into GitHub.</simpara>
</section>
</section>
<section xml:id="_contributing_to_a_project">
<title>Contributing to a Project</title>
<simpara>Now that your account is set up, let&#8217;s walk through some details of how to contribute to an
existing project.</simpara>
<section xml:id="_forking_projects">
<title>Forking Projects</title>
<simpara><indexterm>
<primary>forking</primary>
</indexterm>
To contribute to an existing project to which you don’t have push access, <literal>fork</literal> the project.
This means that GitHub makes a copy that&#8217;s entirely yours of the project. It lives in your account,
and since you own it, you can push to it.</simpara>
<note>
<simpara>Historically, the term <literal>fork</literal> has a somewhat negative context, meaning that someone took an
open source project and created a competing project.
In GitHub, a <literal>fork</literal> is simply a way to copy a project into your own account,
allowing you to make changes with the intention of contributing them back.</simpara>
</note>
<simpara>This way, projects don’t have to worry about adding users as collaborators to give them push access.
People can fork a project, push changes to it, and contribute their changes back to the original
repository by creating what&#8217;s called a Pull Request, which we cover next.
This opens a discussion thread on GitHub for reviewing the change, and the project owner and the
contributor can then communicate about the change until the owner is happy with it,
at which point the owner can merge it.</simpara>
<simpara>To fork a project, visit the project page and click the <literal>Fork</literal> button at the top-right of the page.</simpara>
<figure>
<title>The &#8220;Fork&#8221; button.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/forkbutton.png"/>
</imageobject>
<textobject><phrase>The `Fork` button.</phrase></textobject>
</mediaobject>
</figure>
<simpara>After a few seconds, you&#8217;re taken to your new project page, with your own writeable copy
of the original project.</simpara>
</section>
<section xml:id="ch06-github_flow">
<title>The GitHub Flow</title>
<simpara><indexterm>
<primary>GitHub</primary><secondary>Flow</secondary>
</indexterm>
<indexterm>
<primary>Flow</primary>
</indexterm>
GitHub is designed around a particular collaboration workflow, centered on Pull Requests.
This flow works whether you&#8217;re collaborating with a tightly-knit team in a single shared repository,
or a globally-distributed collection of strangers, each of whom have created their own fork.
It&#8217;s centered on the <xref linkend="_topic_branch"/> workflow covered in <xref linkend="ch03-git-branching"/>.</simpara>
<simpara>Here&#8217;s how it generally works:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Click the <literal>Fork</literal> button to get your own copy of the project.</simpara>
</listitem>
<listitem>
<simpara>Clone your forked copy to a local repository.</simpara>
</listitem>
<listitem>
<simpara>Create a topic branch from <literal>master</literal>.</simpara>
</listitem>
<listitem>
<simpara>Make commits on the topic branch.</simpara>
</listitem>
<listitem>
<simpara>Push the topic branch to your GitHub repository.</simpara>
</listitem>
<listitem>
<simpara>Open a Pull Request on GitHub.</simpara>
</listitem>
<listitem>
<simpara>Continue discussing and committing until the project owner is satisfied.</simpara>
</listitem>
<listitem>
<simpara>The project owner merges or closes the Pull Request.</simpara>
</listitem>
</orderedlist>
<simpara>This is basically the Integration Manager workflow covered in <xref linkend="_integration_manager"/>,
but instead of using email to communicate and review changes, teams use GitHub&#8217;s web based tools.</simpara>
<simpara>Let&#8217;s walk through an example of proposing a change to an open source project hosted on GitHub
using this workflow.</simpara>
<section xml:id="_creating_a_pull_request">
<title>Creating a Pull Request</title>
<simpara>Tony is looking for code to run on his Arduino programmable microcontroller and has found a great program
on GitHub at <link xl:href="https://github.com/schacon/blink">https://github.com/schacon/blink</link>.</simpara>
<figure>
<title>The project we want to contribute to.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/blink-01-start.png"/>
</imageobject>
<textobject><phrase>The project we want to contribute to.</phrase></textobject>
</mediaobject>
</figure>
<simpara>The only problem is that the blink rate is too fast. We think it&#8217;s much nicer to wait 3 seconds
instead of 1 second between each state change. So let&#8217;s improve the program and submit the change
back to the project as a proposed change.</simpara>
<simpara>First, we click the <literal>Fork</literal> button to get our own copy of the project. Our user name here is
<literal>tonychacon</literal> so our copy of this project is at <literal>https://github.com/tonychacon/blink</literal>.
We clone it locally, create a topic branch, make the code change, and finally push that change back
to our GitHub fork.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone https://github.com/tonychacon/blink <co xml:id="CO1-1"/>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <co xml:id="CO1-2"/>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino (macOS) <co xml:id="CO1-3"/>
# If you're on a Linux system, do this instead:
# $ sed -i 's/1000/3000/' blink.ino <co xml:id="CO1-4"/>

$ git diff --word-diff <co xml:id="CO1-5"/>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'three seconds is better' <co xml:id="CO1-6"/>
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <co xml:id="CO1-7"/>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -&gt; slow-blink</programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>Clone our fork of the project locally</para>
</callout>
<callout arearefs="CO1-2">
<para>Create a descriptive topic branch</para>
</callout>
<callout arearefs="CO1-3 CO1-4">
<para>Make our change to the code</para>
</callout>
<callout arearefs="CO1-5">
<para>Check that the change is good</para>
</callout>
<callout arearefs="CO1-6">
<para>Commit our change to the topic branch</para>
</callout>
<callout arearefs="CO1-7">
<para>Push our new topic branch back to our GitHub fork</para>
</callout>
</calloutlist>
<simpara>Now if we go back to our fork on GitHub, we see that GitHub noticed that we pushed a new topic
branch and presents us with a big green button to check out our changes and open a Pull Request
to the original project.</simpara>
<simpara>You can alternatively go to the <literal>Branches</literal> page at <literal>https://github.com/&lt;user&gt;/&lt;project&gt;/branches</literal>
to locate your branch and open a new Pull Request from there.</simpara>
<figure>
<title>Pull Request button</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/blink-02-pr.png"/>
</imageobject>
<textobject><phrase>Pull Request button</phrase></textobject>
</mediaobject>
</figure>
<simpara><indexterm>
<primary>GitHub</primary><secondary>pull requests</secondary>
</indexterm>
<indexterm>
<primary>pull requests</primary>
</indexterm>
If we click that green button, we see a page where we create a title and description for the change
we made so the project owner has a good reason to consider it. It&#8217;s generally a good idea to spend
some effort making this description as accurate as possible so the author knows why the change is being
suggested and why it would be valuable.</simpara>
<simpara>We also see a list of the commits in our topic branch that are "ahead" of <literal>master</literal> (in this case,
just the one) and a unified diff of all the changes in the commits should this branch get merged
by the project owner.</simpara>
<figure>
<title>Pull Request creation page</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/blink-03-pull-request-open.png"/>
</imageobject>
<textobject><phrase>Pull Request creation</phrase></textobject>
</mediaobject>
</figure>
<simpara>When you click the <literal>Create pull request</literal> button, the owner of the project you forked gets
notified that someone is suggesting a change. The owner also gets a link to a page containing information
about the change.</simpara>
<note>
<simpara>Though Pull Requests are commonly used for public projects when the contributor&#8217;s change
is ready to be considered, they&#8217;re also often used in internal projects <emphasis>at the beginning</emphasis> of
the development cycle. Since you can keep pushing to the topic branch even <emphasis role="strong">after</emphasis> the Pull
Request is opened, it&#8217;s often opened early and used as a way to work as a team, rather than
being opened at the very end of the process when the change is complete.</simpara>
</note>
</section>
<section xml:id="_iterating_on_a_pull_request">
<title>Iterating on a Pull Request</title>
<simpara>At this point, the project owner can look at the suggested change and merge it, reject it, or comment on it.
Let&#8217;s say that he likes the idea, but would prefer a slightly longer time for the light to be off.</simpara>
<simpara>While this conversation may take place over email in the workflows presented
in <xref linkend="ch05-distributed-git"/>, on GitHub this happens online.
The project owner can review the changes and leave a comment by clicking on any of the lines in the change.</simpara>
<figure>
<title>Comment on a specific line of code in a Pull Request</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/blink-04-pr-comment.png"/>
</imageobject>
<textobject><phrase>PR line comment</phrase></textobject>
</mediaobject>
</figure>
<simpara>Once the maintainer makes a comment, the person who opened the Pull Request (and indeed,
anyone else watching the repository) gets a notification. Later we go over customizing this,
but if he had email notifications turned on, Tony would get an email message like</simpara>
<figure xml:id="_email_notification">
<title>Comments sent as email notifications</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/blink-04-email.png"/>
</imageobject>
<textobject><phrase>Email notification</phrase></textobject>
</mediaobject>
</figure>
<simpara>Anyone can also leave general comments on the Pull Request. In <xref linkend="_pr_discussion"/> we see an example
of the project owner both commenting on a line of code and then leaving a general comment in the
discussion section. Code comments are brought into the conversation as well.</simpara>
<figure xml:id="_pr_discussion">
<title>Pull Request discussion page</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/blink-05-general-comment.png"/>
</imageobject>
<textobject><phrase>PR discussion page</phrase></textobject>
</mediaobject>
</figure>
<simpara>Now the contributor can see what they need to do in order to get their change accepted.
Luckily this is also very simple. When communicating over email you may have to reroll your patches
and resubmit them to the mailing list, with GitHub you simply commit to the local topic
branch again and push, which automatically updates the Pull Request.
In <xref linkend="_pr_final"/> you also see that the old code comment has been collapsed in the updated
Pull Request since it was made on a line that has since been changed.</simpara>
<simpara>Adding commits to an existing Pull Request doesn&#8217;t trigger a notification, so once Tony has
pushed his corrections he decides to leave a comment to inform the project owner that he made
the requested change.</simpara>
<figure xml:id="_pr_final">
<title>Pull Request final</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/blink-06-final.png"/>
</imageobject>
<textobject><phrase>PR final</phrase></textobject>
</mediaobject>
</figure>
<simpara>An interesting thing to notice is that if you click the <literal>Files Changed</literal> tab on this Pull Request,
you see the "unified" diff&#8201;&#8212;&#8201;that is, all the changes that would be introduced to your main branch
if this topic branch was merged in. In <literal>git diff</literal> terms, it automatically shows the output
of <literal>git diff master...&lt;branch&gt;</literal> for the branch this Pull Request is based on.
See <xref linkend="_what_is_introduced"/> for more about this type of diff.</simpara>
<simpara>The other thing you notice is that GitHub checks to see if the Pull Request merges cleanly
and provides a button to do the merge for you on the server.
This button only shows up if you have write access to the repository and a trivial merge is possible.
Clicking it performs a <literal>non-fast-forward</literal> merge, meaning that even if the merge <emphasis role="strong">could</emphasis> be a fast-forward,
it still creates a merge commit.</simpara>
<simpara>If you prefer, simply pull the branch and merge it locally. If you merge this branch into <literal>master</literal> and
push it to GitHub, the Pull Request automatically is closed.</simpara>
<simpara>This is the basic workflow that most GitHub projects use. Topic branches are created, Pull Requests
are opened on them, a discussion ensues, possibly more work is done on the branch,
and eventually the request is either closed or merged.</simpara>
<note>
<title>Not Only Forks</title>
<simpara>It&#8217;s important to note that you can also open a Pull Request between two branches in the same repository.
If you&#8217;re working on a feature with someone, and you both have write access to the project,
you can push a topic branch to the repository and open a Pull Request to <literal>master</literal> of that same project
to initiate the code review and discussion process. No forking is necessary.</simpara>
</note>
</section>
</section>
<section xml:id="_advanced_pull_requests">
<title>Advanced Pull Requests</title>
<simpara>Now that we&#8217;ve covered the basics of contributing to a project on GitHub, let&#8217;s cover a few interesting
tips and tricks about Pull Requests so you can be more effective using them.</simpara>
<section xml:id="_pull_requests_as_patches">
<title>Pull Requests as Patches</title>
<simpara>It&#8217;s important to understand that many projects don&#8217;t really think of Pull Requests as queues
of perfect patches that should apply cleanly in order, as most mailing list-based projects think
of patch contributions. Most GitHub projects think about Pull Request branches as iterative
conversations around a proposed change, culminating in a unified diff that&#8217;s applied by merging.</simpara>
<simpara>This is an important distinction, because generally the change is suggested before the code
is complete and working, which is far rarer with mailing list based patch contributions.
This enables an earlier conversation with the maintainers so that arriving at the proper
solution is more of a community effort. When code is proposed with a Pull Request and the
maintainers or community suggest a change, the patches are generally not recreated,
but instead the difference is pushed as a new commit, moving the conversation forward with the
previous work still visible.</simpara>
<simpara>For instance, if you go back and look again at <xref linkend="_pr_final"/>, you notice that the contributor didn&#8217;t
rebase his commit and send another Pull Request. Instead he added new commits and pushed them to the
existing branch. This way if you go back and look at this Pull Request in the future, you can easily
find all of the context of why decisions were made. Clicking the <literal>Merge</literal> button purposefully creates a
merge commit that references the Pull Request so that it&#8217;s easy to go back and research the original
conversation, if necessary.</simpara>
</section>
<section xml:id="_keeping_up_with_upstream">
<title>Keeping up with Upstream</title>
<simpara>If your Pull Request becomes out of date or otherwise doesn&#8217;t merge cleanly, fix it so the
maintainer can easily do the merge. GitHub tests this for you and lets you know at the bottom
of every Pull Request if the merge is trivial or not.</simpara>
<figure xml:id="_pr_fail">
<title>Pull Request does not merge cleanly</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/pr-01-fail.png"/>
</imageobject>
<textobject><phrase>PR merge failure</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you see something like <xref linkend="_pr_fail"/>, fix your branch so that the icon turns green and
the maintainer doesn&#8217;t have to do extra work.</simpara>
<simpara>You have two main options to do this. You can either rebase your branch on top of whatever
the target branch is (normally <literal>master</literal> of the repository you forked), or you can merge
the target branch into your branch.</simpara>
<simpara>Most developers on GitHub choose the latter, for the same reasons we just went over in the previous section.
What matters is the history and the final merge, so rebasing doesn&#8217;t result in much more than a slightly
cleaner history and in return is <emphasis role="strong">far</emphasis> more difficult and error prone.</simpara>
<simpara>To merge in the target branch to make your Pull Request mergeable, add the original repository as a new
remote, fetch from it, merge the main branch of that repository into your topic branch, fix any issues,
and finally push it back to the same branch you opened the Pull Request on.</simpara>
<simpara>For example, let&#8217;s say that in the <literal>tonychacon</literal> example we were using before, the original
author made a change that would create a conflict in the Pull Request. Let&#8217;s go through those steps.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add upstream https://github.com/schacon/blink <co xml:id="CO2-1"/>

$ git fetch upstream <co xml:id="CO2-2"/>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -&gt; upstream/master

$ git merge upstream/master <co xml:id="CO2-3"/>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <co xml:id="CO2-4"/>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <co xml:id="CO2-5"/>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -&gt; slow-blink</programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>Add the original repository as a remote named &#8220;upstream&#8221;</para>
</callout>
<callout arearefs="CO2-2">
<para>Fetch the newest work from that remote</para>
</callout>
<callout arearefs="CO2-3">
<para>Merge the main branch of that repository into your topic branch</para>
</callout>
<callout arearefs="CO2-4">
<para>Fix the conflict that occurred</para>
</callout>
<callout arearefs="CO2-5">
<para>Push back up to the same topic branch</para>
</callout>
</calloutlist>
<simpara>Once you do that, the Pull Request is automatically updated and rechecked to see if it merges cleanly.</simpara>
<figure xml:id="_pr_merge_fix">
<title>Pull Request now merges cleanly</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/pr-02-merge-fix.png"/>
</imageobject>
<textobject><phrase>PR fixed</phrase></textobject>
</mediaobject>
</figure>
<simpara>One of the great things about Git is that you can follow these steps as many times as necessary.
If you have a very long-running project, you can easily merge from the target branch over and over
again, and only have to deal with conflicts that have arisen since the last time you merged.</simpara>
<simpara>If you absolutely must rebase the branch to clean it up, you can certainly do so,
but it&#8217;s highly encouraged that you not force pushing over the branch that the Pull Request is already opened on.
If other people have pulled it and done more work on it, you run into all of the issues outlined
in <xref linkend="_rebase_peril"/>. Instead, push the rebased branch to a new branch on GitHub
and open a brand new Pull Request referencing the old one, then close the original.</simpara>
</section>
<section xml:id="_references">
<title>References</title>
<simpara>You may be wondering how to reference an old Pull Request. It turns out there are many,
many ways to reference things almost anywhere you can provide input in GitHub.</simpara>
<simpara>Let&#8217;s start with how to cross-reference another Pull Request. All Pull Requests are assigned numbers
unique within the project. To reference any Pull Request from within another one,
simply put <literal>#&lt;num&gt;</literal> in any comment or description. You can also be more specific if the Pull Request
lives somewhere else. Use <literal>username#&lt;num&gt;</literal> if you&#8217;re referring to a Pull Request in a fork of the repository
you&#8217;re in, or <literal>username/repo#&lt;num&gt;</literal> to reference something in another repository.</simpara>
<simpara>Let&#8217;s look at an example. Say we rebased the branch in the previous example, created a new
Pull Request for it, and now we want to reference the old Pull Request from the new one.
Fill out the description just like <xref linkend="_pr_references"/>.</simpara>
<figure xml:id="_pr_references">
<title>Cross references in a Pull Request.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/mentions-01-syntax.png"/>
</imageobject>
<textobject><phrase>PR references</phrase></textobject>
</mediaobject>
</figure>
<simpara>When we submit this Pull Request, we see all of that rendered like <xref linkend="_pr_references_render"/>.</simpara>
<figure xml:id="_pr_references_render">
<title>Cross references rendered in a Pull Request.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/mentions-02-render.png"/>
</imageobject>
<textobject><phrase>PR references rendered</phrase></textobject>
</mediaobject>
</figure>
<simpara>Notice that the full GitHub URL we entered was shortened.</simpara>
<simpara>Now if Tony goes back and closes out the original Pull Request, we see that by mentioning
it in the new one, GitHub has automatically created a trackback event in the Pull Request timeline.
This means that anyone who visits this Pull Request and sees that it&#8217;s closed can easily link back
to the one that superseded it. The link looks something like <xref linkend="_pr_closed"/>.</simpara>
<figure xml:id="_pr_closed">
<title>Link back to the new Pull Request in the closed Pull Request timeline.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/mentions-03-closed.png"/>
</imageobject>
<textobject><phrase>PR closed</phrase></textobject>
</mediaobject>
</figure>
<simpara>In addition to issue numbers, you can also reference a specific commit by its SHA-1 hash.
You have to specify the full 40 character SHA-1 hash, but if GitHub sees that in a comment,
it links directly to the commit. Again, you can reference commits in forks or other repositories
in the same way you did with Pull Requests.</simpara>
</section>
</section>
<section xml:id="_github_flavored_markdown">
<title>GitHub Flavored Markdown</title>
<simpara>Linking to other Pull Requests is just the beginning of the interesting things you can do in almost any
text box on GitHub. In Pull Request descriptions, comments, code comments, and more, you can use
what&#8217;s called <literal>GitHub Flavored Markdown</literal>. Markdown is like writing in plain text but what you write
is rendered as if it were a web page.</simpara>
<simpara>See <xref linkend="_example_markdown"/> for an example of how comments or text can be written and
then rendered using Markdown.</simpara>
<figure xml:id="_example_markdown">
<title>An example of GitHub Flavored Markdown as written and as rendered.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/markdown-01-example.png"/>
</imageobject>
<textobject><phrase>Example Markdown</phrase></textobject>
</mediaobject>
</figure>
<simpara>The GitHub flavor of Markdown adds to the basic Markdown syntax. This can all be really useful when creating useful Pull Request comments or descriptions.</simpara>
<section xml:id="_task_lists">
<title>Task Lists</title>
<simpara>The first really useful GitHub-specific Markdown feature, especially for use in Pull Requests,
is the Task List. A Task List is a list of checkboxes of things to do.
Putting them into a Pull Request normally indicates things that you want to get done
before you consider the item complete.</simpara>
<simpara>Create a Task List like this:</simpara>
<programlisting language="text" linenumbering="unnumbered">- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code</programlisting>
<simpara>If we include this in the description of our Pull Request, we see it rendered like <xref linkend="_eg_task_lists"/></simpara>
<figure xml:id="_eg_task_lists">
<title>Task lists rendered in a Markdown comment.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/markdown-02-tasks.png"/>
</imageobject>
<textobject><phrase>Example Task List</phrase></textobject>
</mediaobject>
</figure>
<simpara>This is often used in Pull Requests to indicate what you&#8217;d like to do on the branch before the
Pull Request is ready to merge. The really cool part is that you can simply click the checkboxes
to update the comment&#8201;&#8212;&#8201;you don&#8217;t have to edit the Markdown directly to check tasks off.</simpara>
<simpara>What&#8217;s more, GitHub looks for Task Lists in your Pull Requests and shows them as metadata on
the pages that contain them. For example, if you have a Pull Request with tasks and you look
at the overview page of all Pull Requests, you see how complete the Task List is.
This helps people break down Pull Requests into subtasks and helps track the progress of the branch.
An example of this is in <xref linkend="_task_list_progress"/>.</simpara>
<figure xml:id="_task_list_progress">
<title>Task list summary in the Pull Request list.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/markdown-03-task-summary.png"/>
</imageobject>
<textobject><phrase>Example Task List</phrase></textobject>
</mediaobject>
</figure>
<simpara>These are incredibly useful when you open a Pull Request early and use it to track your progress
through feature implementation.</simpara>
</section>
<section xml:id="_code_snippets">
<title>Code Snippets</title>
<simpara>You can also add code snippets to comments. This is especially useful when presenting something that you
<emphasis>could</emphasis> try before actually implementing it. This is also often used to add examples of what
isn&#8217;t working or what this Pull Request could implement.</simpara>
<simpara>To add a snippet of code <literal>fence</literal> it in backticks.</simpara>
<programlisting language="text" linenumbering="unnumbered">```java
for(int i=0 ; i &lt; 5 ; i++)
{
   System.out.println("i is : " + i);
}
```</programlisting>
<simpara>If you add a language name like we did there with <emphasis>java</emphasis>, GitHub tries to syntax highlight the snippet.
In the case of the above example, it would end up rendering like <xref linkend="_md_code"/>.</simpara>
<figure xml:id="_md_code">
<title>Rendered fenced code example.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/markdown-04-fenced-code.png"/>
</imageobject>
<textobject><phrase>Rendered fenced code</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_quoting">
<title>Quoting</title>
<simpara>If you&#8217;re responding to a small part of a long comment, you can selectively quote from the
other comment by preceding the quoted lines with the <literal>&gt;</literal> character. In fact, this is so common
and so useful that there&#8217;s a keyboard shortcut for it. If you highlight text in a comment that
you want to directly reply to and hit the <literal>r</literal> key, you see the quoted text in the comment box.</simpara>
<simpara>The quotes look something like</simpara>
<programlisting language="text" linenumbering="unnumbered">&gt; Whether 'tis Nobler in the mind to suffer
&gt; The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?</programlisting>
<simpara>Once rendered, the comment looks like <xref linkend="_md_quote"/>.</simpara>
<figure xml:id="_md_quote">
<title>Rendered quoting example.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/markdown-05-quote.png"/>
</imageobject>
<textobject><phrase>Rendered quoting</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_emoji">
<title>Emoji</title>
<simpara>Finally, you can also use emoji in your comments. This is actually used quite extensively in
the comments you see in many GitHub Pull Requests. There&#8217;s even an emoji helper in GitHub.
If you&#8217;re typing a comment and you start with a <literal>:</literal> character, an autocompleter helps you find
what you&#8217;re looking for.</simpara>
<figure xml:id="_md_emoji_auto">
<title>Emoji autocompleter in action.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/markdown-06-emoji-complete.png"/>
</imageobject>
<textobject><phrase>Emoji autocompleter</phrase></textobject>
</mediaobject>
</figure>
<simpara>Emojis take the form of <literal>:&lt;name&gt;:</literal> anywhere in the comment. For instance, you could write something like</simpara>
<programlisting language="text" linenumbering="unnumbered">I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:</programlisting>
<simpara>When rendered, it would look something like <xref linkend="_md_emoji"/>.</simpara>
<figure xml:id="_md_emoji">
<title>Heavy emoji commenting.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/markdown-07-emoji.png"/>
</imageobject>
<textobject><phrase>Emoji</phrase></textobject>
</mediaobject>
</figure>
<simpara>Not that this is incredibly useful, but it does add an element of fun to an otherwise sterile medium.</simpara>
<note>
<simpara>There are actually quite a number of web services that make use of emoji characters these days.
A great cheat sheet to reference to find emoji that expresses what you want to say can be found at</simpara>
<simpara><link xl:href="http://www.emoji-cheat-sheet.com">http://www.emoji-cheat-sheet.com</link></simpara>
</note>
</section>
<section xml:id="_images">
<title>Images</title>
<simpara>This isn&#8217;t technically GitHub Flavored Markdown, but it&#8217;s incredibly useful. In addition to adding
Markdown image links to comments, which can be difficult to find and embed URLs in,
GitHub allows you to drag and drop images into text areas to embed the images.</simpara>
<figure xml:id="_md_drag">
<title>Drag and drop images to upload them and auto-embed them.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/markdown-08-drag-drop.png"/>
</imageobject>
<textobject><phrase>Drag and drop images</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you look back at <xref linkend="_md_drag"/>, you see a small <literal>Parsed as Markdown</literal> hint above the text area.
Clicking on that shows a full cheat sheet of everything you can do with GitHub Flavored Markdown.</simpara>
</section>
</section>
</section>
<section xml:id="_maintaining_gh_project">
<title>Maintaining a Project</title>
<simpara>Now that we&#8217;re comfortable contributing to a project, let&#8217;s look at creating, maintaining,
and administering a project.</simpara>
<section xml:id="_creating_a_new_repository">
<title>Creating a New Repository</title>
<simpara>Let&#8217;s create a new repository to contain our shared project.
Start by clicking the <literal>New repository</literal> button on the right-hand side of the dashboard,
or from the <literal>+</literal> button in the top toolbar next to your username, as seen in <xref linkend="_new_repo_dropdown"/></simpara>
<figure>
<title>The <literal>Your repositories</literal> area.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/newrepo.png"/>
</imageobject>
<textobject><phrase>The `Your repositories` area.</phrase></textobject>
</mediaobject>
</figure>
<figure xml:id="_new_repo_dropdown">
<title>The <literal>New repository</literal> dropdown.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/new-repo.png"/>
</imageobject>
<textobject><phrase>The `new repository` dropdown.</phrase></textobject>
</mediaobject>
</figure>
<simpara>This takes you to the <literal>new repository</literal> form:</simpara>
<figure>
<title>The <literal>new repository</literal> form.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/newrepoform.png"/>
</imageobject>
<textobject><phrase>The `new repository` form.</phrase></textobject>
</mediaobject>
</figure>
<simpara>All you really have to do here is provide a repository name. The rest of the fields are optional.
For now, just click the <literal>Create repository</literal> button, and boom&#8201;&#8212;&#8201;you have a new repository on GitHub,
named <literal>&lt;user&gt;/&lt;project_name&gt;</literal>.</simpara>
<simpara>Since your repository is empty, GitHub shows instructions for how to create a brand-new Git repository, or how to connect to an existing Git project.
We don&#8217;t belabor this here. If you need a refresher, check out <xref linkend="ch02-git-basics-chapter"/>.</simpara>
<simpara>Now that your project is hosted on GitHub, you can give the URL to anyone you want to share your project with.
Every project on GitHub is accessible over HTTPS as <literal>https://github.com/&lt;user&gt;/&lt;project_name&gt;</literal> and over SSH
as <literal>git@github.com:&lt;user&gt;/&lt;project_name&gt;</literal>.
Git can fetch from and push to both of these URLs, but it controls access based on the credentials of the
user making the connection.</simpara>
<note>
<simpara>It&#8217;s often preferable to share the HTTPS-based URL for a public project, since the user doesn&#8217;t need
a GitHub account to access it for cloning. Users need an account and an uploaded SSH key to
access your project if you give them the SSH-based URL. The HTTPS-based URL is also exactly the same
URL they would paste into a browser to view the project.</simpara>
</note>
</section>
<section xml:id="_adding_collaborators">
<title>Adding Collaborators</title>
<simpara>If Ben, Jeff, and Louise all have accounts on GitHub, give them push access to your repository
by adding them to your project as <literal>collaborators</literal>. This gives them <literal>push</literal> access, which means they have both
read and write permission.</simpara>
<simpara>Click the <literal>Settings</literal> link at the bottom of the right-hand sidebar.</simpara>
<figure>
<title>The repository settings link.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/reposettingslink.png"/>
</imageobject>
<textobject><phrase>The repository settings link.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Select <literal>Collaborators</literal> from the menu on the left-hand side.
Then, just enter a username into the box, and click <literal>Add collaborator</literal>.
Repeat this as many times as necessary to grant access to everyone you&#8217;re working with.
To revoke access, just click the <literal>X</literal> on the right-hand side of a collaborator&#8217;s row.</simpara>
<figure>
<title>Repository collaborators.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/collaborators.png"/>
</imageobject>
<textobject><phrase>The repository collaborators box.</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_managing_pull_requests">
<title>Managing Pull Requests</title>
<simpara>Now that you have a project with some code in it and maybe even a few collaborators who also have push access,
let&#8217;s go over what to do when you get a Pull Request.</simpara>
<simpara>Pull Requests can either come from a branch in a fork of your repository or they can come from another
branch in the same repository. The only difference is that the ones from a fork are often from people
whose branch you can&#8217;t push to, and who can&#8217;t push to yours. With internal Pull Requests generally
both parties have push and pull access to the branch.</simpara>
<simpara>For these examples, let&#8217;s assume you&#8217;re <literal>tonychacon</literal> and you&#8217;ve created a new Arduino
code project named <literal>fade</literal>.</simpara>
<section xml:id="_email_notifications">
<title>Email Notifications</title>
<simpara>Someone comes along and makes a change to your code and sends a Pull Request. You should get an
email notification that looks something like <xref linkend="_email_pr"/>.</simpara>
<figure xml:id="_email_pr">
<title>Email notification of a new Pull Request.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/maint-01-email.png"/>
</imageobject>
<textobject><phrase>Pull Request email notification</phrase></textobject>
</mediaobject>
</figure>
<simpara>There are a few things to notice about this email message. It gives a small diffstat&#8201;&#8212;&#8201;a list of
files that have changed in the Pull Request and by how much. It also gives a link to the Pull Request
on GitHub and a few URLs to use from the command line.</simpara>
<simpara>Notice the line that says <literal>git pull &lt;url&gt; patch-1</literal>. This is a simple way to merge a remote
branch without having to add a remote. We went over this quickly in <xref linkend="_checking_out_remotes"/>.
You can create and switch to a topic branch and then run this command to merge the Pull Request.</simpara>
<simpara>The other interesting URLs are the <literal>.diff</literal> and <literal>.patch</literal> URLs, which, as you may guess,
provide unified diff and patch versions of the Pull Request.
You could technically merge the Pull Request by running something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ curl http://github.com/tonychacon/fade/pull/1.patch | git am</programlisting>
</section>
<section xml:id="_collaborating_on_the_pull_request">
<title>Collaborating on the Pull Request</title>
<simpara>As we covered in <xref linkend="ch06-github_flow"/>, you can now have a conversation with the person
who opened the Pull Request. You can comment on specific lines of code, comment on whole commits,
or comment on the entire Pull Request itself, using GitHub Flavored Markdown.</simpara>
<simpara>Every time someone comments on the Pull Request you continue to get email notifications so you know there&#8217;s
activity. They each have a link to the Pull Request where the activity is happening.
You can also directly respond to the email to comment on the Pull Request thread.</simpara>
<figure>
<title>Responses to emails are included in the thread.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/maint-03-email-resp.png"/>
</imageobject>
<textobject><phrase>Email response</phrase></textobject>
</mediaobject>
</figure>
<simpara>Once the code is the way you like and you want to merge it in, either pull the code and merge it locally,
either with the <literal>git pull &lt;url&gt; &lt;branch&gt;</literal> syntax we saw earlier, or by adding the fork as a remote,
then fetching and merging.</simpara>
<simpara>If the merge is trivial, you can also just click the <literal>Merge</literal> button on the GitHub site.
This does a <literal>non-fast-forward</literal> merge, creating a merge commit even if a fast-forward merge was possible.
Remember, every time you click the <literal>Merge</literal> button, a merge commit is created. As you see in <xref linkend="_merge_button"/>,
GitHub shows all of this information when you click the <literal>Hint</literal> link.</simpara>
<figure xml:id="_merge_button">
<title>Merge button and instructions for merging a Pull Request manually.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/maint-02-merge.png"/>
</imageobject>
<textobject><phrase>Merge button</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you decide you don&#8217;t want to merge the Pull Request, just close it and the person who opened it is notified.</simpara>
<note>
<simpara>I (JF) am not sure the following section will make sense to most readers new to Git.
I&#8217;m leaving it in the book in case I&#8217;m wrong. I welcome your opinion.</simpara>
</note>
</section>
<section xml:id="_pr_refs">
<title>Pull Request Refs</title>
<simpara>If you&#8217;re dealing with a <emphasis role="strong">lot</emphasis> of Pull Requests and don&#8217;t want to add a bunch of remotes or
do a lot of one time pulls, there&#8217;s a neat trick that GitHub allows. This is a bit advanced and
we go over the details of this a bit more in <xref linkend="_refspec"/>, but it can be pretty useful.</simpara>
<simpara>GitHub actually advertises the Pull Request branches for a repository as sort of pseudo-branches.
By default you don&#8217;t get them when you clone, but they&#8217;re there in an obscured way,
which you can access pretty easily.</simpara>
<simpara>To demonstrate this, we use a low-level Git command (often referred to as a <literal>plumbing</literal> command,
which we read about more in <xref linkend="_plumbing_porcelain"/>) called <literal>git ls-remote</literal>.
This command is generally not used in day-to-day Git operations but it&#8217;s useful to show what
references are present on the server.</simpara>
<simpara>If we run this command against the <literal>blink</literal> repository we were using earlier, we get a list
of all the branches, tags, and other references in the repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git ls-remote https://github.com/schacon/blink
10d539600d86723087810ec636870a504f4fee4d	HEAD
10d539600d86723087810ec636870a504f4fee4d	refs/heads/master
6a83107c62950be9453aac297bb0193fd743cd6e	refs/pull/1/head
afe83c2d1a70674c9505cc1d8b7d380d5e076ed3	refs/pull/1/merge
3c8d735ee16296c242be7a9742ebfbc2665adec1	refs/pull/2/head
15c9f4f80973a2758462ab2066b6ad9fe8dcf03d	refs/pull/2/merge
a5a7751a33b7e86c5e9bb07b26001bb17d775d1a	refs/pull/4/head
31a45fc257e8433c8d8804e3e848cf61c9d3166c	refs/pull/4/merge</programlisting>
<simpara>If the repository is on GitHub and you have any open Pull Requests, those references are prefixed
with <literal>refs/pull/</literal>. They&#8217;re basically branches, but since they&#8217;re not under <literal>refs/heads/</literal> you don&#8217;t
get them normally when you clone or fetch from the server. The process of fetching normally ignores them.</simpara>
<simpara>There are two references per Pull Request. The one ending in <literal>/head</literal> points to exactly the same
commit as the last commit in the Pull Request branch. So if someone opens a Pull Request in our
repository and their branch is named <literal>bug-fix</literal> and it points to commit <literal>a5a775</literal>,
then in <emphasis role="strong">our</emphasis> repository we don&#8217;t have a <literal>bug-fix</literal> branch (since that&#8217;s in their fork),
but we have <literal>pull/&lt;pr#&gt;/head</literal> that points to <literal>a5a775</literal>. This means that we can pretty easily
pull every Pull Request branch in one go without having to add a bunch of remotes.</simpara>
<simpara>Now, you could do something like fetching the reference directly.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch origin refs/pull/958/head
From https://github.com/libgit2/libgit2
 * branch            refs/pull/958/head -&gt; FETCH_HEAD</programlisting>
<simpara>This tells Git to connect to the <literal>origin</literal> remote, and download the ref named <literal>refs/pull/958/head</literal>.
Git happily obeys, and downloads everything you need to construct that ref, and puts a pointer to
the commit you want under <literal>.git/FETCH_HEAD</literal>. You can follow that up by running <literal>git merge FETCH_HEAD</literal> into a
branch you want to test it in, but that merge commit message looks a bit weird.
Also, if you&#8217;re reviewing a <emphasis role="strong">lot</emphasis> of Pull Requests, this gets tedious.</simpara>
<simpara>There&#8217;s also a way to fetch <emphasis>all</emphasis> of the Pull Requests, and keep them up to date whenever you connect
to the remote. Edit <literal>.git/config</literal> and look for the <literal>origin</literal> remote. It should look something like</simpara>
<programlisting language="ini" linenumbering="unnumbered">[remote "origin"]
    url = https://github.com/libgit2/libgit2
    fetch = +refs/heads/*:refs/remotes/origin/*</programlisting>
<simpara>That line that begins with <literal>fetch =</literal> is a <literal>refspec</literal>.
It&#8217;s a way of mapping names on the remote with names in your local repository.
This particular one tells Git "The things on the remote under <literal>refs/heads</literal> should go in my
local repository under <literal>refs/remotes/origin</literal>". You can modify this section to add another refspec.</simpara>
<programlisting language="ini" linenumbering="unnumbered">[remote "origin"]
    url = https://github.com/libgit2/libgit2.git
    fetch = +refs/heads/*:refs/remotes/origin/*
    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*</programlisting>
<simpara>That last line tells Git that all the refs that look like <literal>refs/pull/123/head</literal> should be stored locally
like <literal>refs/remotes/origin/pr/123</literal>.
Now, save that file, and run <literal>git fetch</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch
# …
 * [new ref]         refs/pull/1/head -&gt; origin/pr/1
 * [new ref]         refs/pull/2/head -&gt; origin/pr/2
 * [new ref]         refs/pull/4/head -&gt; origin/pr/4
# …</programlisting>
<simpara>Now all of the remote Pull Requests are represented locally with refs that act much like tracking branches.
They&#8217;re read-only, and they update when you run <literal>git fetch</literal>.
This makes it super easy to try the code from a Pull Request locally.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout pr/2
Checking out files: 100% (3769/3769), done.
Branch pr/2 set up to track remote branch pr/2 from origin.
Switched to a new branch 'pr/2'</programlisting>
<simpara>The eagle-eyed among you would note the <literal>head</literal> on the end of the remote portion of the refspec.
There&#8217;s also a <literal>refs/pull/#/merge</literal> ref on the GitHub side, which represents the commit that would
result if you click the <literal>Merge</literal> button on the site. This allows testing the merge before even
clicking the button.</simpara>
</section>
<section xml:id="_pull_requests_on_pull_requests">
<title>Pull Requests on Pull Requests</title>
<simpara>Not only can you open Pull Requests that target <literal>master</literal>. In fact, you can even target another Pull Request.</simpara>
<simpara>If you see a Pull Request that&#8217;s moving in the right direction and you have an idea for a change
that depends on it, or you&#8217;re not sure it&#8217;s a good idea, or you just don&#8217;t have push access to the
target branch, you can open a Pull Request directly to it.</simpara>
<simpara>When you go to open a Pull Request, there&#8217;s a box at the top of the page that specifies which branch</simpara>
<simpara>you&#8217;re requesting to push to and which you&#8217;re requesting to pull from. Click the <literal>Edit</literal> button at the
right of that box to change not only the branches but also the target fork.</simpara>
<figure xml:id="_pr_targets">
<title>Manually change the Pull Request target fork and branch.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/maint-04-target.png"/>
</imageobject>
<textobject><phrase>PR targets</phrase></textobject>
</mediaobject>
</figure>
<simpara>Here specify merging your new branch into another Pull Request or another fork of the project.</simpara>
</section>
</section>
<section xml:id="_mentions_and_notifications">
<title>Mentions and Notifications</title>
<simpara>GitHub also has a pretty nice built-in notification system that can come in handy when you have
questions or need feedback.</simpara>
<simpara>In any comment if you start typing an <literal>@</literal> character the form begins to autocomplete with the names
and usernames of collaborators or contributors to the project.</simpara>
<figure>
<title>Start typing @ to mention someone.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/maint-05-mentions.png"/>
</imageobject>
<textobject><phrase>Mentions</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can also mention a user who isn&#8217;t in that dropdown.</simpara>
<simpara>When you post a comment mentioning a user, that user is notified. This means that this can be an
effective way of pulling people into conversations rather than forcing them to check back often.
Very often people pull in others to review a Pull Request.</simpara>
<simpara>If someone gets mentioned in a Pull Request, they&#8217;re <literal>subscribed</literal> to it and continue getting
notifications any time activity occurs in it. You&#8217;re subscribed if you opened the Pull Request, if you&#8217;re
watching the repository, or if you comment on something. If you no longer wish to receive notifications,
there&#8217;s an <literal>Unsubscribe</literal> button on the page you can click to stop receiving updates.</simpara>
<figure>
<title>Unsubscribe from an Issue or Pull Request.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/maint-06-unsubscribe.png"/>
</imageobject>
<textobject><phrase>Unsubscribe</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_the_notifications_page">
<title>The Notifications Page</title>
<simpara>When we mention <literal>notifications</literal> here, we mean a specific way that GitHub tries to get in touch
with you when something happens. There are several ways to configure notifications.
If you go to the <literal>Notification center</literal> tab from the settings page, you see some of the available options.</simpara>
<figure>
<title>Notification center options.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/maint-07-notifications.png"/>
</imageobject>
<textobject><phrase>Notification center</phrase></textobject>
</mediaobject>
</figure>
<simpara>The two choices are to get notifications over <literal>Email</literal> and over the <literal>Web</literal>.
You can choose either, neither, or both.</simpara>
<section xml:id="_web_notifications">
<title>Web Notifications</title>
<simpara>Web notifications only exist on GitHub, which is the only place you can check them.
If you select this option in your preferences and a notification is triggered for you,
you see a small blue dot over the notifications icon at the top of the page, as seen in <xref linkend="_not_center"/>.</simpara>
<figure xml:id="_not_center">
<title>Notification center.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/maint-08-notifications-page.png"/>
</imageobject>
<textobject><phrase>Notification center</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you click the <literal>Notifications</literal> icon, you see a list of all the items you have been notified about,
grouped by project. You can filter by a specific project by clicking on its name in the left hand sidebar.
You can also acknowledge the notification by clicking the <literal>Checkmark</literal> icon next to any notification,
or acknowledge <emphasis>all</emphasis> of the notifications in a project by clicking the <literal>Checkmark</literal> icon at the top of the
group. There&#8217;s also a mute button next to each checkmark that you can click to stop receiving any
further notifications on that item.</simpara>
<simpara>All of these tools are very useful for handling large numbers of notifications.
Many GitHub power users simply turn off email notifications entirely and manage all of their
notifications through this page.</simpara>
</section>
<section xml:id="_email_notifications_2">
<title>Email Notifications</title>
<simpara>Email notifications are the other way to handle notifications from GitHub.
If you have this turned on you get email for each notification. We saw examples of this
in <xref linkend="_email_notification"/> and <xref linkend="_email_pr"/>. The email also is threaded properly,
which is nice if you&#8217;re using a threaded email client.</simpara>
<simpara>There&#8217;s also a fair amount of metadata embedded in the headers of the email GitHub sends,
which can be really helpful for setting up custom filters and rules.</simpara>
<simpara>For instance, if we look at the actual email headers sent to Tony in the email shown in <xref linkend="_email_pr"/>, we see</simpara>
<programlisting language="mbox" linenumbering="unnumbered">To: tonychacon/fade &lt;fade@noreply.github.com&gt;
Message-ID: &lt;tonychacon/fade/pull/1@github.com&gt;
Subject: [fade] Wait longer to see the dimming effect better (#1)
X-GitHub-Recipient: tonychacon
List-ID: tonychacon/fade &lt;fade.tonychacon.github.com&gt;
List-Archive: https://github.com/tonychacon/fade
List-Post: &lt;mailto:reply+i-4XXX@reply.github.com&gt;
List-Unsubscribe: &lt;mailto:unsub+i-XXX@reply.github.com&gt;,...
X-GitHub-Recipient-Address: tchacon@example.com</programlisting>
<simpara>There are a couple of interesting things here. To highlight or re-route email to this particular
project or even this Pull Request, the information in <literal>Message-ID</literal> gives all the data
in <literal>&lt;user&gt;/&lt;project&gt;/&lt;type&gt;/&lt;id&gt;</literal> format.</simpara>
<simpara>The <literal>List-Post</literal> and <literal>List-Unsubscribe</literal> fields mean that if you have an email client that understands
them, you can easily post to the list or <literal>Unsubscribe</literal> from the thread. That would be essentially
the same as clicking the <literal>Mute</literal> button on the web version of the notification or <literal>Unsubscribe</literal> on the
Pull Request page itself.</simpara>
<simpara>It&#8217;s also worth noting that if you have both email and web notifications enabled, and you read
the email version of the notification, the web version also is marked as read
if your email client can display images.</simpara>
</section>
</section>
</section>
<section xml:id="_special_files">
<title>Special Files</title>
<simpara>There are a couple of special files that GitHub notices if they&#8217;re present in your repository.</simpara>
</section>
<section xml:id="_readme">
<title>README</title>
<simpara>The first is <literal>README</literal>, which can be in nearly any format that GitHub recognizes as prose.
For example, it could be <literal>README</literal>, <literal>README.md</literal>, <literal>README.asciidoc</literal>, etc. If GitHub sees a <literal>README</literal>
file in your top level directory, GitHub renders it on the landing page of the project.</simpara>
<simpara>Many teams use this file to hold relevant project information for someone who might be new to the project.
This generally includes things like</simpara>
<itemizedlist>
<listitem>
<simpara>What the project is for</simpara>
</listitem>
<listitem>
<simpara>How to configure and install it</simpara>
</listitem>
<listitem>
<simpara>An example of how to use it or get it running</simpara>
</listitem>
<listitem>
<simpara>The license that the project is offered under</simpara>
</listitem>
<listitem>
<simpara>How to contribute to it</simpara>
</listitem>
</itemizedlist>
<simpara>Since GitHub renders this file, you can embed images or links in it.</simpara>
</section>
<section xml:id="_contributing">
<title>CONTRIBUTING</title>
<simpara>The other special file that GitHub recognizes is <literal>CONTRIBUTING</literal>.
If you have a file named <literal>CONTRIBUTING</literal>, with any file extension, GitHub shows this when
anyone starts creating a Pull Request.</simpara>
<figure xml:id="_contrib_file">
<title>Opening a Pull Request when a CONTRIBUTING file exists.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/maint-09-contrib.png"/>
</imageobject>
<textobject><phrase>Contributing notice</phrase></textobject>
</mediaobject>
</figure>
<simpara>The idea here is that you specify specific things in a CONTRIBUTING file you do or don&#8217;t want in a
Pull Request sent to your project. This way people may actually read the guidelines before creating
the Pull Request.</simpara>
</section>
<section xml:id="_project_administration">
<title>Project Administration</title>
<simpara>Generally there aren&#8217;t many administrative things you can do in a single project,
but there are a couple of items that might be of interest.</simpara>
<section xml:id="_changing_the_default_branch">
<title>Changing the Default Branch</title>
<simpara>If you&#8217;re using a default branch other than <literal>master</literal> for people to create Pull Requests on or see by default,
you can change the default branch in your repository&#8217;s settings page under the <literal>Options</literal> tab.</simpara>
<figure xml:id="_default_branch">
<title>Change the default branch for a project.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/maint-10-default-branch.png"/>
</imageobject>
<textobject><phrase>Default branch</phrase></textobject>
</mediaobject>
</figure>
<simpara>Simply change the default branch in the dropdown and then that&#8217;s the default branch for all major operations,
including which branch is checked out when someone clones the repository.</simpara>
</section>
<section xml:id="_transferring_a_project">
<title>Transferring a Project</title>
<simpara>To transfer a project to another user or organization at GitHub, there&#8217;s a <literal>Transfer ownership</literal> option
at the bottom of the same <literal>Options</literal> tab of your repository settings page.</simpara>
<figure xml:id="_transfer_project">
<title>Transfer a project to another GitHub user or Organization.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/maint-11-transfer.png"/>
</imageobject>
<textobject><phrase>Transfer</phrase></textobject>
</mediaobject>
</figure>
<simpara>This is helpful if you&#8217;re abandoning a project and want to give ownership away.</simpara>
<simpara>Not only does this move the repository, along with all its watchers, to another place,
it also sets up a redirect from your URL to the new location. It also redirect clones and fetches from Git,
not just web requests.</simpara>
</section>
</section>
</section>
<section xml:id="ch06-github_orgs">
<title>Managing an organization</title>
<simpara><indexterm>
<primary>GitHub</primary><secondary>organizations</secondary>
</indexterm>
<indexterm>
<primary>organizations</primary>
</indexterm>
In addition to single-user accounts, GitHub has what are called Organization accounts.
Like personal accounts, Organization accounts are a place where all an organization&#8217;s projects are stored.
However many other things are different in Organization accounts, which are used by a group of people with shared
project ownership. Normally these accounts are used for open source projects (such as <literal>perl</literal> or <literal>rails</literal>)
or companies (such as <literal>google</literal> or <literal>twitter</literal>).</simpara>
<section xml:id="_organization_basics">
<title>Organization Basics</title>
<simpara>An organization is easy to create. Just click the <literal>+</literal> icon at the top-right of any GitHub page,
and select <literal>New organization</literal> from the menu.</simpara>
<figure>
<title>The &#8220;New organization&#8221; menu item.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/neworg.png"/>
</imageobject>
<textobject><phrase>The ``New organization'' menu item.</phrase></textobject>
</mediaobject>
</figure>
<simpara>First, name your organization and provide an email address for a main point of contact.
Then invite other users to be members of the organization.</simpara>
<simpara>Follow these steps and you&#8217;re soon the owner of a brand-new organization.
Like personal accounts, organizations are free if everything you plan to do there is public.</simpara>
<simpara>As a member of an organization, when you fork a repository, you have the choice of forking
it to your organization&#8217;s storage area. When you create new repositories you can create them either
under your personal account or under any of the organization accounts that you&#8217;re a member of.
You also automatically watch any new repository created by these organizations.</simpara>
<simpara>Just like in <xref linkend="_personal_avatar"/>, you can upload an avatar for your organization to personalize it.
Also, just like personal accounts, you have a publically viewable landing page for the
organization that lists all of its repositories.</simpara>
<simpara>Now let&#8217;s cover some of the things that are different with an organization account.</simpara>
</section>
<section xml:id="_teams">
<title>Teams</title>
<simpara>An organization consists of user accounts. Each user in an organization can be a member of one or more teams.
A team is simply a grouping of individual organization user accounts and can be given specific access
permissions for the  organization&#8217;s repositories.</simpara>
<simpara>For example, say your company has three repositories: <literal>frontend</literal>, <literal>backend</literal>, and <literal>deployscripts</literal>.
You&#8217;d want your HTML/CSS/JavaScript developers to have access to <literal>frontend</literal> and maybe <literal>backend</literal>,
and your Operations people to have access to <literal>backend</literal> and <literal>deployscripts</literal>.
Teams make this easy, without having to manage access for each individual team member for every repository.</simpara>
<simpara>The Organization page shows a simple dashboard of all its repositories, users, and teams.</simpara>
<figure xml:id="_org_page">
<title>The Organization page.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/orgs-01-page.png"/>
</imageobject>
<textobject><phrase>orgs 01 page</phrase></textobject>
</mediaobject>
</figure>
<simpara>To manage your teams, click the Teams sidebar on the right hand side of the page in <xref linkend="_org_page"/>.
This brings you to a page for adding members to the team, adding repositories to the team,
or managing the settings and access control levels for the team. Each team can have read only,
read/write, or administrative access to the repositories. You can change the access by clicking
the <literal>Settings</literal> button in <xref linkend="_team_page"/>.</simpara>
<figure xml:id="_team_page">
<title>The Team page.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/orgs-02-teams.png"/>
</imageobject>
<textobject><phrase>orgs 02 teams</phrase></textobject>
</mediaobject>
</figure>
<simpara>When you invite someone to join a team, they get an email message letting them know they&#8217;ve been invited.</simpara>
<simpara>Additionally, team <literal>@mentions</literal> (such as <literal>@acmecorp/frontend</literal>) work much the same as they do with
individual users, except that <emphasis role="strong">all</emphasis> members of the team are then subscribed to the thread.
This is useful if you want the attention of someone on a team, but you don&#8217;t know exactly who.</simpara>
<simpara>A user can belong to any number of teams, so don&#8217;t limit yourself to only access-control teams.
Special-interest teams like <literal>ux</literal>, <literal>css</literal>, or <literal>refactoring</literal> are useful for certain kinds of questions,
and others like <literal>legal</literal> and <literal>colorblind</literal> for others.</simpara>
</section>
<section xml:id="_audit_log">
<title>Audit Log</title>
<simpara>Organizations also give members access to all the information about what has gone on in the organization.
Go to the <literal>Audit log</literal> tab to see what events have happened at an organization level, who did them,
and where in the world they were done.</simpara>
<figure xml:id="_the_audit_log">
<title>The Audit log.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/orgs-03-audit.png"/>
</imageobject>
<textobject><phrase>orgs 03 audit</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can also filter down to specific types of events, places, or people.</simpara>
</section>
</section>
<section xml:id="_scripting_github">
<title>Scripting GitHub</title>
<simpara>We&#8217;ve covered all of the major features and workflows of GitHub, but any large group or project
has their own customizations to make or external services to integrate.</simpara>
<simpara>Luckily for us, GitHub is really quite scriptable. In this section we cover how to use the
GitHub webhooks system and its API to make GitHub work the way we want.</simpara>
<section xml:id="_webhooks_and_services">
<title>Webhooks and Services</title>
<simpara>Webhooks and Services are the easiest ways for GitHub to interact with external systems.</simpara>
<section xml:id="_services">
<title>Services</title>
<simpara>First we take a look at Services. Both the Webhooks and Services integrations can be found in the
Settings section of your repository, where we previously looked to add Collaborators and to change
the default branch of your project. Under the <literal>Webhooks and Services</literal> tab you see <xref linkend="_services_hooks"/></simpara>
<figure xml:id="_services_hooks">
<title>Services and Webhooks configuration section.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/scripting-01-services.png"/>
</imageobject>
<textobject><phrase>Services and hooks</phrase></textobject>
</mediaobject>
</figure>
<simpara>There are dozens of services to choose from, most of them integrations into other commercial and open
source systems. Most are for continuous integration services, bug and issue trackers, chat rooms,
and documentation generators. We walk through setting up a very simple one, the Email webhook.</simpara>
<simpara>If you choose <literal>email</literal> from the <literal>Add Service</literal> dropdown, you get a configuration page like <xref linkend="_service_config"/>.</simpara>
<figure xml:id="_service_config">
<title>Email service configuration.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/scripting-02-email-service.png"/>
</imageobject>
<textobject><phrase>Email service</phrase></textobject>
</mediaobject>
</figure>
<simpara>In this case, if we click <literal>Add service</literal>, the email address we specify gets an email message every time
someone pushes to the repository. Services can listen for lots of different types of events,
but most only listen for push events and then respond appropriately.</simpara>
<simpara>If there&#8217;s a system you&#8217;re using that you&#8217;d like to integrate with GitHub, check here to see
if there&#8217;s an existing service integration available. For example, if you&#8217;re using Jenkins to
run tests on your codebase, enable the Jenkins builtin service integration to kick off a
test run every time someone pushes to your repository.</simpara>
</section>
<section xml:id="_webhooks">
<title>Webhooks</title>
<simpara>For something more specific or to integrate with a service that isn&#8217;t included in this list,
instead use the more generic webhooks system. GitHub repository webhooks are pretty simple.
Specify a URL and GitHub posts an HTTP payload to that URL whenever any event you select occurs.</simpara>
<simpara>Generally the way this works is that you create a small web service to receive a GitHub webhook
payload and then have the service do something with the data in the payload.</simpara>
<simpara>To enable a webhook, click the <literal>Add webhook</literal> button in <xref linkend="_services_hooks"/>.
This shows a page that looks like <xref linkend="_webhook"/>.</simpara>
<figure xml:id="_webhook">
<title>Webhook configuration.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/scripting-03-webhook.png"/>
</imageobject>
<textobject><phrase>Web hook</phrase></textobject>
</mediaobject>
</figure>
<simpara>The configuration for a webhook is pretty simple. In most cases simply enter a URL and a secret key,
and click <literal>Add webhook</literal>. There are a few options for the events you want GitHub to send you a payload
for. The default is to only get a payload for the <literal>push</literal> event, when someone pushes new code to
your repository.</simpara>
<simpara>Let&#8217;s see a small example of a web service that can handle a webhook. We use the Sinatra Ruby web
framework since it&#8217;s fairly concise and you should be able to easily see what we&#8217;re doing.</simpara>
<simpara>Let&#8217;s say we want to get an email message if a specific person pushes to a specific branch of our
project when modifying a specific file. We could fairly easily do that with code like</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'sinatra'
require 'json'
require 'mail'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON

  # gather the data we're looking for
  pusher = push["pusher"]["name"]
  branch = push["ref"]

  # get a list of all the files touched
  files = push["commits"].map do |commit|
    commit['added'] + commit['modified'] + commit['removed']
  end
  files = files.flatten.uniq

  # check for our criteria
  if pusher == 'schacon' &amp;&amp;
     branch == 'ref/heads/special-branch' &amp;&amp;
     files.include?('special-file.txt')

    Mail.deliver do
      from     'tchacon@example.com'
      to       'tchacon@example.com'
      subject  'Scott Changed the File'
      body     "ALARM"
    end
  end
end</programlisting>
<simpara>Here we&#8217;re taking the JSON payload that GitHub delivers and looking up who did the push,
what branch they pushed to, and what files were touched in all the commits that were pushed.
Then we check what we found against our criteria and send an email message if anything matches.</simpara>
<simpara>In order to develop and test something like this, there&#8217;s a nice developer console on the same
page where you set up the webhook. You can see the last few deliveries that GitHub tried to make.
For each webhook you can dig down into when it was delivered, if it was successful, and the
body and headers for both the request and the response. This makes it incredibly easy to test
and debug your webhooks.</simpara>
<figure xml:id="_web_hook_debug">
<title>Web hook debugging information.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/scripting-04-webhook-debug.png"/>
</imageobject>
<textobject><phrase>Webhook debug</phrase></textobject>
</mediaobject>
</figure>
<simpara>Another great feature is that you can redeliver any of the payloads.</simpara>
<simpara>For more information on how to write webhooks and all the event types you can listen for,
go to the GitHub Developer documentation at <link xl:href="https://developer.github.com/webhooks/">https://developer.github.com/webhooks/</link></simpara>
</section>
</section>
<section xml:id="_the_github_api">
<title>The GitHub API</title>
<simpara><indexterm>
<primary>GitHub</primary><secondary>API</secondary>
</indexterm>
<indexterm>
<primary>API</primary>
</indexterm>
Services and webhooks provide a way to receive push notifications about events that happen in your
repositories, but what if you need more information? What if you need to automate something
like adding collaborators or labeling issues?</simpara>
<simpara>This is where the GitHub API comes in handy. GitHub has tons of API endpoints for doing nearly
anything you can do on the website in an automated fashion. In this section we learn how
to authenticate and connect to the API, how to comment on an issue, and how to change the status of a
Pull Request through the API.</simpara>
</section>
<section xml:id="_basic_usage_2">
<title>Basic Usage</title>
<simpara>The most basic thing you can do is a simple HTTP GET request on an endpoint that doesn&#8217;t require
authentication. This could get information about a user or an open source project.
For example, to find out more about a user named <literal>schacon</literal>, run</simpara>
<programlisting language="javascript" linenumbering="unnumbered">$ curl https://api.github.com/users/schacon
{
  "login": "schacon",
  "id": 70,
  "avatar_url": "https://avatars.githubusercontent.com/u/70",
# …
  "name": "Scott Chacon",
  "company": "GitHub",
  "following": 19,
  "created_at": "2008-01-27T17:19:28Z",
  "updated_at": "2014-06-10T02:37:23Z"
}</programlisting>
<simpara>There are tons of endpoints like this to get information about organizations, projects, issues, and
commits&#8201;&#8212;&#8201;just about anything you can publicly see on GitHub. You can even use the API to
render arbitrary Markdown or find a <literal>.gitignore</literal> template.</simpara>
<programlisting language="javascript" linenumbering="unnumbered">$ curl https://api.github.com/gitignore/templates/Java
{
  "name": "Java",
  "source": "*.class

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.ear

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
"
}</programlisting>
</section>
<section xml:id="_commenting_on_an_issue">
<title>Commenting on an Issue</title>
<simpara>However, to perform an action on the website such as commenting on an Issue or Pull Request,
or if you want to view or interact with private content, you need to authenticate.</simpara>
<simpara>There are several ways to authenticate. You can use basic authentication with just your username and password,
but generally it&#8217;s a better idea to use a personal access token.
You can generate this from the <literal>Applications</literal> tab of your settings page.</simpara>
<figure xml:id="_access_token">
<title>Generate your access token from the &#8220;Applications&#8221; tab of your settings page.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/scripting-05-access-token.png"/>
</imageobject>
<textobject><phrase>Access Token</phrase></textobject>
</mediaobject>
</figure>
<simpara>It asks how you want to limit how this token is used. Make sure to use a good description so you feel
comfortable removing the token when your script or application is no longer used.</simpara>
<simpara>GitHub only shows the token once, so be sure to copy it somewhere. You can now use the token
in a script to authenticate instead of using a username and password.
This is nice because the token is revocable.</simpara>
<simpara>This also has the added advantage of increasing your rate limit. Without authenticating,
you&#8217;re limited to 60 requests per hour. If you authenticate, you can make up to 5,000 requests per hour.</simpara>
<simpara>So let&#8217;s use it to make a comment on one of our issues. Let&#8217;s say we want to leave a comment on a
specific issue, Issue #6. To do so we have to send an HTTP POST request
to <literal>repos/&lt;user&gt;/&lt;repo&gt;/issues/&lt;num&gt;/comments</literal> with the token we just generated in an Authorization header.</simpara>
<programlisting language="javascript" linenumbering="unnumbered">$ curl -H "Content-Type: application/json" \
       -H "Authorization: token TOKEN" \
       --data '{"body":"A new comment, :+1:"}' \
       https://api.github.com/repos/schacon/blink/issues/6/comments
{
  "id": 58322100,
  "html_url": "https://github.com/schacon/blink/issues/6#issuecomment-58322100",
  ...
  "user": {
    "login": "tonychacon",
    "id": 7874698,
    "avatar_url": "https://avatars.githubusercontent.com/u/7874698?v=2",
    "type": "User",
  },
  "created_at": "2014-10-08T07:48:19Z",
  "updated_at": "2014-10-08T07:48:19Z",
  "body": "A new comment, :+1:"
}</programlisting>
<simpara>Now if you go to that issue, you see the comment that we just successfully posted as in <xref linkend="_api_comment"/>.</simpara>
<figure xml:id="_api_comment">
<title>A comment posted from the GitHub API.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/scripting-06-comment.png"/>
</imageobject>
<textobject><phrase>API Comment</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can use the API to do just about anything you can do on the website&#8201;&#8212;&#8201;creating and setting milestones,
assigning people to Issues and Pull Requests, creating and changing labels, accessing commit data,
creating new commits and branches, opening, closing or merging Pull Requests, creating and editing teams,
commenting on lines of code in a Pull Request, searching the site, and on and on.</simpara>
</section>
<section xml:id="_changing_the_status_of_a_pull_request">
<title>Changing the Status of a Pull Request</title>
<simpara>Our final example is how to change the status of a Pull Request. Each commit can have one or more
statuses associated with it. There&#8217;s an API to add and query that status.</simpara>
<simpara>Most of the continuous integration and testing services make use of this API to react to pushes
by testing the code that was pushed, and then report back if the code has passed all the tests.
You could also use this to check if the commit message is properly formatted, if the submitter
followed all your contribution guidelines, if the commit has a valid signature, and any number of other things.</simpara>
<simpara>Let&#8217;s say you set up a webhook on your repository that hits a small web service that checks for
a <literal>Signed-off-by</literal> string in the commit message.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">require 'httparty'
require 'sinatra'
require 'json'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON
  repo_name = push['repository']['full_name']

  # look through each commit message
  push["commits"].each do |commit|

    # look for a Signed-off-by string
    if /Signed-off-by/.match commit['message']
      state = 'success'
      description = 'Successfully signed off!'
    else
      state = 'failure'
      description = 'No signoff found.'
    end

    # post status to GitHub
    sha = commit["id"]
    status_url = "https://api.github.com/repos/#{repo_name}/statuses/#{sha}"

    status = {
      "state"       =&gt; state,
      "description" =&gt; description,
      "target_url"  =&gt; "http://example.com/how-to-signoff",
      "context"     =&gt; "validate/signoff"
    }
    HTTParty.post(status_url,
      :body =&gt; status.to_json,
      :headers =&gt; {
        'Content-Type'  =&gt; 'application/json',
        'User-Agent'    =&gt; 'tonychacon/signoff',
        'Authorization' =&gt; "token #{ENV['TOKEN']}" }
    )
  end
end</programlisting>
<simpara>This should be fairly simple to follow. In this webhook handler we look through each newly pushed commit,
looking for the string <emphasis>Signed-off-by</emphasis> in the commit message. Finally we send a POST to
the <literal>/repos/&lt;user&gt;/&lt;repo&gt;/statuses/&lt;commit_sha&gt;</literal> API endpoint with the status.</simpara>
<simpara>In this case you send a state (<emphasis>success</emphasis>, <emphasis>failure</emphasis>, <emphasis>error</emphasis>), a description of what happened,
a target URL the user can go to for more information, and a <literal>context</literal> in case there are multiple
statuses for a single commit. For example, a testing service or a validation service
may also provide a status&#8201;&#8212;&#8201;the <literal>context</literal> field is how they&#8217;re differentiated.</simpara>
<simpara>If someone opens a new Pull Request on GitHub and this webhook is set up,
you see something like <xref linkend="_commit_status"/></simpara>
<figure xml:id="_commit_status">
<title>Commit status via the API.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/scripting-07-status.png"/>
</imageobject>
<textobject><phrase>Commit status</phrase></textobject>
</mediaobject>
</figure>
<simpara>You now see a little green check mark next to the commit that has a <literal>Signed-off-by</literal> string
in the message and a red cross through the one where the author forgot to sign off.
You also see that the Pull Request takes the status of the last commit on the branch and warns
if it&#8217;s a failure. This is really useful if you&#8217;re using this API for test results so you don&#8217;t
accidentally merge a commit that failed its tests.</simpara>
</section>
<section xml:id="_octokit">
<title>Octokit</title>
<simpara>Although these examples have used <literal>curl</literal> and simple HTTP requests for nearly everything,
several open-source libraries exist that make this API available in a more idiomatic way.
One such example is the Octokit project. At the time of writing, supported languages include Go,
Objective-C, Ruby, and .NET. Check out <link xl:href="http://github.com/octokit">http://github.com/octokit</link> for more information.</simpara>
<simpara>Hopefully these tools help you customize and modify GitHub to work better with your specific workflows.
For complete documentation on the entire API, as well as guides for common tasks,
check out <link xl:href="https://developer.github.com">https://developer.github.com</link>.</simpara>
</section>
</section>
<section xml:id="_summary_7">
<title>Summary</title>
<simpara>Now you&#8217;re a GitHub user.
You know how to create an account, manage an organization, create and push to repositories,
contribute to other people&#8217;s projects, and accept contributions from others.
In the next chapter, you learn more powerful tools and tips for dealing with complex situations,
which truly make you a Git master.</simpara>
</section>
</chapter>
<chapter xml:id="ch07-git-tools">
<title>Git Tools</title>
<simpara>By now, you’ve learned most of the day-to-day commands and workflows that you need to manage a Git repository.
You’ve accomplished the basic tasks of tracking and committing files, and you’ve harnessed the power of
the staging area, lightweight topic branching, and merging.</simpara>
<simpara>Now you explore a number of very powerful things that Git can do that you may not necessarily use on
a day-to-day basis but that you may need at some point.</simpara>
<section xml:id="_revision_selection">
<title>Revision Selection</title>
<simpara>Git allows you to specify a specific commit or a range of commits in several ways.
They aren’t necessarily obvious but are helpful to know.</simpara>
<section xml:id="_single_revisions">
<title>Single Revisions</title>
<simpara>You can obviously refer to a commit by its SHA-1 hash, but there are also more human-friendly ways.
This section presents various examples.</simpara>
</section>
<section xml:id="_short_sha_1">
<title>Short SHA-1</title>
<simpara>Git is smart enough to figure out the commit you&#8217;re referring to if you provide the first
four characters of an SHA-1 hash, as long as these characters are unambiguous&#8201;&#8212;&#8201;that is,
only one thing in your current repository begins with those four characters.</simpara>
<simpara>For example, suppose you run <literal>git log</literal> and find a specific commit you&#8217;re interested in
examining in more detail.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff</programlisting>
<simpara>In this case, let&#8217;s look at <literal>1c002dd...</literal>. The following commands are equivalent (again assuming
the shorter strings are unambiguous):</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d</programlisting>
<simpara>Git can display a short, unique abbreviation for an SHA-1 hash.
If you pass <literal>--abbrev-commit</literal> to <literal>git log</literal>, the output contains unique short SHA-1 hashes
which default to seven characters but can be longer if necessary to be unambiguous.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit</programlisting>
<simpara>Generally, eight to ten characters are more than enough to display a unique SHA-1 hash within a project.</simpara>
<simpara>As an example, the Linux kernel, which is a large project with over 700,000 commits and 6.5 million objects,
contains no two objects whose SHA-1 hashes overlap over more than the first 11 characters.</simpara>
<note>
<title>A Short Note About SHA-1</title>
<simpara>Many people are concerned that at some point, by random happenstance,
multiple objects in their repository might have the same SHA-1 hash. What then?</simpara>
<simpara>If you do try to commit an object that has the same SHA-1 hash as something already
in your repository, Git doesn&#8217;t actually save the new object because it thinks the new and existing
objects are identical, so there would be no point in saving the new object.
If you try to look at an object with that SHA-1 hash later, you always get the content of the original object.</simpara>
<simpara>However, you should be aware of how ridiculously unlikely this scenario is. An SHA-1 hash is 20
bytes or 160 bits. The number of randomly hashed objects needed to ensure a 50% probability
of a single collision is about 2<superscript>80</superscript>
(the formula for determining collision probability is <literal>p = (n(n-1)/2) * (1/2^160))</literal>. 2<superscript>80</superscript>
is 1.2 x 10<superscript>24</superscript>
or 1 million billion billion. That’s 1,200 times the number of grains of sand on Earth.</simpara>
<simpara>Here’s an example to give you an idea of what it would take to get an SHA-1 hash collision.
If all 6.5 billion humans on Earth were programmers, and every second each person produced the same
amount of code that&#8217;s in the entire Linux kernel history (6.5 million Git objects) and pushed it
into one enormous Git repository, it would take roughly 2 years until that repository contained enough
objects to have a 50% probability of a single SHA-1 hash collision.
There&#8217;s a higher probability that every member of your programming team is attacked and killed by
wolves in unrelated incidents during the same night than an SHA-1 collision.</simpara>
</note>
</section>
<section xml:id="_branch_references">
<title>Branch References</title>
<simpara>The easiest way to reference a commit requires that it have a branch reference pointing to it.
Then, you can use a branch name in any Git command that expects an SHA-1 hash.
For instance, to show the last commit on a branch, the following commands are equivalent,
assuming that <literal>topic1</literal> points to <literal>ca82a6d</literal>:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show ca82a6d
$ git show topic1</programlisting>
<simpara>To see the SHA-1 hash a branch points to, use the Git plumbing tool <literal>git rev-parse</literal>.
(See <xref linkend="ch10-git-internals"/> for more information about plumbing tools.)
Basically, <literal>git rev-parse</literal> exists for low-level operations and isn’t designed to be used on the command line.
However, it can sometimes be helpful to see what’s really going on. Here we run <literal>git rev-parse</literal> on a branch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949</programlisting>
</section>
<section xml:id="_git_reflog">
<title>RefLog Shortnames</title>
<simpara>One of the things Git does in the background is keeping a <literal>reflog</literal>&#8201;&#8212;&#8201;a log
of where your <literal>HEAD</literal> and branch references have been for the last few months.</simpara>
<simpara>You can see your reflog by running <literal>git reflog</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD</programlisting>
<simpara>Every time a branch is updated for any reason, Git stores the change in the reflog.
This shows older commits, as well. For example, to see the fifth prior commit in your repository,
use the <literal>@{5}</literal> reference that you see in the reflog output.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show HEAD@{5}</programlisting>
<simpara>Also use this syntax to see where a branch was some specific amount of time ago.
For instance, to see where <literal>master</literal> was yesterday, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show master@{yesterday}</programlisting>
<simpara>This technique only works for data that’s still in your reflog, so you can&#8217;t use it to look
for commits older than a few months.</simpara>
<simpara>To see reflog information formatted like <literal>git log</literal> output, run <literal>git log -g</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'</programlisting>
<simpara>It’s important to note that the reflog information is strictly local&#8201;&#8212;&#8201;it’s a log of what
you’ve done in your repository. The references won’t be the same on someone else’s copy of the repository.
Right after you initially clone a repository, you have an empty reflog, since no activity has occurred
yet in your repository. Running <literal>git show HEAD@{2.months.ago}</literal> works only if you cloned the project
at least two months ago&#8201;&#8212;&#8201;if you cloned it five minutes ago, you see nothing.</simpara>
</section>
<section xml:id="_ancestry_references">
<title>Ancestry References</title>
<simpara>The other main way to specify a commit is via its ancestry.
If you place a <literal>^</literal> (caret) at the end of a reference, Git interprets it to mean the parent of that commit.
Suppose you look at the history of your project.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list</programlisting>
<simpara>Then, you can specify the previous commit by the name <literal>HEAD^</literal>, which means <literal>the parent of HEAD</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'</programlisting>
<note>
<title>Escaping the caret on Windows</title>
<simpara>On Windows, <literal>^</literal> is a special character to <literal>cmd.exe</literal> and needs to be treated specially.
Either double it or put the commit reference in quotes.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show HEAD^     # will NOT work on Windows
$ git show HEAD^^    # OK
$ git show "HEAD^"   # OK</programlisting>
</note>
<simpara>You can also specify a number after the <literal>^</literal>&#8201;&#8212;&#8201;for example, <literal>d921970^2</literal> means <literal>the second parent of d921970.</literal>
This syntax is only useful for merge commits, which have more than one parent.
The first parent is the branch you were on when you merged,
and the second is the commit on the branch that you merged in.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly &lt;paul+git@mjr.org&gt;
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes</programlisting>
<simpara>The other main ancestry notation is <literal>~</literal> (tilde).
This also refers to the first parent, so <literal>HEAD~</literal> and <literal>HEAD^</literal> are equivalent.
The difference becomes apparent when you specify a number.
<literal>HEAD~2</literal> means <literal>the first parent of the first parent,</literal> or <literal>the grandparent</literal>&#8201;&#8212;&#8201;it traverses
the first parents the number of times you specify.
For example, in the history listed earlier, <literal>HEAD~3</literal> would be</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem</programlisting>
<simpara>This can also be written <literal>HEAD~~~</literal>, which again is the first parent of the first parent of the first parent.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show HEAD~~~
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem</programlisting>
<simpara>You can also combine these syntaxes. For example, you can specify the second parent of the
previous reference (assuming it was a merge commit) by using <literal>HEAD~3^2</literal>, and so on.</simpara>
</section>
<section xml:id="_commit_ranges">
<title>Commit Ranges</title>
<simpara>Now that you know how to specify individual commits, let’s see how to specify ranges of commits.
This is particularly useful for managing branches. If you have a lot of branches,
you can use range specifications to answer questions like what work is on this branch
that I haven’t merged into my main branch yet?</simpara>
<section xml:id="_double_dot">
<title>Double Dot</title>
<simpara>The most common range specification is the double-dot syntax.
This specifies a range of commits that are reachable from one commit but not another.
For example, say you have a commit history that looks like <xref linkend="double_dot"/></simpara>
<figure xml:id="double_dot">
<title>Example history for range selection.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/double-dot.png"/>
</imageobject>
<textobject><phrase>Example history for range selection.</phrase></textobject>
</mediaobject>
</figure>
<simpara><literal>master..experiment</literal> shows the commits in <literal>experiment</literal> that haven’t been merged into <literal>master</literal> yet.
This means all commits reachable by <literal>experiment</literal> that aren’t reachable by <literal>master</literal>.
For the sake of brevity and clarity in these examples, we use the letters of the commits from the diagram in
place of the actual <literal>git log</literal> output in the order that they would be displayed.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log master..experiment
D
C</programlisting>
<simpara>On the other hand, to see the opposite&#8201;&#8212;&#8201;all commits in <literal>master</literal> that aren’t
in <literal>experiment</literal>&#8201;&#8212;&#8201;reverse the branch names.
<literal>experiment..master</literal> shows everything in <literal>master</literal> not reachable from <literal>experiment</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log experiment..master
F
E</programlisting>
<simpara>This is useful for keeping <literal>experiment</literal> up to date and previewing what you’re about to merge in.
Another very frequent use of this syntax is to see what you’re about to push to a remote.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log origin/master..HEAD</programlisting>
<simpara>This shows any commits in your current branch that aren’t in <literal>master</literal> on the <literal>origin</literal> remote.
If you run <literal>git push</literal> and your current branch is tracking <literal>origin/master</literal>,
the commits shown by running <literal>git log origin/master..HEAD</literal> are the commits that are transferred to <literal>origin</literal>.
You can also leave off one side of the specification as an abreviation for <literal>HEAD</literal>.
For example, you get the same results as in the previous example by running <literal>git log origin/master..</literal>. Git
substitutes <literal>HEAD</literal> if one side is missing.</simpara>
</section>
<section xml:id="_multiple_points">
<title>Multiple Points</title>
<simpara>The double-dot syntax is a useful shorthand but perhaps you want to specify more than two branches
to specify your revision, such as showing what commits are in any of several branches that aren&#8217;t
in the branch you’re currently on. Do this by using either the <literal>^</literal> character or the <literal>--not</literal> flag
before any reference from which you don’t want to see reachable commits.
Thus, the following three commands are equivalent:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA</programlisting>
<simpara>This is nice because you can specify more than two references in your query,
which you can&#8217;t do with the double-dot syntax.
For instance, to see all commits reachable from <literal>refA</literal> or <literal>refB</literal>, but not from <literal>refC</literal>, run one of</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log refA refB ^refC
$ git log refA refB --not refC</programlisting>
<simpara>This makes for a very powerful revision query language that should help show what&#8217;s in your branches.</simpara>
</section>
<section xml:id="_triple_dot">
<title>Triple Dot</title>
<simpara>The last major range-selection syntax is the triple-dot syntax, which specifies all the commits
reachable by either of two references, but not by both of them. Look back at the example commit history
in <xref linkend="double_dot"/> To see what&#8217;s in <literal>master</literal> or <literal>experiment</literal>, but not in both, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log master...experiment
F
E
D
C</programlisting>
<simpara>Again, this shows normal <literal>git log</literal> output but only for those four commits,
appearing in the traditional commit date order.</simpara>
<simpara>A common flag to use with <literal>git log</literal> in this case is <literal>--left-right</literal>, which shows which
side of the range each commit is in. This helps make the output more useful.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --left-right master...experiment
&lt; F
&lt; E
&gt; D
&gt; C</programlisting>
<simpara>With these tools, you can easily specify the commit or commits to inspect.</simpara>
</section>
</section>
</section>
<section xml:id="_interactive_staging">
<title>Interactive Staging</title>
<simpara>Git comes with a couple of scripts that make some command-line tasks easier.
Here are a few interactive commands that help you easily craft your commits to include only
certain combinations and parts of files. These tools are very helpful if you modify a bunch of files
and then decide that those changes should be in several focused commits rather than one big messy commit.
This way, you can make sure your commits are logically separate and can be easily reviewed by
the developers you work with. If you run <literal>git add</literal> with the <literal>-i</literal> or <literal>--interactive</literal> flag,
Git goes into an interactive command mode, displaying something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt;</programlisting>
<simpara>You see a much different view of your staging area&#8201;&#8212;&#8201;basically the same information you get
from <literal>git status</literal> but more succinct and informative.
It lists the changes you’ve staged on the left and unstaged changes on the right.</simpara>
<simpara>After this comes a <literal>Commands</literal> section.
Here you can do a number of things, including staging files, unstaging files, staging parts of files,
adding untracked files, and seeing diffs of what&#8217;s been staged.</simpara>
<section xml:id="_staging_and_unstaging_files">
<title>Staging and Unstaging Files</title>
<simpara>If you enter <literal>2</literal> or <literal>u</literal> at the <literal>What now&gt;</literal> prompt, the script prompts for the files to stage.</simpara>
<programlisting language="console" linenumbering="unnumbered">What now&gt; 2
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&gt;&gt;</programlisting>
<simpara>To stage <literal>TODO</literal> and <literal>index.html</literal>, enter their numbers.</simpara>
<programlisting language="console" linenumbering="unnumbered">Update&gt;&gt; 1,2
           staged     unstaged path
* 1:    unchanged        +0/-1 TODO
* 2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&gt;&gt;</programlisting>
<simpara>The <literal>*</literal> at the beginning of the line means the file is selected to be staged.
If you don&#8217;t enter anything at the <literal>Update&gt;&gt;</literal> prompt and then type Enter, Git stages the files you selected.</simpara>
<programlisting language="console" linenumbering="unnumbered">Update&gt;&gt;
updated 2 paths

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 1
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb</programlisting>
<simpara>Now you see that <literal>TODO</literal> and <literal>index.html</literal> are staged and <literal>simplegit.rb</literal> is still unstaged.
To unstage <literal>TODO</literal> at this point, enter <literal>3</literal> or <literal>r</literal> (for revert).</simpara>
<programlisting language="console" linenumbering="unnumbered">*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 3
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&gt;&gt; 1
           staged     unstaged path
* 1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&gt;&gt; [enter]
reverted one path</programlisting>
<simpara>Looking at the status output again, you see that you’ve unstaged <literal>TODO</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb</programlisting>
<simpara>To see the diff of what you staged and what&#8217;s in your repository, enter <literal>6</literal> or <literal>d</literal> (for diff).
It shows a list of your staged files, and you can select the ones for which you&#8217;d like to see the staged diff.
This is much like running <literal>git diff --cached</literal> on the command line.</simpara>
<programlisting language="console" linenumbering="unnumbered">*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now&gt; 6
           staged     unstaged path
  1:        +1/-1      nothing index.html
Review diff&gt;&gt; 1
diff --git a/index.html b/index.html
index 4d07108..4335f49 100644
--- a/index.html
+++ b/index.html
@@ -16,7 +16,7 @@ Date Finder

 &lt;p id="out"&gt;...&lt;/p&gt;

-&lt;div id="footer"&gt;contact : support@github.com&lt;/div&gt;
+&lt;div id="footer"&gt;contact : email.support@github.com&lt;/div&gt;

 &lt;script type="text/javascript"&gt;</programlisting>
<simpara>With these basic commands, you can use interactive add mode to manage your staging area a little more easily.</simpara>
</section>
<section xml:id="_staging_patches">
<title>Staging Patches</title>
<simpara>It’s also possible for Git to stage certain parts of files and not others.
For example, if you make two changes to <literal>simplegit.rb</literal> and want to stage one of them and not the other,
doing so is very easy. From the interactive prompt, enter <literal>5</literal> or <literal>p</literal> (for patch).
You&#8217;re asked which files you&#8217;d like to partially stage. Then, for each section of the selected files,
you see hunks of the file diff and you&#8217;re asked if you&#8217;d like to stage them, one by one.</simpara>
<programlisting language="console" linenumbering="unnumbered">diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index dd5ecc4..57399e0 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -22,7 +22,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log -n 25 #{treeish}")
+    command("git log -n 30 #{treeish}")
   end

   def blame(path)
Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</programlisting>
<simpara>You have a lot of options at this point. Typing <literal>?</literal> shows them.</simpara>
<programlisting language="console" linenumbering="unnumbered">Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?
y - stage this hunk
n - do not stage this hunk
a - stage this and all the remaining hunks in the file
d - do not stage this hunk nor any of the remaining hunks in the file
g - select a hunk to go to
/ - search for a hunk matching the given regex
j - leave this hunk undecided, see next undecided hunk
J - leave this hunk undecided, see next hunk
k - leave this hunk undecided, see previous undecided hunk
K - leave this hunk undecided, see previous hunk
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help</programlisting>
<simpara>Generally, enter <literal>y</literal> or <literal>n</literal> to stage each hunk, but staging all hunks in certain files or skipping a
hunk decision until later can be helpful too. If you stage one part of the file and leave another part
unstaged, your status output looks like</simpara>
<programlisting language="console" linenumbering="unnumbered">What now&gt; 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:        +1/-1        +4/-0 lib/simplegit.rb</programlisting>
<simpara>The status of <literal>simplegit.rb</literal> is interesting.
It shows that some lines are staged and some are unstaged.
You’ve partially staged this file.
At this point, you can exit the script and run <literal>git commit</literal> to commit the partially staged files.</simpara>
<simpara>You also don’t need to be in interactive add mode to do partial-file staging.
You can start the same script by running <literal>git add</literal> with the <literal>-p</literal> or <literal>--patch</literal> flag.</simpara>
<simpara>Furthermore, you can use patch mode for partially resetting files with <literal>git reset --patch</literal>,
or for checking out parts of files with <literal>git checkout --patch</literal>.</simpara>
</section>
</section>
<section xml:id="_git_stashing">
<title>Stashing and Cleaning</title>
<simpara>Often, when you’ve been working on a project, things get messy and you want to switch branches to work
on something else. The problem is, you don’t want to commit half-done work just so you can get back
to the messy state later. The answer to this conundrum is <literal>git stash</literal>.</simpara>
<simpara>Stashing takes the dirty state of your working directory&#8201;&#8212;&#8201;that is, your modified tracked files
and staged changes&#8201;&#8212;&#8201;and saves it on a stack that you can go back to at any time.</simpara>
<note>
<title>Migrating to <literal>git stash push</literal></title>
<simpara>As of late October 2017, there has been extensive discussion on the Git mailing list that has resulted
in the <literal>git stash save</literal> command being deprecated in favor of the existing alternative <literal>git stash push</literal>.
The main reason for this is that <literal>git stash push</literal> introduces the option of stashing selected files,
something <literal>git stash save</literal> can&#8217;t do.</simpara>
<simpara><literal>git stash save</literal> is not going away any time soon, so don&#8217;t worry about it suddenly disappearing.
But you might want to start using <literal>git stash push</literal> for the new features it supports.</simpara>
</note>
<section xml:id="_stashing_your_work">
<title>Stashing Your Work</title>
<simpara>To demonstrate, go into your project and start working on a couple of files and stage a change.
If you run <literal>git status</literal>, you see the dirty state.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   lib/simplegit.rb</programlisting>
<simpara>Now you want to switch branches, but you don’t want to commit what you’ve been working on yet.
So, stash the changes. To push a new stash onto your stack, run <literal>git stash</literal> or <literal>git stash save</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git stash
Saved working directory and index state \
  "WIP on master: 049d078 added the index file"
HEAD is now at 049d078 added the index file
(To restore them type "git stash apply")</programlisting>
<simpara>Your working directory is clean.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
# On branch master
nothing to commit, working directory clean</programlisting>
<simpara>At this point, you can easily switch branches and do work elsewhere. Your changes are stored on your stack.
To see the stashes you’ve stored, run <literal>git stash list</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log</programlisting>
<simpara>In this case, you&#8217;ve done two stashes previously, so you have access to three different stashed states.
You can reapply the one you just stashed by running <literal>git stash apply</literal>, as shown in the help
output of the original stash command. To apply one of the older stashes, specify it by naming it
like this: <literal>git stash apply stash@{2}</literal>. If you don’t specify a stash, Git assumes you mean the
most recent stash.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git stash apply
On branch master
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   index.html
	modified:   lib/simplegit.rb

no changes added to commit (use "git add" and/or "git commit -a")</programlisting>
<simpara>You see that Git re-modifies the files you reverted when you saved the stash.
In this case, you had a clean working directory when you tried to apply the stash,
and you tried to apply it on the same branch you saved it from. But having a clean working
directory and applying it on the same branch aren’t necessary to successfully apply a stash.
You can save a stash from one branch, switch to another branch, and try to apply the changes.
You can also have modified and uncommitted files in your working directory when you apply a stash.
Git shows merge conflicts if anything no longer applies cleanly.</simpara>
<simpara>The changes to your files are reapplied, but the file you staged before wasn’t restaged.
To do that, you must run <literal>git stash apply</literal> with the <literal>--index</literal> flag to try to reapply the staged changes.
This gets you back to your original state.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git stash apply --index
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   lib/simplegit.rb</programlisting>
<simpara>The apply option only tries to apply the stashed work. Even if the reapply is successful,
the stashed work remains on your stack. To remove it, run <literal>git stash drop</literal> with the
name of the stash to remove.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)</programlisting>
<simpara>You can also run <literal>git stash pop</literal> to apply the stash and then immediately remove it from your stack.</simpara>
</section>
<section xml:id="_creative_stashing">
<title>Creative Stashing</title>
<simpara>There are a few stash variants that can also be helpful. One flag to <literal>git stash save</literal> that&#8217;s
quite popular is <literal>--keep-index</literal>. This tells Git to not stash anything that you&#8217;ve already staged.</simpara>
<simpara>This can be really helpful if you&#8217;ve made a number of changes but only want to commit some of them
and then come back to the rest of the changes later.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status -s
M  index.html
 M lib/simplegit.rb

$ git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
M  index.html</programlisting>
<simpara>Another common way to use the stash is to stash both tracked and untracked files.
By default, <literal>git stash</literal> only stores files that are already in the index.
If you specify <literal>--include-untracked</literal> or <literal>-u</literal>, Git also stashes any untracked files.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

$ git stash -u
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
$</programlisting>
<simpara>Finally, if you specify the <literal>--patch</literal> flag, Git doesn&#8217;t stash everything that&#8217;s modified but instead
prompts for you to specify which changes you&#8217;d like to stash and which you&#8217;d like to keep in your
working directory.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2&gt;&amp;1`.chomp
       end
     end
+
+    def show(treeish = 'master')
+      command("git show #{treeish}")
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file</programlisting>
</section>
<section xml:id="_creating_a_branch_from_a_stash">
<title>Creating a Branch from a Stash</title>
<simpara>If you stash some work, leave it there for a while, and continue on the branch from which
you stashed the work, you may have a problem reapplying the work. If reapplying tries to modify a
file that you’ve since modified, you get a merge conflict which you have to resolve.
An easier way to test the stashed changes again is to run <literal>git stash branch &lt;branch-name&gt;</literal>,
which creates a new branch with the given branch name, checks out the commit you were on
when you stashed your work, reapplies your work there, and then drops the stash if it applies successfully.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git stash branch testchanges
M	index.html
M	lib/simplegit.rb
Switched to a new branch 'testchanges'
On branch testchanges
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   lib/simplegit.rb

Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)</programlisting>
<simpara>This is a nice shortcut to recover stashed work easily and then work on it in a new branch.</simpara>
</section>
<section xml:id="_git_clean">
<title>Cleaning your Working Directory</title>
<simpara>Finally, you may not want to stash some work in your working directory, but simply get rid of it.
<literal>git clean</literal> does this.</simpara>
<simpara>Some common reasons for this might be to remove cruft that has been generated by merges or external tools,
or to remove build artifacts.</simpara>
<simpara>Be careful with this command, since it&#8217;s designed to remove files from your working directory that aren&#8217;t
tracked. If you change your mind, there&#8217;s often no way to retrieve those files.
A safer option is to run <literal>git stash --all</literal> to remove everything but save it in a stash.</simpara>
<simpara>Assuming you do want to remove cruft or clean your working directory, do so by running <literal>git clean</literal>.
To remove all the untracked files in your working directory, run <literal>git clean -f -d</literal>, which removes
any files and also any subdirectories that become empty as a result. The <literal>-f</literal> flag means "force".</simpara>
<simpara>If you ever want to see what running this command would do, run it with the <literal>-n</literal> flag,
which does a dry run and says what <emphasis>would</emphasis> have been removed.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clean -d -n
Would remove test.o
Would remove tmp/</programlisting>
<simpara>By default, <literal>git clean</literal> only removes untracked files that aren&#8217;t ignored.
Any files that match a pattern in <literal>.gitignore</literal> or other ignore files aren&#8217;t removed.
To remove those files too, such as <literal>.o</literal> files generated from a build so that you can do a fresh build,
add the <literal>-x</literal> flag to <literal>git clean</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

$ git clean -n -d
Would remove build.TMP
Would remove tmp/

$ git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/</programlisting>
<simpara>If you don&#8217;t know what <literal>git clean</literal> is going to do, always run it with <literal>-n</literal> first to double
check before changing the <literal>-n</literal> to <literal>-f</literal> and doing it for real. The other way to check the result
is to run <literal>git clean</literal> with the <literal>-i</literal> or <literal>interactive</literal> flag.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clean -x -i
Would remove the following items:
  build.TMP  test.o
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
What now&gt;</programlisting>
<simpara>This way you can step through each file individually or specify patterns for deletion interactively.</simpara>
<note>
<simpara>There is an unusual situation when you might need to be extra forceful in telling Git to clean
your working directory. If you happen to be in a working directory under which you&#8217;ve copied or
cloned other Git repositories, even running <literal>git clean -f -d</literal> won&#8217;t delete those directories.
In this case, add a second <literal>-f</literal> flag for emphasis.</simpara>
</note>
</section>
</section>
<section xml:id="_signing">
<title>Signing Your Work</title>
<simpara>Git is cryptographically secure, but it&#8217;s not foolproof. If you&#8217;re taking work from others and want to
verify that it&#8217;s actually from a trusted source, Git can sign and verify it using GPG.</simpara>
<section xml:id="_gpg_introduction">
<title>GPG Introduction</title>
<simpara>First of all, to sign anything you need to configure GPG and install your personal key.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   2048R/0A46826A 2014-06-04
uid                  Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;
sub   2048R/874529A9 2014-06-04</programlisting>
<simpara>If you don&#8217;t have a key installed, generate one by running <literal>gpg --gen-key</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ gpg --gen-key</programlisting>
<simpara>Once you have a private key to use for signing, configure Git to use it by setting
the <literal>user.signingkey</literal> config setting.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global user.signingkey 0A46826A</programlisting>
<simpara>Now Git uses your key by default to sign tags and commits.</simpara>
</section>
<section xml:id="_signing_tags">
<title>Signing Tags</title>
<simpara>If you have a GPG private key set up, use it now to sign new tags.
All you have to do is use <literal>-s</literal> instead of <literal>-a</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag -s v1.5 -m 'my signed 1.5 tag'

You need a passphrase to unlock the secret key for
user: "Ben Straub &lt;ben@straub.cc&gt;"
2048-bit RSA key, ID 800430EB, created 2014-05-04</programlisting>
<simpara>If you run <literal>git show</literal> on that tag, you see your GPG signature attached to it.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show v1.5
tag v1.5
Tagger: Ben Straub &lt;ben@straub.cc&gt;
Date:   Sat May 3 20:29:41 2014 -0700

my signed 1.5 tag
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1

iQEcBAABAgAGBQJTZbQlAAoJEF0+sviABDDrZbQH/09PfE51KPVPlanr6q1v4/Ut
LQxfojUWiLQdg2ESJItkcuweYg+kc3HCyFejeDIBw9dpXt00rY26p05qrpnG+85b
hM1/PswpPLuBSr+oCIDj5GMC2r2iEKsfv2fJbNW8iWAXVLoWZRF8B0MfqX/YTMbm
ecorc4iXzQu7tupRihslbNkfvfciMnSDeSvzCpWAHl7h8Wj6hhqePmLm9lAYqnKp
8S5B/1SSQuEAjRZgI4IexpZoeKGVDptPHxLLS38fozsyi0QyDyzEgJxcJQVMXxVi
RUysgqjcpT8+iQM1PblGfHR4XAhuOqN5Fx06PSaFZhqvWFezJ28/CLyX5q+oIVk=
=EFTF
-----END PGP SIGNATURE-----

commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number</programlisting>
</section>
<section xml:id="_verifying_tags">
<title>Verifying Tags</title>
<simpara>To verify a signed tag, run <literal>git tag -v [tag-name]</literal>.
This uses GPG to verify the signature.
You need the signer’s public key in your keyring for this to work properly.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag -v v1.4.2.1
object 883653babd8ee7ea23e6a5c392bb739348b1eb61
type commit
tag v1.4.2.1
tagger Junio C Hamano &lt;junkio@cox.net&gt; 1158138501 -0700

GIT 1.4.2.1

Minor fixes since 1.4.2, including git-mv and git-http with alternates.
gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Good signature from "Junio C Hamano &lt;junkio@cox.net&gt;"
gpg:                 aka "[jpeg image of size 1513]"
Primary key fingerprint: 3565 2A26 2040 E066 C9A7  4A7D C0C6 D9A4 F311 9B9A</programlisting>
<simpara>If you don’t have the signer’s public key, you see something like</simpara>
<programlisting language="console" linenumbering="unnumbered">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A
gpg: Can't check signature: public key not found
error: could not verify the tag 'v1.4.2.1'</programlisting>
</section>
<section xml:id="_signing_commits">
<title>Signing Commits</title>
<simpara>In more recent versions of Git (v1.7.9 and above), you can now also sign individual commits.
If you&#8217;re interested in signing commits directly instead of just the tags, just add <literal>-S</literal> to <literal>git commit</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit -a -S -m 'signed commit'

You need a passphrase to unlock the secret key for
user: "Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;"
2048-bit RSA key, ID 0A46826A, created 2014-06-04

[master 5c3386c] signed commit
 4 files changed, 4 insertions(+), 24 deletions(-)
 rewrite Rakefile (100%)
 create mode 100644 lib/git.rb</programlisting>
<simpara>To see and verify these signatures, there&#8217;s also a <literal>--show-signature</literal> flag to <literal>git log</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --show-signature -1
commit 5c3386cf54bba0a33a32da706aa52bc0155503c2
gpg: Signature made Wed Jun  4 19:49:17 2014 PDT using RSA key ID 0A46826A
gpg: Good signature from "Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;"
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Jun 4 19:49:17 2014 -0700

    signed commit</programlisting>
<simpara>Additionally, you can configure <literal>git log</literal> to check any signatures it finds and list them if you
use the <literal>git log</literal> <literal>%G?</literal> format option.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty="format:%h %G? %aN  %s"

5c3386c G Scott Chacon  signed commit
ca82a6d N Scott Chacon  changed the version number
085bb3b N Scott Chacon  removed unnecessary test code
a11bef0 N Scott Chacon  first commit</programlisting>
<simpara>Here we see that only the latest commit is signed and valid, and the previous commits aren&#8217;t.</simpara>
<simpara>In Git 1.8.3 and later, <literal>git merge</literal> and <literal>git pull</literal> can be told, by adding the <literal>--verify-signatures</literal> flag,
to inspect and reject a merge when a commit doesn&#8217;t carry a trusted GPG signature.</simpara>
<simpara>If you use this option when merging a branch and it contains commits that are not signed and valid,
the merge fails.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge --verify-signatures non-verify
fatal: Commit ab06180 does not have a GPG signature.</programlisting>
<simpara>If the merge contains only valid signed commits, the command shows all the signatures it has checked
and then continues with the merge.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge --verify-signatures signed-branch
Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;
Updating 5c3386c..13ad65e
Fast-forward
 README | 2 ++
 1 file changed, 2 insertions(+)</programlisting>
<simpara>You can also use the <literal>-S</literal> flag with <literal>git merge</literal> to sign the resulting merge commit. The following example both verifies that every commit in the branch to be merged is signed and furthermore signs the resulting merge commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge --verify-signatures -S  signed-branch
Commit 13ad65e has a good GPG signature by Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;

You need a passphrase to unlock the secret key for
user: "Scott Chacon (Git signing key) &lt;schacon@gmail.com&gt;"
2048-bit RSA key, ID 0A46826A, created 2014-06-04

Merge made by the 'recursive' strategy.
 README | 2 ++
 1 file changed, 2 insertions(+)</programlisting>
</section>
<section xml:id="_everyone_must_sign">
<title>Everyone Must Sign</title>
<simpara>Signing tags and commits is great, but if you decide to add it to your normal workflow,
make sure that everyone on your team understands how to do so. If you don&#8217;t,
you end up spending a lot of time helping people figure out how to rewrite their commits with valid
signatures. Make sure you understand GPG and the benefits of signing before adopting this as part of
your standard workflow.</simpara>
</section>
</section>
<section xml:id="_searching">
<title>Searching</title>
<simpara>You often need to find where a function is called or defined,
or find the history of a method. Git provides a couple of useful tools for searching the code
and commits stored in a repository quickly and easily. We go through a few of them.</simpara>
<section xml:id="_git_grep">
<title>Git Grep</title>
<simpara>Git includes a subcommand called <literal>grep</literal> that searches any committed tree, the working
directory, or even the index for a string or regular expression. In these examples, we look through the Git source code itself.</simpara>
<simpara>By default, <literal>git grep</literal> looks through the files in your working directory.
Pass <literal>-n</literal> to print out the line numbers where Git finds matches.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git grep -n gmtime_r
compat/gmtime.c:3:#undef gmtime_r
compat/gmtime.c:8:      return git_gmtime_r(timep, &amp;result);
compat/gmtime.c:11:struct tm *git_gmtime_r(const time_t *timep, struct tm *result)
compat/gmtime.c:16:     ret = gmtime_r(timep, result);
compat/mingw.c:826:struct tm *gmtime_r(const time_t *timep, struct tm *result)
compat/mingw.h:206:struct tm *gmtime_r(const time_t *timep, struct tm *result);
date.c:482:             if (gmtime_r(&amp;now, &amp;now_tm))
date.c:545:             if (gmtime_r(&amp;time, tm)) {
date.c:758:             /* gmtime_r() in match_digit() may have clobbered it */
git-compat-util.h:1138:struct tm *git_gmtime_r(const time_t *, struct tm *);
git-compat-util.h:1140:#define gmtime_r git_gmtime_r</programlisting>
<simpara>There are a number of interesting flags you can provide <literal>git grep</literal>.</simpara>
<simpara>For instance, instead of the previous command, if you add the <literal>--count</literal> flag, Git can
summarize the output by just showing which files matched and how many matches were in each file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git grep --count gmtime_r
compat/gmtime.c:4
compat/mingw.c:1
compat/mingw.h:1
date.c:3
git-compat-util.h:2</programlisting>
<simpara>To see the method or function where the match was found, add the <literal>-p</literal> or <literal>--show-function</literal> flag.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git grep -p gmtime_r *.c
date.c=static int match_multi_number(timestamp_t num, char c, const char *date,
date.c:         if (gmtime_r(&amp;now, &amp;now_tm))
date.c=static int match_digit(const char *date, struct tm *tm, int *offset, int *tm_gmt)
date.c:         if (gmtime_r(&amp;time, tm)) {
date.c=int parse_date_basic(const char *date, timestamp_t *timestamp, int *offset)
date.c:         /* gmtime_r() in match_digit() may have clobbered it */</programlisting>
<simpara>So here we see that <literal>gmtime_r</literal> is called in the <literal>match_multi_number</literal> and <literal>match_digit</literal> functions
in <literal>date.c</literal>.</simpara>
<simpara>You can also look for complex combinations of strings with the <literal>--and</literal> flag, which requires that the strings
that appear on both sides of the flag appear on the current line. For instance, let&#8217;s look for any lines that define
a constant containing either the strings <literal>LINK</literal> or <literal>BUF_MAX</literal> in the Git codebase in an older 1.8.0 version.</simpara>
<simpara>Here we also use the <literal>--break</literal> and <literal>--heading</literal> flags which help split up the output into a more readable format.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git grep --break --heading \
    -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0
v1.8.0:builtin/index-pack.c
62:#define FLAG_LINK (1u&lt;&lt;20)

v1.8.0:cache.h
73:#define S_IFGITLINK  0160000
74:#define S_ISGITLINK(m)       (((m) &amp; S_IFMT) == S_IFGITLINK)

v1.8.0:environment.c
54:#define OBJECT_CREATION_MODE OBJECT_CREATION_USES_HARDLINKS

v1.8.0:strbuf.c
326:#define STRBUF_MAXLINK (2*PATH_MAX)

v1.8.0:symlinks.c
53:#define FL_SYMLINK  (1 &lt;&lt; 2)

v1.8.0:zlib.c
30:/* #define ZLIB_BUF_MAX ((uInt)-1) */
31:#define ZLIB_BUF_MAX ((uInt) 1024 * 1024 * 1024) /* 1GB */</programlisting>
<simpara><literal>git grep</literal> has several advantages over normal searching commands like <literal>grep</literal> and <literal>ack</literal>.
The first is that it&#8217;s really fast. The second is that you can search anywhere in a Git repository,
not just the working directory. As we saw in the above example, we looked for terms in an older
version of the Git source code, not just in the version that was currently checked out.</simpara>
</section>
<section xml:id="_git_log_searching">
<title>Git Log Searching</title>
<simpara>Perhaps you&#8217;re looking not for <emphasis role="strong">where</emphasis> a term exists, but <emphasis role="strong">when</emphasis> it was introduced.
<literal>git log</literal> has a number of powerful options for finding specific commits by the content of their
commit messages or even by the changes they introduce.</simpara>
<simpara>To find, for example, when the <literal>ZLIB_BUF_MAX</literal> constant was originally introduced, <literal>git log</literal>
only shows the commits that either added or removed that string if we add the <literal>-S</literal> flag.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -S ZLIB_BUF_MAX --oneline
e01503b zlib: allow feeding more than 4GB in one go
ef49a7a zlib: zlib can only process 4GB at a time</programlisting>
<simpara>If we look at the changes in those commits we see that in <literal>ef49a7a</literal> the constant was introduced
and in <literal>e01503b</literal> it was modified.</simpara>
<simpara>To be more specific, provide a regular expression to search for with the <literal>-G</literal> flag.</simpara>
<section xml:id="_line_log_search">
<title>Line Log Search</title>
<simpara>Another fairly advanced log search technique that&#8217;s insanely useful is the line history search.
This is a fairly recent addition and not very well known, but it can be really helpful.
Add the <literal>-L</literal> flag to <literal>git log</literal> to show the history of a function or line of code.</simpara>
<simpara>For example, to see every change made to the function <literal>git_deflate_bound</literal> in <literal>zlib.c</literal>,
run <literal>git log -L :git_deflate_bound:zlib.c</literal>. Git tries to figure out what the bounds of that function
are and then looks through the history and shows every change that was made to the function
as a series of patches back to when the function was first created.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -L :git_deflate_bound:zlib.c
commit ef49a7a0126d64359c974b4b3b71d7ad42ee3bca
Author: Junio C Hamano &lt;gitster@pobox.com&gt;
Date:   Fri Jun 10 11:52:15 2011 -0700

    zlib: zlib can only process 4GB at a time

diff --git a/zlib.c b/zlib.c
--- a/zlib.c
+++ b/zlib.c
@@ -85,5 +130,5 @@
-unsigned long git_deflate_bound(z_streamp strm, unsigned long size)
+unsigned long git_deflate_bound(git_zstream *strm, unsigned long size)
 {
-       return deflateBound(strm, size);
+       return deflateBound(&amp;strm-&gt;z, size);
 }


commit 225a6f1068f71723a910e8565db4e252b3ca21fa
Author: Junio C Hamano &lt;gitster@pobox.com&gt;
Date:   Fri Jun 10 11:18:17 2011 -0700

    zlib: wrap deflateBound() too

diff --git a/zlib.c b/zlib.c
--- a/zlib.c
+++ b/zlib.c
@@ -81,0 +85,5 @@
+unsigned long git_deflate_bound(z_streamp strm, unsigned long size)
+{
+       return deflateBound(strm, size);
+}
+</programlisting>
<simpara>If Git can&#8217;t figure out how to match a function or method in your programming language,
you can also provide a regular expression. For example, the following would do the same thing:</simpara>
<simpara><literal>git log -L '/unsigned long git_deflate_bound/',/^}/:zlib.c</literal></simpara>
<simpara>You could also give a range of lines or a single line number to get the same sort of output.</simpara>
</section>
</section>
</section>
<section xml:id="_rewriting_history">
<title>Rewriting History</title>
<simpara>When working with Git, you may want to revise your commit history for some reason.
One of the great things about Git is that it allows making decisions at the last possible moment.
You can decide what files go into a commit by what you put into the staging area,
you can easily change what you&#8217;re working on with <literal>git stash</literal>, and you can rewrite
commits that already happened so they look like they happened in a different way.
This can involve changing the order of the commits, changing messages or modifying files in a commit,
squashing together or splitting apart commits, or removing commits entirely&#8201;&#8212;&#8201;all before you share your work.</simpara>
<simpara>In this section, we cover how to make your commit history look the way you want.</simpara>
<note>
<simpara>One of the cardinal rules of Git is that since so much work is in a local repository,
you can easily choose to rewrite your history <emphasis>locally</emphasis>.
However, once you push your work, things change. You should consider
anything you&#8217;ve pushed as final unless you have good reason to change it.
In short, you should avoid pushing your work until you&#8217;re happy with it and ready to share
it with the rest of the world.</simpara>
</note>
<section xml:id="_git_amend">
<title>Changing the Last Commit</title>
<simpara>Changing your last commit is probably the most common rewriting of history that you do.
You often want to do two basic things to your last commit: modify the commit message,
or change what you just committed.</simpara>
<simpara>To only modify your last commit message is very simple.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit --amend</programlisting>
<simpara>That starts your text editor, with your last commit message already in the editor&#8217;s buffer,
ready for you to modify. When you save and exit the editor, Git creates a commit containing
the new message. This is your new last commit.</simpara>
<simpara>If you’ve committed and then want to change what you saved by adding or changing files,
the process works basically the same. Stage the changes you want to commit by running <literal>git add</literal> on
the files containing the changes, or <literal>git rm</literal> a tracked file. Then running <literal>git commit --amend</literal>
changes what&#8217;s in your staging area and adds it to the next commit.</simpara>
<simpara>Be careful with this technique because both of these change the SHA-1 hash of the commit.
It’s like a very small rebase&#8201;&#8212;&#8201;don’t amend your last commit if you’ve already pushed it.</simpara>
<tip>
<title>An amended commit may (or may not) need an amended commit message</title>
<simpara>When you amend a commit, you can change both the commit message and the content of the commit.
If you amend the content of the commit substantially, you should probably update the commit message
to reflect that amended content.</simpara>
<simpara>On the other hand, if your amendments are suitably trivial (fixing a silly typo or adding a file
you simply forgot to stage) such that the earlier commit message is still relevant, simply make the changes,
stage them, and avoid an unnecessary editor session entirely by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit --amend --no-edit</programlisting>
</tip>
</section>
<section xml:id="_changing_multiple">
<title>Changing Multiple Commit Messages</title>
<simpara>To modify a commit that&#8217;s farther back in history, you must use more complex tools.
Git doesn’t have a modify-history tool, but you can use rebasing as a way of changing a series
of commits instead of moving them to another branch. With the interactive rebase tool,
you can then stop after each commit you want to modify to change the message, add files,
or do whatever you wish. You rebase interactively by running <literal>git rebase -i</literal>.
You must indicate how far back you want to rewrite commits by specifying the commit to start with.</simpara>
<simpara>For example, to change any or all of the last three commit messages,
supply as an argument to <literal>git rebase -i</literal> the parent of the last commit you want to edit,
which is <literal>HEAD~2^</literal> or <literal>HEAD~3</literal>. It may be easier to remember <literal>HEAD~3</literal> because you’re trying
to edit the last three commits. But keep in mind that you’re actually designating a point four
commits ago, which is the parent of the last commit you want to edit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rebase -i HEAD~3</programlisting>
<simpara>Remember again that this is a rebasing command&#8201;&#8212;&#8201;every commit included in the range <literal>HEAD~3..HEAD</literal> is
rewritten, whether you change the message or not. Don’t include any commit you’ve already pushed
to a central server. Doing so confuses other developers.</simpara>
<simpara>Running this puts a list of commits in your text editor buffer that looks something like</simpara>
<programlisting language="console" linenumbering="unnumbered">pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out</programlisting>
<simpara>It’s important to note that these commits are listed in an order opposite of what you normally
see when running <literal>git log</literal>. If you run <literal>git log</literal>, you see something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit</programlisting>
<simpara>Notice the reversed order.
The interactive rebase shows a script that it’s going to run.
It starts at the commit you specify on the command line (<literal>HEAD~3</literal>) and replays the changes introduced
in each of these commits from top to bottom. It lists the oldest at the top, rather than the newest,
because that’s the first one it replays.</simpara>
<simpara>You need to edit the script so that it stops at the commit you want to edit.
To do so, change the word &#8216;pick&#8217; to the word &#8216;edit&#8217; for each of the commits you want the script to stop after.
For example, to modify only the third commit message, change the script to look like</simpara>
<programlisting language="console" linenumbering="unnumbered">edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</programlisting>
<simpara>When you save and exit the editor, Git rewinds back to the last commit in that list and drops you to the command line with the following message:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you’re satisfied with your changes, run

       git rebase --continue</programlisting>
<simpara>These instructions tell you exactly what to do.
Enter</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit --amend</programlisting>
<simpara>Change the commit message, and exit the editor.
Then, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rebase --continue</programlisting>
<simpara>This command applies the other two commits automatically, and then you’re done.
If you change <literal>pick</literal> to <literal>edit</literal> on more lines, you can repeat these steps for each commit you choose to edit.
Git stops each time, lets you amend the commit, and continues when you’re finished.</simpara>
</section>
<section xml:id="_reordering_commits">
<title>Reordering Commits</title>
<simpara>You can also use interactive rebases to reorder or remove commits entirely.
To remove the <literal>added cat-file</literal> commit and change the order in which the other two commits were introduced,
change the rebase script from this</simpara>
<programlisting language="console" linenumbering="unnumbered">pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</programlisting>
<simpara>to this.</simpara>
<programlisting language="console" linenumbering="unnumbered">pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit</programlisting>
<simpara>When you save and exit the editor, Git rewinds your branch to the parent of these commits,
applies <literal>310154e</literal> and then <literal>f7f3f6d</literal>, and then stops.
You effectively change the order of those commits and remove the <literal>added cat-file</literal> commit completely.</simpara>
</section>
<section xml:id="_squashing">
<title>Squashing Commits</title>
<simpara>It’s also possible to take a series of commits and squash them into a single commit with
the interactive rebasing tool. The script puts helpful instructions in the rebase message.</simpara>
<programlisting language="console" linenumbering="unnumbered">#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out</programlisting>
<simpara>If, instead of <literal>pick</literal> or <literal>edit</literal>, you specify <literal>squash</literal>, Git applies both that change and the change
directly before it, and merges the commit messages together.
So, to make a single commit from these three commits, make the script look like</simpara>
<programlisting language="console" linenumbering="unnumbered">pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file</programlisting>
<simpara>When you save and exit the editor, Git applies all three changes and then puts you back into
the editor to merge the three commit messages.</simpara>
<programlisting language="console" linenumbering="unnumbered"># This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file</programlisting>
<simpara>When you save that, you have a single commit that introduces the changes of all three previous commits.</simpara>
</section>
<section xml:id="_splitting_a_commit">
<title>Splitting a Commit</title>
<simpara>Splitting a commit undoes a commit and then partially stages and commits as many times as the number of
commits you want to end up with.
For example, suppose you want to split the middle commit of your three commits.
Instead of <literal>updated README formatting and added blame</literal>, you want to split it into two
commits: <literal>updated README formatting</literal> for the first, and <literal>added blame</literal> for the second.
You can do that in the <literal>git rebase -i</literal> script by changing the instruction on the commit
you want to split to <literal>edit</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file</programlisting>
<simpara>Then, when the script drops you to the command line, reset that commit, take the changes that
have been reset, and create multiple commits out of them. When you save and exit the editor,
Git rewinds to the parent of the first commit in your list, applies the first commit (<literal>f7f3f6d</literal>),
applies the second (<literal>310154e</literal>), and drops you to the command line. There, you can do a mixed reset
of that commit with <literal>git reset HEAD^</literal>, which effectively undoes that commit and leaves
the modified files unstaged. Now you can stage and commit files until you have several commits,
and run <literal>git rebase --continue</literal> when you’re done.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue</programlisting>
<simpara>After Git applies the last commit (<literal>a5f4a0d</literal>) in the script, your history looks like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit</programlisting>
<simpara>Once again, this changes the SHA-1 hashes of all the commits in your list,
so make sure no commit shows up in that list that you’ve already pushed to a shared repository.</simpara>
</section>
<section xml:id="_the_nuclear_option_filter_branch">
<title>The Nuclear Option: filter-branch</title>
<simpara>There&#8217;s another history-rewriting option to rewrite a larger number of commits in some scriptable way&#8201;&#8212;&#8201;for
instance, changing your email address globally or removing a file from every commit.
The command is <literal>git filter-branch</literal>, and it can rewrite huge swaths of your history,
so you probably shouldn’t use it unless your project isn’t yet public and other people haven&#8217;t
based work off the commits you’re about to rewrite. However, it can be very useful.
We describe a few of its common uses so you can get an idea of some of the things it’s capable of.</simpara>
<section xml:id="_removing_file_every_commit">
<title>Removing a File from Every Commit</title>
<simpara>This is fairly common.
Someone accidentally commits a huge binary file with a thoughtless <literal>git add .</literal>, and you want to
remove the file in all commits. Perhaps you accidentally committed a file that contains a password,
and you want to make your project open source. <literal>git filter-branch</literal> is how to scrub your entire history.
To remove a file named <literal>passwords.txt</literal> from your entire history, use the <literal>--tree-filter</literal> flag
to <literal>git filter-branch</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten</programlisting>
<simpara>The <literal>--tree-filter</literal> flag runs the specified command after each checkout of the project and
then recommits the results. In this case, you remove a file called <literal>passwords.txt</literal> from every snapshot,
whether it exists or not. Or, to remove all accidentally committed editor backup files,
run something like <literal>git filter-branch --tree-filter 'rm -f *~' HEAD</literal>.</simpara>
<simpara>You&#8217;re able to watch Git rewriting trees and commits, and then move the branch pointer at the end.
It’s generally a good idea to do this in a testing branch and then hard-reset your <literal>master</literal> after
you’ve determined the outcome is what you really want.
To run <literal>git filter-branch</literal> on all your branches, add the <literal>--all</literal> flag.</simpara>
</section>
<section xml:id="_making_a_subdirectory_the_new_root">
<title>Making a Subdirectory the New Root</title>
<simpara>Suppose you’ve done an import from another SCS and have subdirectories that make no
sense (<literal>trunk</literal>, <literal>tags</literal>, and so on).
To make the <literal>trunk</literal> subdirectory be the new project root for every commit, run <literal>git filter-branch</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten</programlisting>
<simpara>Now your new project root is what was in the <literal>trunk</literal> subdirectory.
Git also automatically removes commits that didn&#8217;t affect the subdirectory.</simpara>
</section>
<section xml:id="_changing_email_addresses_globally">
<title>Changing Email Addresses Globally</title>
<simpara>Another common case is that you forgot to run <literal>git config</literal> to set your name and email address before
you started working, or perhaps you want to open-source a project at work and change all your work
email addresses to your personal address.
In any case, you can change email addresses in multiple commits in a batch with <literal>git filter-branch</literal> as well.
Be careful to change only the email addresses that are yours, so use the <literal>--commit-filter</literal> flag.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD</programlisting>
<simpara>This rewrites every commit to contain your new email address.
Because commits contain the SHA-1 hashes of their parents, this command changes every commit SHA-1
hash in your branch, not just those that have the matching email address.</simpara>
</section>
</section>
</section>
<section xml:id="_git_reset">
<title>Reset Demystified</title>
<simpara>Before moving on to more specialized tools, let&#8217;s talk about <literal>git reset</literal> and <literal>git checkout</literal>.
These commands are two of the most confusing parts of Git when you first encounter them.
They do so many things that it seems hopeless to actually try to understand them and employ them properly.
For this, we recommend a simple metaphor.</simpara>
<section xml:id="_the_three_trees">
<title>The Three Trees</title>
<simpara>An easy way to think about <literal>git reset</literal> and <literal>git checkout</literal> is through the illusion of Git being
a content manager of three different trees. By tree we really mean a collection of files,
which we call a snapshot.</simpara>
<simpara>Git manages and manipulates these three trees.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Tree</entry>
<entry align="left" valign="top">Role</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>HEAD</simpara></entry>
<entry align="left" valign="top"><simpara>Last commit snapshot, next parent</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Index</simpara></entry>
<entry align="left" valign="top"><simpara>Proposed next commit snapshot</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Working Directory</simpara></entry>
<entry align="left" valign="top"><simpara>Sandbox</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="_head_explained">
<title>HEAD Explained</title>
<simpara><literal>HEAD</literal> is the pointer to the current branch reference, which is in turn a pointer to the last commit made
on that branch. That means <literal>HEAD</literal> is the parent of the next commit that&#8217;s created.
It&#8217;s generally simplest to think of <literal>HEAD</literal> as the snapshot of <emphasis role="strong">your last commit</emphasis>.</simpara>
<simpara>In fact, it&#8217;s pretty easy to see what that snapshot looks like.
Here&#8217;s an example showing the actual directory listing and SHA-1 hash for each file in the <literal>HEAD</literal> snapshot.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib</programlisting>
<simpara><literal>git cat-file</literal> and <literal>git ls-tree</literal> are plumbing commands used for lower level things and not
really used in day-to-day work, but they help us see what&#8217;s going on here.</simpara>
</section>
<section xml:id="_the_index">
<title>The Index</title>
<simpara>The index is your <emphasis role="strong">proposed next commit</emphasis>. We&#8217;ve also been referring to this concept as
Git&#8217;s staging area since this is where Git gets the list of files to commit when you run <literal>git commit</literal>.</simpara>
<simpara>Git populates this index with a list of all the files that were last checked out into your working
directory and what they looked like when they were originally checked out. You then modify some of
those files, and <literal>git commit</literal> converts them into a tree for a new commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb</programlisting>
<simpara>Again, here we&#8217;re running <literal>git ls-files</literal>, which shows what&#8217;s currently in the index.</simpara>
</section>
<section xml:id="_the_working_directory">
<title>The Working Directory</title>
<simpara>Finally, you have your working directory. The other two trees store their content in an efficient
but inconvenient format inside the <literal>.git</literal> folder.
The working directory is where actual files are stored, which makes them much easier to edit.
Think of the working directory as a sandbox, where you can try changes out before putting them
into the index, and then committing them into the repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files</programlisting>
</section>
</section>
<section xml:id="_the_workflow">
<title>The Workflow</title>
<simpara>Git&#8217;s main purpose is to record snapshots of your project by manipulating these three trees.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-workflow.png"/>
</imageobject>
<textobject><phrase>reset workflow</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Let&#8217;s visualize this process. Say you go into a new directory with a single file in it.
We call this <literal>v1</literal> of the file, and we indicate it in blue.
Now we run <literal>git init</literal>, which creates a Git repository with a <literal>HEAD</literal> reference that doesn&#8217;t point
to a branch yet (<literal>master</literal> doesn&#8217;t exist).</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-ex1.png"/>
</imageobject>
<textobject><phrase>reset ex1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>At this point, only the working directory tree has any content.</simpara>
<simpara>Now we want to commit this file, so we run <literal>git add</literal> to copy what&#8217;s in the working directory
into the index.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-ex2.png"/>
</imageobject>
<textobject><phrase>reset ex2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Then we run <literal>git commit</literal>, which takes the content of the index and saves it in the repository,
creates a commit, and updates <literal>master</literal> to point to that commit.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-ex3.png"/>
</imageobject>
<textobject><phrase>reset ex3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If we run <literal>git status</literal>, we see no changes, because all three trees are the same.</simpara>
<simpara>Now we want to make a change to <literal>v1</literal> of that file and commit it.
We go through almost the same process. First we change the file in our working directory.
Let&#8217;s call this <literal>v2</literal> of the file, and indicate it in red.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-ex4.png"/>
</imageobject>
<textobject><phrase>reset ex4</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If we run <literal>git status</literal> right now, we see the file in red in the <literal>Changes not staged for commit</literal>
section because the version of the file in the working directory and that in the index are different.
Next we run <literal>git add file1.txt</literal> to add <literal>v2</literal> to the index.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-ex5.png"/>
</imageobject>
<textobject><phrase>reset ex5</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>At this point <literal>git status</literal> shows the file in green
under <literal>Changes to be committed</literal> because the index and <literal>HEAD</literal> differ&#8201;&#8212;&#8201;that is,
our proposed next commit is now different from our last commit.
Finally, we run <literal>git commit</literal> to create the commit.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-ex6.png"/>
</imageobject>
<textobject><phrase>reset ex6</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Now <literal>git status</literal> shows nothing because all three trees are the same again.</simpara>
<simpara>Switching branches or cloning goes through a similar process.
When you checkout a branch, Git changes <literal>HEAD</literal> to point to the new branch, populates the index
with a snapshot of the last commit in that branch, then copies the content of the index into your working directory.</simpara>
</section>
<section xml:id="_the_role_of_reset">
<title>The Role of Reset</title>
<simpara><literal>git reset</literal> makes more sense when viewed this way.</simpara>
<simpara>For the purposes of these examples, let&#8217;s say that we&#8217;ve modified <literal>file.txt</literal> again and committed
it a third time. So now our history looks like</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-start.png"/>
</imageobject>
<textobject><phrase>reset start</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Let&#8217;s now walk through exactly what <literal>git reset</literal> does. It directly manipulates these three trees
in a simple and predictable way. It does up to three things.</simpara>
<section xml:id="_step_1_move_what_head_points_to">
<title>Step 1: Move what HEAD points to</title>
<simpara>The first thing <literal>git reset</literal> does is move what <literal>HEAD</literal> points to.
This isn&#8217;t the same as changing <literal>HEAD</literal> itself (which is what <literal>git checkout</literal> does).
<literal>git reset</literal> moves the branch that <literal>HEAD</literal> points to.
This means if <literal>HEAD</literal> points to <literal>master</literal> (i.e. you&#8217;re currently on <literal>master</literal>),
running <literal>git reset 9e5e6a4</literal> starts by making <literal>master</literal> point to <literal>9e5e6a4</literal>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-soft.png"/>
</imageobject>
<textobject><phrase>reset soft</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>No matter what form of <literal>git reset</literal> you run, this is the first thing Git always does.
If you run <literal>git reset --soft</literal>, Git simply stops there.</simpara>
<simpara>Now take a second to look at that diagram and realize what happened. This essentially undid the last commit.
When you run <literal>git commit</literal>, Git creates a new commit and moves the branch that <literal>HEAD</literal> points to
to point to the new commit. When you run <literal>git reset --soft HEAD~</literal>, you&#8217;re moving the branch to
the parent of <literal>HEAD</literal>, which is back to where it was, without changing the index or working directory.
You could now update the index and run <literal>git commit</literal> again to accomplish what <literal>git commit --amend</literal>
would do (see <xref linkend="_git_amend"/>).</simpara>
</section>
<section xml:id="_step_2_updating_the_index_mixed">
<title>Step 2: Updating the Index (--mixed)</title>
<simpara>Note that if you run <literal>git status</literal> now you see in green the difference between the index and what
the new <literal>HEAD</literal> is.</simpara>
<simpara>The next thing <literal>git reset</literal> does is to update the index with the content of whatever snapshot
<literal>HEAD</literal> now points to.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-mixed.png"/>
</imageobject>
<textobject><phrase>reset mixed</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If you specify the <literal>--mixed</literal> flag, <literal>git reset</literal> stops at this point.
This is also the default, so if you specify no flag at all (just <literal>git reset HEAD~</literal> in this case),
this is where the command stops.</simpara>
<simpara>Now take another second to look at that diagram and realize what happened. Git still undid your last commit,
but also <emphasis>unstaged</emphasis> everything.
You rolled back to the state that existed before you ran <literal>git add</literal> and <literal>git commit</literal>.</simpara>
</section>
<section xml:id="_step_3_updating_the_working_directory_hard">
<title>Step 3: Updating the Working Directory (--hard)</title>
<simpara>The third thing that <literal>git reset</literal> does is to make the working directory look like the index.
If you use the <literal>--hard</literal> flag, <literal>git reset</literal> continues to this stage.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-hard.png"/>
</imageobject>
<textobject><phrase>reset hard</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>So let&#8217;s think about what just happened.
You undid your last commit, the results of <literal>git add</literal> and <literal>git commit</literal>, <emphasis role="strong">and</emphasis> all the work you did in
your working directory.</simpara>
<simpara>It&#8217;s important to note that this flag (<literal>--hard</literal>) is the only way to make <literal>git reset</literal> dangerous,
and one of the very few cases where Git actually destroys data.
Any other invocation of <literal>git reset</literal> can be pretty easily undone, but the <literal>--hard</literal> flag can&#8217;t,
since it forcibly overwrites files in the working directory.
In this particular case, we still have the <literal>v3</literal> version of our file in a commit in our repository,
and we could get it back by doing something we&#8217;ll describe in a later chapter, but if we hadn&#8217;t committed the file,
Git still would have overwritten it, making it unrecoverable.</simpara>
</section>
<section xml:id="_recap">
<title>Recap</title>
<simpara><literal>git reset</literal> overwrites these three trees in order, stopping when you tell it.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Move the branch <literal>HEAD</literal> points to <emphasis>(stop here if <literal>--soft</literal>)</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Make the index look like <literal>HEAD</literal> <emphasis>(stop here unless <literal>--hard</literal>)</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Make the working directory look like the Index.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_reset_with_a_path">
<title>Reset With a Path</title>
<simpara>That covers the behavior of <literal>git reset</literal> in its basic form, but you can also provide it with a path.
If you do, <literal>git reset</literal> skips step 1, and limits the remainder of its actions to a specific file
or set of files. This actually sort of makes sense&#8201;&#8212;&#8201;<literal>HEAD</literal> is just a pointer, and you can&#8217;t point
to part of one commit and part of another. But the index and working directory <emphasis>can</emphasis> be partially updated,
so <literal>git reset</literal> proceeds with steps 2 and 3.</simpara>
<simpara>So, assume we run <literal>git reset file.txt</literal>.
This form (since you didn&#8217;t specify a commit SHA-1 hash or branch, and you didn&#8217;t
specify <literal>--soft</literal> or <literal>--hard</literal>) is shorthand for <literal>git reset --mixed HEAD file.txt</literal>, which</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Moves the branch <literal>HEAD</literal> points to <emphasis>(skipped)</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Makes the index look like <literal>HEAD</literal> <emphasis>(stop here)</emphasis>.</simpara>
</listitem>
</orderedlist>
<simpara>So it essentially just copies <literal>file.txt</literal> from <literal>HEAD</literal> to the index.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-path1.png"/>
</imageobject>
<textobject><phrase>reset path1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This has the practical effect of <emphasis>unstaging</emphasis> the file.
If we look at the diagram and think about what <literal>git add</literal> does, they&#8217;re exact opposites.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-path2.png"/>
</imageobject>
<textobject><phrase>reset path2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This is why the output of <literal>git status</literal> suggests that you run this to unstage a file.
(See <xref linkend="_unstaging"/> for more on this.)</simpara>
<simpara>We could just as easily not let Git assume we mean "pull the data from <literal>HEAD</literal>" by specifying a
specific commit to pull that file version from.
We&#8217;d just run something like <literal>git reset eb43bf file.txt</literal>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-path3.png"/>
</imageobject>
<textobject><phrase>reset path3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This effectively does the same thing as if we had reverted the content of the file to <literal>v1</literal> in the
working directory, ran <literal>git add</literal> on it, then reverted it back to <literal>v3</literal> again (without actually going
through all those steps). If we run <literal>git commit</literal> now, it records a commit that reverts that file
back to <literal>v1</literal>, even though we never actually had it in our working directory again.</simpara>
<simpara>It&#8217;s also interesting to note that like <literal>git add</literal>, <literal>git reset</literal> accepts a <literal>--patch</literal> flag to
unstage content on a hunk-by-hunk basis. So you can selectively unstage or revert content.</simpara>
</section>
<section xml:id="_squashing_2">
<title>Squashing</title>
<simpara>Let&#8217;s look at how to do something interesting with this newfound power&#8201;&#8212;&#8201;squashing commits.</simpara>
<simpara>Maybe you have a series of commits with messages like <literal>oops.</literal>, <literal>WIP</literal>, and <literal>forgot this file</literal>.
Run <literal>git reset</literal> to quickly and easily squash them into a single commit that makes you look really smart.
(<xref linkend="_squashing"/> shows another way to do this, but in this example it&#8217;s simpler to run <literal>git reset</literal>.)</simpara>
<simpara>Let&#8217;s say you have a project where the first commit contained one file, the second commit added a new file
and changed the first, and the third commit changed the first file again.
The second commit was a work in progress and you want to squash it.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-squash-r1.png"/>
</imageobject>
<textobject><phrase>reset squash r1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Run <literal>git reset --soft HEAD~2</literal> to move the <literal>HEAD</literal> branch back to an older commit (the first commit you
want to keep).</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-squash-r2.png"/>
</imageobject>
<textobject><phrase>reset squash r2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>And then simply run <literal>git commit</literal> again.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-squash-r3.png"/>
</imageobject>
<textobject><phrase>reset squash r3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You see that your reachable history, the history you would push, now looks like you had
one commit with <literal>file-a.txt</literal> <literal>v1</literal>, then a second that both modified <literal>file-a.txt</literal> to <literal>v3</literal> and
added <literal>file-b.txt</literal>. The commit with the <literal>v2</literal> version of the file is no longer in the history.</simpara>
</section>
<section xml:id="_check_it_out">
<title>Check It Out</title>
<simpara>Finally, you may wonder what the difference is between <literal>git checkout</literal> and <literal>git reset</literal>.
Like <literal>git reset</literal>, <literal>git checkout</literal> manipulates the three trees, and it works differently depending
on whether you give the command a path.</simpara>
<section xml:id="_without_paths">
<title>Without Paths</title>
<simpara>Running <literal>git checkout [branch]</literal> is pretty similar to running <literal>git reset --hard [branch]</literal> in
that it updates all three trees to look like <literal>[branch]</literal>, but there are two important differences.</simpara>
<simpara>First, unlike <literal>git reset --hard</literal>, <literal>git checkout</literal> is working directory safe. It checks to make sure it&#8217;s
not blowing away files that contain changes. Actually, it&#8217;s a bit smarter than that&#8201;&#8212;&#8201;it tries
to do a trivial merge in the working directory, so all of the files you <emphasis>haven&#8217;t</emphasis> changed are updated.
<literal>git reset --hard</literal>, on the other hand, simply replaces everything across the board without checking.</simpara>
<simpara>The second important difference is how <literal>git checkout</literal> updates <literal>HEAD</literal>.
Where <literal>git reset</literal> moves the branch that <literal>HEAD</literal> points to, <literal>git checkout</literal> moves <literal>HEAD</literal> itself to
point to another branch.</simpara>
<simpara>For instance, say we have <literal>master</literal> and <literal>develop</literal> which point to different commits, and we&#8217;re
currently on <literal>develop</literal> (so <literal>HEAD</literal> points to it). If we run <literal>git reset master</literal>, <literal>develop</literal> itself now
points to the same commit as <literal>master</literal>. If we instead run <literal>git checkout master</literal>, <literal>develop</literal> doesn&#8217;t
move but <literal>HEAD</literal> does, which now points to <literal>master</literal>.</simpara>
<simpara>So, in both cases we&#8217;re moving <literal>HEAD</literal> to point to commit A, but <emphasis>how</emphasis> we do so is very different.
<literal>git reset</literal> moves the branch <literal>HEAD</literal> points to, whereas <literal>git checkout</literal> moves <literal>HEAD</literal> itself.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/reset-checkout.png"/>
</imageobject>
<textobject><phrase>reset checkout</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_with_paths">
<title>With Paths</title>
<simpara>The other way to run <literal>git checkout</literal> is with a path, which, like <literal>git reset</literal>, doesn&#8217;t move <literal>HEAD</literal>.
It&#8217;s just like <literal>git reset [branch] file</literal> in that it updates the index with that file, but it also
overwrites the file in the working directory. It would be exactly like <literal>git reset --hard [branch] file</literal>
(if <literal>git reset</literal> would let you do that)&#8201;&#8212;&#8201;it&#8217;s not working-directory safe, and it doesn&#8217;t move <literal>HEAD</literal>.</simpara>
<simpara>Also, like <literal>git reset</literal> and <literal>git add</literal>, <literal>git checkout</literal> accepts a <literal>--patch</literal> flag to allow you to
selectively revert file content on a hunk-by-hunk basis.</simpara>
</section>
</section>
<section xml:id="_summary_8">
<title>Summary</title>
<simpara>Hopefully now you understand and feel more comfortable with <literal>git reset</literal>, but you&#8217;re probably still a
little confused about exactly how it differs from <literal>git checkout</literal>. Plus, you&#8217;re probably feeling
that you couldn&#8217;t possibly remember all the rules of the different invocations.</simpara>
<simpara>Here&#8217;s a cheat-sheet showing which commands affect which trees.
The <literal>HEAD</literal> column contains <literal>REF</literal> if that command moves the reference (branch) that <literal>HEAD</literal> points to,
and <literal>HEAD</literal> if it moves <literal>HEAD</literal> itself.
Pay especial attention to the <literal>wd safe?</literal> column&#8201;&#8212;&#8201;if it contains <emphasis role="strong">NO</emphasis>, take a second to think
before running that command.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="42.8571*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="14.2857*"/>
<colspec colname="col_4" colwidth="14.2857*"/>
<colspec colname="col_5" colwidth="14.2858*"/>
<thead>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top">HEAD</entry>
<entry align="left" valign="top">Index</entry>
<entry align="left" valign="top">Workdir</entry>
<entry align="left" valign="top">WD Safe?</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Commit Level</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>reset --soft [commit]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>REF</simpara></entry>
<entry align="left" valign="top"><simpara>NO</simpara></entry>
<entry align="left" valign="top"><simpara>NO</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>reset [commit]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>REF</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
<entry align="left" valign="top"><simpara>NO</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>reset --hard [commit]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>REF</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">NO</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>checkout &lt;commit&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>HEAD</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">File Level</emphasis></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>reset [commit] &lt;paths&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>NO</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
<entry align="left" valign="top"><simpara>NO</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>checkout [commit] &lt;paths&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>NO</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
<entry align="left" valign="top"><simpara>YES</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">NO</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_advanced_merging">
<title>Advanced Merging</title>
<simpara>Merging in Git is typically fairly easy. Since Git makes it easy to merge branches multiple times,
it means that you can have a very long lived branch that you keep up to date as you go,
solving small conflicts often, rather than being surprised by one enormous conflict when you&#8217;re
done with the branch.</simpara>
<simpara>However, sometimes tricky conflicts do occur. Unlike some other VCSs, Git doesn&#8217;t try to be overly
clever about merge conflict resolution. Git&#8217;s philosophy is to be smart about determining when a
merge resolution is unambiguous. But, if there&#8217;s a conflict, Git doesn&#8217;t try to be clever by
automatically resolving it. Therefore, if you wait too long to merge branches that diverge,
you can quickly run into issues.</simpara>
<simpara>In this section, we go over what some of those issues might be and what tools Git provides to help
handle these tricky situations. We also cover some of the different, non-standard types of merges,
as well as see how to back out of merges that didn&#8217;t work out right.</simpara>
<section xml:id="_merge_conflicts">
<title>Merge Conflicts</title>
<simpara>While we covered the basics of resolving merge conflicts in <xref linkend="_basic_merge_conflicts"/>,
for more complex conflicts Git provides a few tools to help you figure out what&#8217;s going on and how
to better deal with the conflicts.</simpara>
<simpara>First of all, if at all possible, make sure your working directory is clean before doing a merge
that may have conflicts. If you have work in progress, either commit it to a temporary branch or stash it.
This makes it so that you can undo <emphasis role="strong">anything</emphasis> you try. If you have unsaved changes in your
working directory when you try a merge, some of these tips may result in preserving that work.</simpara>
<simpara>Let&#8217;s walk through a very simple example. We have a super simple Ruby program that prints <emphasis>hello world</emphasis>.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()</programlisting>
<simpara>We create a new branch named <literal>whitespace</literal> and proceed to change all the Unix line endings (LF)
to DOS line endings (CRLF), essentially changing every line of the file, but just with whitespace changes.
Then we change the line <literal>hello world</literal> to <literal>hello mundo</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)</programlisting>
<simpara>Now we switch back to <literal>master</literal> and add some documentation.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'document the function'
[master bec6336] document the function
 1 file changed, 1 insertion(+)</programlisting>
<simpara>Now we try to merge <literal>whitespace</literal> and we get conflicts because of the whitespace changes.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</programlisting>
<section xml:id="_abort_merge">
<title>Aborting a Merge</title>
<simpara>We now have a few options. First, let&#8217;s cover how to get out of this situation.
If you perhaps weren&#8217;t expecting conflicts and don&#8217;t want to deal with the situation yet,
simply back out of the merge with by running <literal>git merge --abort</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master</programlisting>
<simpara><literal>git merge --abort</literal> tries to revert back to the state that existed before you ran the merge.
The only cases where it might not work would be if you had unstashed uncommitted changes in your
working directory. Otherwise it should work fine.</simpara>
<simpara>If, for some reason, you just want to start over, you can also run <literal>git reset --hard HEAD</literal>,
and your repository is back to the last committed state. Remember that any uncommitted work is lost.</simpara>
</section>
<section xml:id="_ignoring_whitespace">
<title>Ignoring Whitespace</title>
<simpara>In this specific case, the conflicts are whitespace related. We know this because we deliberately
created the conflicts, but it&#8217;s also pretty easy to tell in real cases when looking at the conflicts
because every line is removed on one side and added again on the other. By default, Git sees all
of these lines as changed, so it can&#8217;t merge the files.</simpara>
<simpara>The default merge strategy can take arguments though, and a few of them handle ignoring whitespace changes.
If you see that you have a lot of whitespace issues in a merge, simply abort it and do it again,
this time running <literal>git merge</literal> with either <literal>-Xignore-all-space</literal> or <literal>-Xignore-space-change</literal>.
The first flag ignores whitespace <emphasis role="strong">completely</emphasis> when comparing lines.
The second treats sequences of one or more whitespace characters as equivalent.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</programlisting>
<simpara>Since in this case the actual file changes didn&#8217;t conflict, once we ignore the whitespace changes,
everything merges just fine.</simpara>
<simpara>This is a lifesaver if you have someone on your team who likes to occasionally reformat everything
from spaces to tabs, or vice-versa.</simpara>
</section>
<section xml:id="_manual_remerge">
<title>Manual File Re-merging</title>
<simpara>Though Git handles whitespace changes pretty well, there are other types of changes that perhaps Git
can&#8217;t handle automatically, but for which there are scriptable fixes. As an example,
let&#8217;s pretend that Git couldn&#8217;t handle the whitespace change and we need to resolve it by hand.</simpara>
<simpara>What we really need to do is run the file we&#8217;re trying to merge through a <literal>dos2unix</literal> program before
trying the actual file merge. How would we do that?</simpara>
<simpara>First, we get into the merge conflict state. Then we get copies of my version of the file,
the other version (from the branch we&#8217;re merging in), and the common version (from where both
sides branched off). Then we fix up either the other side or our side and try the merge
again for just this single file.</simpara>
<simpara>Getting the three file versions is actually pretty easy. Git stores all of these versions
in stages which each have a number associated with them.
Stage 1 is the common ancestor, stage 2 is your version, and stage 3 is from the <literal>MERGE_HEAD</literal>,
the version you&#8217;re merging in (<literal>theirs</literal>).</simpara>
<simpara>You can extract a copy of each of these versions of the conflicted file by running <literal>git show</literal> and
using a special syntax.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb</programlisting>
<simpara>To get a little more hard core, you can also run <literal>git ls-files -u</literal> to get the actual SHA-1 hashes of each file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</programlisting>
<simpara><literal>:1:hello.rb</literal> is just a shorthand for looking up that file&#8217;s SHA-1 hash.</simpara>
<simpara>Now that we have the content of all three stages in our working directory, we can manually
fix up the whitespace issue and re-merge the file by running the little-known <literal>git merge-file</literal> command
which does just that.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()</programlisting>
<simpara>At this point we&#8217;ve nicely merged the file. In fact, this actually works better than
the <literal>-Xignore-space-change</literal> flag because this actually fixes the whitespace changes before
the merge instead of simply ignoring them. In the <literal>-Xignore-space-change</literal> merge, we actually
ended up with a few lines with DOS line endings.</simpara>
<simpara>To get an idea before finalizing this commit about what was actually changed between one side
or the other, run <literal>git diff</literal> to compare what&#8217;s in your working director that you&#8217;re about to commit
as the result of the merge, to any of these stages. Let&#8217;s go through them all.</simpara>
<simpara>To compare your result to what you had in your branch before the merge (to see what
the merge introduced) run <literal>git diff --ours</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</programlisting>
<simpara>Here we easily see what happened in our branch. What we&#8217;re actually introducing to this file
with this merge is a chang to that single line.</simpara>
<simpara>To see how the result of the merge differs from what was on their side, run <literal>git diff --theirs</literal>.
In this and the following example, include the <literal>-b</literal> flag to strip out the whitespace because we&#8217;re comparing
it to what&#8217;s in the repository, not to what&#8217;s in our cleaned up <literal>hello.theirs.rb</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end</programlisting>
<simpara>Finally, see how the file has changed from both sides by running <literal>git diff --base</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</programlisting>
<simpara>At this point we can run <literal>git clean</literal> to clear out the extra files we created to do the manual
merge but no longer need.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb</programlisting>
</section>
<section xml:id="_checking_out_conflicts">
<title>Checking Out Conflicts</title>
<simpara>Perhaps we&#8217;re not happy with the resolution at this point for some reason, or maybe manually editing
one or both sides still didn&#8217;t work well and we need more context.</simpara>
<simpara>Let&#8217;s change the example. For this example, we have two longer lived branches that each have a few
commits in them but create a legitimate conflict when merged.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code</programlisting>
<simpara>We now have three unique commits that live only on <literal>master</literal> and three others that live on <literal>mundo</literal>.
If we try to merge <literal>mundo</literal>, we get a conflict.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</programlisting>
<simpara>We&#8217;d like to see the merge conflict. If we open the file, we see something like</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
end

hello()</programlisting>
<simpara>Both sides of the merge added content to this file, but some of the commits modified the file in
the same place, causing the conflict.</simpara>
<simpara>Let&#8217;s explore a couple of tools to determine how this conflict came to be.
Perhaps it&#8217;s not obvious how exactly you should fix it. You need more context.</simpara>
<simpara>One helpful tool is <literal>git checkout</literal> with the <literal>--conflict</literal> flag. This re-checksout the file
and replaces the merge conflict markers. This can be useful to reset the markers to try
resolving the conflicts again.</simpara>
<simpara>You can pass the <literal>--conflict</literal> flag either <literal>diff3</literal> or <literal>merge</literal> (the default). If you pass <literal>diff3</literal>,
Git uses a slightly different version of conflict markers, not only giving you the <literal>ours</literal>
and <literal>theirs</literal> versions, but also the <literal>base</literal> version inline for more context.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout --conflict=diff3 hello.rb</programlisting>
<simpara>Once we run that, the file looks like this instead.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end

hello()</programlisting>
<simpara>If you like this format, set it as the default for future merge conflicts by setting
the <literal>merge.conflictstyle</literal> setting to <literal>diff3</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global merge.conflictstyle diff3</programlisting>
<simpara><literal>git checkout</literal> can also take the <literal>--ours</literal> and <literal>--theirs</literal> flags, which can be a really fast way
of choosing just one side or the other without merging at all.</simpara>
<simpara>This can be particularly useful for conflicts of binary files where you can simply choose one side,
or where you only want to merge certain files from another branch.
You can do the merge and then checkout certain files from one side or the other before committing.</simpara>
</section>
<section xml:id="_merge_log">
<title>Merge Log</title>
<simpara>Another useful tool when resolving merge conflicts is <literal>git log</literal>.
This can help show context on what may have contributed to the conflicts.
Reviewing a little bit of history to remember why two lines of development were touching the same
area of code can be really helpful.</simpara>
<simpara>To see a full list of all of the unique commits included in either branch involved in this merge,
use the <literal>triple dot</literal> syntax we learned in <xref linkend="_triple_dot"/>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 update README
&lt; 9af9d3b add a README
&lt; 694971d update phrase to hola world
&gt; e3eb223 add more tests
&gt; 7cff591 add testing script
&gt; c3ffff1 changed text to hello mundo</programlisting>
<simpara>That&#8217;s a nice list of all six commits involved, as well as which line of development each commit was on.</simpara>
<simpara>We can further simplify this to give much more specific context. If we add the <literal>--merge</literal> flag to <literal>git log</literal>,
it only shows the commits in either side of the merge that touch a file that&#8217;s currently conflicted.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline --left-right --merge
&lt; 694971d update phrase to hola world
&gt; c3ffff1 changed text to hello mundo</programlisting>
<simpara>If you run that with the <literal>-p</literal> flag instead, you see just the diffs to the file that ended up in conflict.
This can be <emphasis role="strong">really</emphasis> helpful in quickly showing the context you need to help understand why
something conflicts and how to more intelligently resolve it.</simpara>
</section>
<section xml:id="_combined_diff_format">
<title>Combined Diff Format</title>
<simpara>Since Git stages any successful merge results, when you run <literal>git diff</literal> while in a conflicted merge state,
you only see what&#8217;s currently still in conflict. This can help show what you still have to resolve.</simpara>
<simpara>When you run <literal>git diff</literal> right after a merge conflict, you see information in a rather unique diff output
format.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</programlisting>
<simpara>The format is called <literal>Combined Diff</literal>, and includes two columns of data at the beginning of each line.
The first column shows if that line is different (added or removed) between <literal>ours</literal> and the file in
your working directory. The second column does the same between <literal>theirs</literal> and your working directory copy.</simpara>
<simpara>So, in that example you see that the <literal>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</literal> and <literal>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</literal> lines are in the working directory copy but aren&#8217;t
in either side of the merge. This makes sense because the merge tool stuck them in there to show
the conflicts, but we&#8217;re expected to remove them.</simpara>
<simpara>If we resolve the conflicts and run <literal>git diff</literal> again, we see the same thing, but it&#8217;s a little more useful.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</programlisting>
<simpara>This shows that <literal>hola world</literal> was in our side but not in the working copy, that <literal>hello mundo</literal> was
in their side but not in the working copy, and finally that <literal>hola mundo</literal> wasn&#8217;t in either side
but is now in the working directory copy. This can be useful to review before committing the resolution.</simpara>
<simpara>You also get this from <literal>git log</literal> for any merge to see how something was resolved after the fact.
Git outputs this format if you run <literal>git show</literal> on a merge commit, or if you add a <literal>--cc</literal> flag
to <literal>git log -p</literal> (which by default only shows patches for non-merge commits).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</programlisting>
</section>
</section>
<section xml:id="_undoing_merges">
<title>Undoing Merges</title>
<simpara>Now that you know how to create a merge commit, what happens if you make a mistake making one?
One of the great things about working with Git is that it&#8217;s OK to make mistakes,
because it&#8217;s possible (and in many cases easy) to fix them.</simpara>
<simpara>Merge commits are no different.
Let&#8217;s say you start working on a topic branch and accidentally merge it into <literal>master</literal>.
Now your commit history looks like</simpara>
<figure>
<title>Accidental merge commit</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/undomerge-start.png"/>
</imageobject>
<textobject><phrase>Accidental merge commit.</phrase></textobject>
</mediaobject>
</figure>
<simpara>There are two ways to approach this problem, depending on your desired outcome.</simpara>
<section xml:id="_fix_the_references">
<title>Fix the references</title>
<simpara>If the unwanted merge commit only exists on your local repository, the easiest and best
solution is to move the branches to point where you want them to.
In most cases, if you follow the errant <literal>git merge</literal> with <literal>git reset --hard HEAD~</literal>,
this resets the branch pointers so they look like</simpara>
<figure>
<title>History after <literal>git reset --hard HEAD~</literal></title>
<mediaobject>
<imageobject>
<imagedata fileref="images/undomerge-reset.png"/>
</imageobject>
<textobject><phrase>History after `git reset --hard HEAD~`.</phrase></textobject>
</mediaobject>
</figure>
<simpara>We covered <literal>reset</literal> back in <xref linkend="_git_reset"/>, so it shouldn&#8217;t be too hard to
figure out what&#8217;s going on here. Here&#8217;s a quick refresher.</simpara>
<simpara><literal>reset --hard</literal> performs the following three steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Move the branch <literal>HEAD</literal> points to.
In this case, move <literal>master</literal> to where it was before the merge commit (<literal>C6</literal>).</simpara>
</listitem>
<listitem>
<simpara>Make the index look like <literal>HEAD</literal>.</simpara>
</listitem>
<listitem>
<simpara>Make the working directory look like what&#8217;s in the index.</simpara>
</listitem>
</orderedlist>
<simpara>The downside of this approach is that it&#8217;s rewriting history, which can be problematic with a shared repository.</simpara>
<simpara>Check out <xref linkend="_rebase_peril"/> for more on what can happen.
The short version is that if other people&#8217;s repositories have the commits you&#8217;re rewriting,
you should probably avoid <literal>git reset</literal>.
This approach also doesn&#8217;t work if any other commits have been created since the merge,
which you&#8217;d effectively lose.</simpara>
</section>
<section xml:id="_reverse_commit">
<title>Reverse the commit</title>
<simpara>If moving the branch pointers around isn&#8217;t going to work, Git lets you make a new commit which
undoes all the changes in an existing commit.
Git calls this operation a <literal>revert</literal>, and in this particular scenario, you invoke it by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"</programlisting>
<simpara>The <literal>-m 1</literal> flag indicates which parent is the <literal>mainline</literal> and should be kept.
When you invoke a merge into <literal>HEAD</literal> (<literal>git merge topic</literal>), the new commit has two parents&#8201;&#8212;&#8201;the first
one is <literal>HEAD</literal> (<literal>C6</literal>), and the second is the tip of the branch being merged (<literal>C4</literal>).
In this case, we want to undo all the changes introduced by merging parent #2 (<literal>C4</literal>),
while keeping all the content from parent #1 (<literal>C6</literal>).</simpara>
<simpara>The history with the revert commit looks like</simpara>
<figure>
<title>History after <literal>git revert -m 1</literal></title>
<mediaobject>
<imageobject>
<imagedata fileref="images/undomerge-revert.png"/>
</imageobject>
<textobject><phrase>History after `git revert -m 1`.</phrase></textobject>
</mediaobject>
</figure>
<simpara>The new commit <literal>^M</literal> has exactly the same content as <literal>C6</literal>,
so starting from here is as if the merge never happened,
except that the now-unmerged commits are still there.
Git gets confused if you try to merge <literal>topic</literal> into <literal>master</literal> again.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge topic
Already up-to-date.</programlisting>
<simpara>There&#8217;s nothing in <literal>topic</literal> that isn&#8217;t already reachable from <literal>master</literal>.
What&#8217;s worse, if you add work to <literal>topic</literal> and merge again, Git only brings in the changes <emphasis>since</emphasis> the
reverted merge.</simpara>
<figure>
<title>History with a bad merge</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/undomerge-revert2.png"/>
</imageobject>
<textobject><phrase>History with a bad merge.</phrase></textobject>
</mediaobject>
</figure>
<simpara>The best way around this is to un-revert the original merge, since now you want to bring in the
changes that were reverted, <emphasis role="strong">then</emphasis> create a new merge commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic</programlisting>
<figure>
<title>History after re-merging a reverted merge</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/undomerge-revert3.png"/>
</imageobject>
<textobject><phrase>History after re-merging a reverted merge.</phrase></textobject>
</mediaobject>
</figure>
<simpara>In this example, <literal>M</literal> and <literal>^M</literal> cancel out.
<literal>^^M</literal> effectively merges in the changes from <literal>C3</literal> and <literal>C4</literal>, and <literal>C8</literal> merges the changes from <literal>C7</literal>,
so now <literal>topic</literal> is fully merged.</simpara>
</section>
</section>
<section xml:id="_other_types_of_merges">
<title>Other Types of Merges</title>
<simpara>So far we&#8217;ve covered the normal merge of two branches, normally handled with what&#8217;s called
the <literal>recursive</literal> strategy of merging. There are also other ways to merge branches. Let&#8217;s cover a few of them.</simpara>
<section xml:id="_our_or_theirs_preference">
<title>Our or Theirs Preference</title>
<simpara>First of all, there&#8217;s another useful thing we can do with the normal <literal>recursive</literal> strategy.
We&#8217;ve already seen the <literal>-Xignore-all-space</literal> and <literal>-Xignore-space-change</literal> flags but we can also tell
Git to favor one side or the other when it sees a conflict.</simpara>
<simpara>By default, when Git sees a conflict when merging two branches, it adds merge conflict markers into your
file and marks it as conflicted for you to resolve. If you&#8217;d prefer for Git to simply choose a
specific side and ignore the other side instead of letting you manually resolve the conflict,
pass <literal>git merge</literal> either  <literal>-Xours</literal> or <literal>-Xtheirs</literal>.</simpara>
<simpara>In this case, Git doesn&#8217;t add conflict markers. Any differences that are mergeable, it merges.
If any differences conflict, it simply completely chooses the side you specify, including binary files.</simpara>
<simpara>If we go back to the <literal>hello world</literal> example we were using before, we see that merging our branch
causes conflicts.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.</programlisting>
<simpara>However if we run <literal>git merge</literal> with <literal>-Xours</literal> or <literal>-Xtheirs</literal> it doesn&#8217;t.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</programlisting>
<simpara>In that case, instead of putting conflict markers in the file with <literal>hello mundo</literal> on one side
and <literal>hola world</literal> on the other, it simply picks <literal>hola world</literal>. However, all the other non-conflicting
changes on that branch are successfully merged in.</simpara>
<simpara>This option can also be passed to <literal>git merge-file</literal>, as we saw earlier, by running something
like <literal>git merge-file --ours</literal> for individual file merges.</simpara>
<simpara>To do something like this but not have Git even try to merge changes from the other side,
there&#8217;s a more draconian option, which is the <literal>ours</literal> merge <emphasis>strategy</emphasis>. This is different from
the <literal>ours</literal> recursive merge <emphasis>option</emphasis>.</simpara>
<simpara>This basically does a fake merge. It records a new merge commit with both branches as parents,
but it doesn&#8217;t even look at the branch you&#8217;re merging. It simply records the exact code in your
current branch as the result of the merge.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$</programlisting>
<simpara>You can see that there&#8217;s no difference between the branch we were on and the result of the merge.</simpara>
<simpara>This can often be useful to basically trick Git into thinking that a branch is already merged
when doing a merge later on. For example, say you branched off <literal>release</literal> and you&#8217;ve done some work
on it that you want to merge back into <literal>master</literal> at some point. In the meantime, a bugfix
on <literal>master</literal> needs to be backported into <literal>release</literal>. You can merge the bugfix branch into <literal>release</literal> and
also run <literal>git merge -s ours</literal> the same branch into <literal>master</literal> (even though the fix is already there)
so when you later merge <literal>release</literal> again, there are no conflicts from the bugfix.</simpara>
</section>
<section xml:id="_subtree_merge">
<title>Subtree Merging</title>
<simpara>The idea of the subtree merge is that you have two projects, and one of the projects maps
to a subdirectory of the other one. When you specify a subtree merge, Git is often smart
enough to figure out that one is a subtree of the other, and merge appropriately.</simpara>
<simpara>We go through an example of adding a separate project into an existing project and then merging
the code of the second into a subdirectory of the first.</simpara>
<simpara>First, we add the Rack project as a remote reference in our own project and then check it out into its own branch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"</programlisting>
<simpara>Now we have the root of the Rack project in <literal>rack_branch</literal> and our own project in <literal>master</literal>.
If you check out one and then the other, you can see that they have different top-level directories.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README</programlisting>
<simpara>This is sort of a strange concept. Not all the branches in your repository actually have to be
branches of the same project. It&#8217;s not common, because it&#8217;s rarely helpful, but it&#8217;s
fairly easy to have branches contain completely different histories.</simpara>
<simpara>In this case, we want to pull the Rack project into our <literal>master</literal> project as a subdirectory.
We can do that by running <literal>git read-tree</literal>.
You learn more about <literal>git read-tree</literal> and its friends in <xref linkend="_git_internals"/>, but for now
know that it reads the root tree of one branch into your current staging area and working directory.
We just switch back to your <literal>master</literal>, and pull <literal>rack_branch</literal> into the <literal>rack</literal> subdirectory of
our <literal>master</literal> of our main project.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git read-tree --prefix=rack/ -u rack_branch</programlisting>
<simpara>When we commit, it looks like we have all the Rack files under that subdirectory&#8201;&#8212;&#8201;as though
we copied them from a tarball. What gets interesting is that we can fairly easily merge
changes from one of the branches to the other.
So, if the Rack project is updated, we can pull in upstream changes by switching to that branch and pulling.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout rack_branch
$ git pull</programlisting>
<simpara>Then, we can merge those changes back into our <literal>master</literal>.
To pull in the changes and prepopulate the commit message, run <literal>git merge</literal> with the <literal>--squash</literal> flag,
as well as the recursive merge strategy&#8217;s <literal>-Xsubtree</literal> flag. (The recursive strategy is the default here,
but we include it for clarity.)</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</programlisting>
<simpara>All the changes from the Rack project are merged and ready to be committed locally.
You can also do the opposite&#8201;&#8212;&#8201;make changes in the <literal>rack</literal> subdirectory of your <literal>master</literal> and then
merge them into your <literal>rack_branch</literal> later to submit them to the maintainers or push them upstream.</simpara>
<simpara>This is a way to have a workflow somewhat similar to the submodule workflow without using submodules
(which we cover in <xref linkend="_git_submodules"/>).
We can keep branches with other related projects in our repository and occasionally subtree merge
them into our project. It&#8217;s nice in some ways, for example all the code is committed to a single place.
However, it has other drawbacks in that it&#8217;s a bit more complex and easier to make mistakes in
reintegrating changes or accidentally pushing a branch into an unrelated repository.</simpara>
<simpara>Another slightly weird thing is that to get a diff between what you have in your <literal>rack</literal> subdirectory
and what you have in your <literal>rack_branch</literal>&#8201;&#8212;&#8201;to see if you need to merge them&#8201;&#8212;&#8201;you can’t run
the normal <literal>git diff</literal>.
Instead, you must run <literal>git diff-tree</literal> with the branch you want to compare to.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff-tree -p rack_branch</programlisting>
<simpara>Or, to compare what&#8217;s in your <literal>rack</literal> subdirectory with what <literal>master</literal> was on the server
the last time you fetched, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff-tree -p rack_remote/master</programlisting>
</section>
</section>
</section>
<section xml:id="ref_rerere">
<title>Rerere</title>
<simpara><literal>git rerere</literal> is a bit of a hidden feature. The name stands for <literal>reuse recorded resolution</literal> and,
as the name implies, it allows Git to remember how you resolved a hunk conflict before so that the next
time Git sees the same conflict, Git can automatically resolve it.
There are a number of scenarios in which this might be really handy. One of the examples that&#8217;s
mentioned in the documentation is to make sure a long lived topic branch merges cleanly but you don&#8217;t
want to have a bunch of intermediate merge commits. With <literal>rerere</literal> enabled you can merge occasionally,
resolve the conflicts, then back out the merge. If you do this continuously, the final merge
should then be easy because <literal>git rerere</literal> can do everything for you automatically.</simpara>
<simpara>This same tactic can be used to keep a branch rebased so you don&#8217;t have to deal with the same
rebasing conflicts each time. Or if you take a branch that you merged that required a bunch of
conflicts to be fixed and then decide to rebase it instead&#8201;&#8212;&#8201;you likely don&#8217;t have to resolve
all the same conflicts again. Another situation is when you occasionally merge a bunch of evolving
topic branches into a test branch, as the Git project itself often does. If the tests fail, you can
rewind the merges and re-do them without the topic branch that made the tests fail and without having
to re-resolve the conflicts again.</simpara>
<simpara>To enable <literal>git rerere</literal>, simply run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global rerere.enabled true</programlisting>
<simpara>You can also turn it on by creating the <literal>.git/rr-cache</literal> directory in a specific repository,
but modifying the config setting is clearer and can be done globally.</simpara>
<simpara>Now let&#8217;s see a simple example, similar to our previous one. Let&#8217;s say we have a file named
<literal>hello.rb</literal> that looks like</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end</programlisting>
<simpara>In one branch we change <literal>hello</literal> to <literal>hola</literal>, then in another branch we change <literal>world</literal> to <literal>mundo</literal>,
just like before.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/rerere1.png"/>
</imageobject>
<textobject><phrase>rerere1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>When we merge the two branches, we get a merge conflict.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge i18n-world
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Recorded preimage for 'hello.rb'
Automatic merge failed; fix conflicts and then commit the result.</programlisting>
<simpara>You should notice the line <literal>Recorded preimage for FILE</literal>. Otherwise the output should look exactly
like a normal merge conflict. At this point, <literal>git rerere</literal> can tell us a few things. Normally,
you&#8217;d run <literal>git status</literal> now to see what conflicted.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
# On branch master
# Unmerged paths:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#   (use "git add &lt;file&gt;..." to mark resolution)
#
#	both modified:      hello.rb
#</programlisting>
<simpara>However, <literal>git rerere status</literal> also tells you the file for which it recorded the pre-merge state.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rerere status
hello.rb</programlisting>
<simpara><literal>git rerere diff</literal> shows the current state of the resolution&#8201;&#8212;&#8201;what you started with to resolve
and what you&#8217;ve resolved it to.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,11 @@
 #! /usr/bin/env ruby

 def hello
-&lt;&lt;&lt;&lt;&lt;&lt;&lt;
-  puts 'hello mundo'
-=======
+&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
   puts 'hola world'
-&gt;&gt;&gt;&gt;&gt;&gt;&gt;
+=======
+  puts 'hello mundo'
+&gt;&gt;&gt;&gt;&gt;&gt;&gt; i18n-world
 end</programlisting>
<simpara>Also (this isn&#8217;t really related to <literal>git rerere</literal>), run <literal>git ls-files -u</literal> to see the conflicted
files and the before, left, and right versions.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git ls-files -u
100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1	hello.rb
100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2	hello.rb
100644 54336ba847c3758ab604876419607e9443848474 3	hello.rb</programlisting>
<simpara>Now resolve the conflict to just be <literal>puts 'hola mundo'</literal>,
and run <literal>git rerere diff</literal> again to see what Git remembers.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-&lt;&lt;&lt;&lt;&lt;&lt;&lt;
-  puts 'hello mundo'
-=======
-  puts 'hola world'
-&gt;&gt;&gt;&gt;&gt;&gt;&gt;
+  puts 'hola mundo'
 end</programlisting>
<simpara>That basically says when Git sees a hunk conflict in <literal>hello.rb</literal> that has <literal>hello mundo</literal> on one side
and <literal>hola world</literal> on the other, Git resolves the conflict to <literal>hola mundo</literal>.</simpara>
<simpara>Now we can mark it as resolved and commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add hello.rb
$ git commit
Recorded resolution for 'hello.rb'.
[master 68e16e5] Merge branch 'i18n'</programlisting>
<simpara>You can see that it "Recorded resolution for <emphasis>hello.rb</emphasis>".</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/rerere2.png"/>
</imageobject>
<textobject><phrase>rerere2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Now, let&#8217;s undo that merge and then rebase it on top of <literal>master</literal> instead.
We move our branch back by running <literal>git reset</literal>, as we saw in <xref linkend="_git_reset"/>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git reset --hard HEAD^
HEAD is now at ad63f15 i18n the hello</programlisting>
<simpara>Our merge is undone. Now let&#8217;s rebase the topic branch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout i18n-world
Switched to branch 'i18n-world'

$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: i18n one word
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Failed to merge in the changes.
Patch failed at 0001 i18n one word</programlisting>
<simpara>We got the same merge conflict we expected, but take a look at the <literal>Resolved 'hello.rb' using previous resolution</literal>
line. If we look at the file, we see that it&#8217;s already been resolved, and there are no merge conflict
markers in it.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end</programlisting>
<simpara>Also, <literal>git diff</literal> shows how the conflict was automatically re-resolved.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff
diff --cc hello.rb
index a440db6,54336ba..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/rerere3.png"/>
</imageobject>
<textobject><phrase>rerere3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You can also recreate the conflicted file state by running <literal>git checkout</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout --conflict=merge hello.rb
$ cat hello.rb
#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end</programlisting>
<simpara>We saw an example of this in <xref linkend="_advanced_merging"/>.
For now though, let&#8217;s re-resolve it by just running <literal>git rerere</literal> again:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rerere
Resolved 'hello.rb' using previous resolution.
$ cat hello.rb
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end</programlisting>
<simpara>We re-resolved the file automatically using the <literal>git rerere</literal> cached resolution.
You can now add and continue the rebase.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add hello.rb
$ git rebase --continue
Applying: i18n one word</programlisting>
<simpara>So, if you do a lot of re-merges, or want to keep a topic branch up to date with your <literal>master</literal> without
a ton of merges, or you rebase often, turn on <literal>git rerere</literal> to improve your life.</simpara>
</section>
<section xml:id="_debugging_with_git">
<title>Debugging with Git</title>
<simpara>Git also provides tools to help debug bugs in your projects.
Because Git is designed to work with nearly any type of project, these tools are generic,
but they can often help hunt for a bug or culprit when things go wrong.</simpara>
<section xml:id="_file_annotation">
<title>File Annotation</title>
<simpara>If you track down a bug in your code and want to know when it was introduced and why, file annotation is often your best tool.
It shows the commit that was the last to modify each line of any file.
So if you see that a method in your code is buggy, you can annotate the file by running <literal>git blame</literal>
to determine which commit was responsible for the introduction of that line.</simpara>
<simpara>The following example shows the output of <literal>git blame</literal> to determine which commit and committer was
responsible for lines in the Linux kernel <literal>Makefile</literal>. It uses the <literal>-L</literal> flag to restrict the output
to lines 69 through 82 of that file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git blame -L 69,82 Makefile
b8b0618cf6fab (Cheng Renquan  2009-05-26 16:03:07 +0800 69) ifeq ("$(origin V)", "command line")
b8b0618cf6fab (Cheng Renquan  2009-05-26 16:03:07 +0800 70)   KBUILD_VERBOSE = $(V)
^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 71) endif
^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 72) ifndef KBUILD_VERBOSE
^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 73)   KBUILD_VERBOSE = 0
^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 74) endif
^1da177e4c3f4 (Linus Torvalds 2005-04-16 15:20:36 -0700 75)
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 76) ifeq ($(KBUILD_VERBOSE),1)
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 77)   quiet =
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 78)   Q =
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 79) else
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 80)   quiet=quiet_
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 81)   Q = @
066b7ed955808 (Michal Marek   2014-07-04 14:29:30 +0200 82) endif</programlisting>
<simpara>Notice that the first field is the partial SHA-1 hash of the commit that last modified that line.
The next two fields are values extracted from that commit&#8201;&#8212;&#8201;the author name and the authored date
of that commit&#8201;&#8212;&#8201;so you can easily see who modified that line and when.
After that come the line number and the content of the line.
Also note the lines starting with <literal>^</literal>. These are the lines that were in this file’s original commit.
This is when this file was first added to this project, and those lines have been unchanged since.
This is a tad confusing, because now you’ve seen at least three different ways that Git
uses <literal>^</literal> to modify a commit SHA-1 hash.</simpara>
<simpara>Another cool thing about Git is that it doesn’t track file renames explicitly.
It records snapshots and then tries to figure out what was renamed, after the fact.
Git can recognize all sorts of code movement.
If you pass <literal>-C</literal> to <literal>git blame</literal>, Git analyzes the file you’re annotating and tries to figure
out where snippets of code it contains originally came from if they were copied from elsewhere.
For example, say you&#8217;re refactoring a file named <literal>GITServerHandler.m</literal> into multiple files,
one of which is <literal>GITPackUpload.m</literal>. By running <literal>git blame -C GITPackUpload.m</literal>,
you can see the origin of sections of the code.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git blame -C -L 141,153 GITPackUpload.m
f344f58d GITServerHandler.m (Scott 2009-01-04 141)
f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@"GATHER COMMI
ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)
56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {
56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb
56ef2caf GITServerHandler.m (Scott 2009-01-05 153)</programlisting>
<simpara>This is really useful.
Normally, your original commit is when you copied the code into Git, because that&#8217;s the first
time you touched those lines in this file. Git shows the original commit where you wrote those lines.</simpara>
</section>
<section xml:id="_binary_search">
<title>Binary Search</title>
<simpara>Annotating a file helps if you know where the issue is to begin with.
If you don’t know what&#8217;s breaking, and there have been dozens or hundreds of commits since
the last time you know the code worked, turn to <literal>git bisect</literal> for help.
<literal>git bisect</literal> does a binary search through your commit history to help identify which commit
introduced the bug as quickly as possible.</simpara>
<simpara>Let’s say you just pushed out a release of your code to a production environment,
you’re getting bug reports about something that wasn’t happening in your development environment,
and you can’t imagine why the code is doing that. You go back to your code, and it turns out
you can reproduce the bug, but you can’t figure out what&#8217;s going wrong.
You can bisect the code to find out.
First run <literal>git bisect start</literal> to get things going, and then run <literal>git bisect bad</literal> to tell Git
that the commit you’re on is broken.
Then, tell bisect when the last known good state was, using <literal>git bisect good [good_commit]</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git bisect start
$ git bisect bad
$ git bisect good v1.0
Bisecting: 6 revisions left to test after this
[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo</programlisting>
<simpara>Git figured out that about 12 commits came between the commit you marked as the last good commit (v1.0)
and the current bad version, and it checked out the commit roughly in the middle for you.
At this point, you can run your test to see if the bug exists in this commit.
If it does, then it was introduced sometime before this middle commit. If it doesn’t,
then the problem was introduced sometime after the middle commit.
It turns out there&#8217;s no bug here, and you notify Git by running <literal>git bisect good</literal> and continue your journey.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git bisect good
Bisecting: 3 revisions left to test after this
[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing</programlisting>
<simpara>Now you’re on another commit, halfway between the one you just tested and your bad commit.
You run your test again and find that this commit is broken, so you notify Git by running <literal>git bisect bad</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git bisect bad
Bisecting: 1 revisions left to test after this
[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table</programlisting>
<simpara>This commit is fine, and now Git has all the information it needs to determine the commit in
which the bug was introduced. It tells you the SHA-1 hash of the first bad commit and shows
some of the commit information and which files were modified in that commit so you can figure
out what happened that may have introduced this bug.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git bisect good
b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
Author: PJ Hyett &lt;pjhyett@example.com&gt;
Date:   Tue Jan 27 14:48:32 2009 -0800

    secure this thing

:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config</programlisting>
<simpara>When you’re finished, run <literal>git bisect reset</literal> to reset <literal>HEAD</literal> to where it was before you started
otherwise you end up in a weird state.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git bisect reset</programlisting>
<simpara>This is a powerful tool that can check hundreds of commits for a bug in minutes.
In fact, if you have a script that exits with a 0 value if the project is good or non-0 if
the project is bad, you can fully automate the bisect process.
First, you again tell Git the scope of the bisect by providing the known bad and good commits.
You do this by listing them by running <literal>git bisect start</literal>, listing the known bad commit first
and the known good commit second.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git bisect start HEAD v1.0
$ git bisect run test-error.sh</programlisting>
<simpara>Doing so automatically runs <literal>test-error.sh</literal> on each checked-out commit until Git finds the first broken commit.</simpara>
</section>
</section>
<section xml:id="_git_submodules">
<title>Submodules</title>
<simpara>Often, while working on one project, you need to use another project from within it.
Perhaps it’s a library that a third party developed or that you’re developing separately
and using in multiple parent projects. A common issue in these scenarios is how
to treat the two projects as separate yet still be able to use one from within the other.</simpara>
<simpara>Here’s an example.
Suppose you’re developing a website and creating Atom feeds.
Instead of writing your own Atom-generating code, you decide to use a library that already exists.
You’re likely to either include this code from a shared library, like a CPAN install or Ruby gem,
or copy the source code into your own project tree.
The issue with including a shared library is that it’s difficult to customize the library in any
way and often more difficult to deploy it, because you need to make sure every client has that library
available. The issue with copying the code into your own project is that any custom changes you make
are difficult to merge when changes to the library become available.</simpara>
<simpara>Git addresses this issue by using submodules.
They allow keeping a Git repository as a subdirectory of another Git repository.
This lets you clone another repository into your project and keep your commits separate.</simpara>
<section xml:id="_starting_submodules">
<title>Starting with Submodules</title>
<simpara>We walk through developing a simple project that has been split up into a main project and a few sub-projects.</simpara>
<simpara>Let&#8217;s start by adding an existing Git repository as a submodule of the repository that we&#8217;re working on.
To add a new submodule, run <literal>git submodule add</literal> with the absolute or relative URL of the project you&#8217;d
like to start tracking. In this example, we add a library called <literal>DbConnector</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git submodule add https://github.com/chaconinc/DbConnector
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.</programlisting>
<simpara>By default, <literal>git submodule</literal> adds the subproject into a directory with the same name as the repository -
in this case <literal>DbConnector</literal>. You can add a different path at the end of the command to use a different name.</simpara>
<simpara>If you run <literal>git status</literal> at this point, you notice a few things.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

	new file:   .gitmodules
	new file:   DbConnector</programlisting>
<simpara>First you should notice the new <literal>.gitmodules</literal> file.
This is a configuration file that stores the mapping between the project’s URL and the local
subdirectory where the submodule is located.</simpara>
<programlisting language="ini" linenumbering="unnumbered">[submodule "DbConnector"]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector</programlisting>
<simpara>If you have multiple submodules, you have multiple entries in this file.
It’s important to note that this file is version-controlled with the other files, like <literal>.gitignore</literal>.
It’s pushed and pulled with the rest of your project.
This is how other people who clone this project know where to get submodule projects from.</simpara>
<note>
<simpara>Since the URL in <literal>.gitmodules</literal> is what other people first try to clone or fetch from,
make sure to use a URL that they can access. For example, if you use a different URL to push
to than others would use to pull from, use the one that others can access. You can overwrite this
value locally with <literal>git config submodule.DbConnector.url PRIVATE_URL</literal>.</simpara>
</note>
<simpara>The other listing in the <literal>git status</literal> output is the project directory name.
If you run <literal>git diff</literal> on that, you see something interesting.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc</programlisting>
<simpara>Although <literal>DbConnector</literal> is a subdirectory in your working directory, Git sees it as a submodule and doesn&#8217;t
track its content when you’re not in that directory. Instead, Git sees it as a particular commit.</simpara>
<simpara>For a little nicer output, pass the <literal>--submodule</literal> flag to <literal>git diff</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "DbConnector"]
+       path = DbConnector
+       url = https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)</programlisting>
<simpara>When you commit, you see something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit -am 'added DbConnector module'
[master fb9093c] added DbConnector module
 2 files changed, 4 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000 DbConnector</programlisting>
<simpara>Notice the <literal>160000</literal> mode for <literal>DbConnector</literal>.
That&#8217;s a special mode in Git that means you’re recording a commit as a directory entry
rather than as a subdirectory or file.</simpara>
<simpara>Finally, push the changes.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin master</programlisting>
</section>
<section xml:id="_cloning_submodules">
<title>Cloning a Project with Submodules</title>
<simpara>Here we clone a project containing a submodule.
When you clone such a project, by default you get the directories that contain submodules,
but none of the files within them yet.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
$ cd MainProject
$ ls -la
total 16
drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .
drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..
drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git
-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules
drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector
-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile
drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src
$ cd DbConnector/
$ ls
$</programlisting>
<simpara>An empty <literal>DbConnector</literal> directory is there.
You must run two commands - <literal>git submodule init</literal> to initialize your local configuration file,
and <literal>git submodule update</literal> to fetch all the files from that project and check out the
appropriate commit listed in your superproject.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git submodule init
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
$ git submodule update
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'</programlisting>
<simpara>Now your <literal>DbConnector</literal> subdirectory is in the exact state it was in when you committed earlier.</simpara>
<simpara>There&#8217;s another way to do this which is a little simpler, however. If you add <literal>--recursive</literal> to <literal>git clone</literal>,
Git automatically initializes and updates each submodule in the repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone --recurse-submodules https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'</programlisting>
</section>
<section xml:id="_working_on_a_project_with_submodules">
<title>Working on a Project with Submodules</title>
<simpara>Now we have a copy of a project containing submodules. We collaborate with our teammates
on both the main project and the submodule project.</simpara>
<section xml:id="_pulling_in_upstream_changes">
<title>Pulling in Upstream Changes</title>
<simpara>The simplest way to use submodules in a project would be if you were simply consuming a subproject
and wanted to get updates from it from time to time but weren&#8217;t actually modifying anything.
Let&#8217;s walk through a simple example.</simpara>
<simpara>To check for new work in a submodule, go into the directory and run <literal>git fetch</literal> and <literal>git merge</literal>
on the original repository to update the local code.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch
From https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc  master     -&gt; origin/master
$ git merge origin/master
Updating c3f01dc..d0354fc
Fast-forward
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)</programlisting>
<simpara>Now if you go back into the main project and run <literal>git diff --submodule</literal> you see that the submodule
was updated, and a list of added commits. If you don&#8217;t want
to include <literal>--submodule</literal> every time you run <literal>git diff</literal>, set it as the default by
setting the <literal>diff.submodule</literal> config value to <literal>log</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global diff.submodule log
$ git diff
Submodule DbConnector c3f01dc..d0354fc:
  &gt; more efficient db routine
  &gt; better connection routine</programlisting>
<simpara>If you commit at this point then you lock the submodule to have the new code when other people update.</simpara>
<simpara>There&#8217;s an easier way to do this as well, if you prefer to not manually fetch and merge in the subdirectory.
If you run <literal>git submodule update --remote</literal>, Git goes into your submodules and does the fetch
and update for you.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git submodule update --remote DbConnector
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   3f19983..d0354fc  master     -&gt; origin/master
Submodule path 'DbConnector': checked out 'd0354fc054692d3906c85c3af05ddce39a1c0644'</programlisting>
<simpara>This command by default assumes that you want to update the checkout to the <literal>master</literal> branch
of the submodule repository. You can, however, set this to something different. For example,
to have the DbConnector submodule track that repository&#8217;s <literal>stable</literal> branch,
set it in either your <literal>.gitmodules</literal> file (so everyone else also tracks it),
or just in your local <literal>.git/config</literal> file. Let&#8217;s set it in <literal>.gitmodules</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config -f .gitmodules submodule.DbConnector.branch stable

$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d  stable -&gt; origin/stable
Submodule path 'DbConnector': checked out 'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'</programlisting>
<simpara>If you leave off <literal>-f .gitmodules</literal> Git only makes the change for you, but it probably makes more
sense to track that information in the repository so everyone else does as well.</simpara>
<simpara>When we run <literal>git status</literal> at this point, Git shows that we have new commits in the submodule.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

  modified:   .gitmodules
  modified:   DbConnector (new commits)

no changes added to commit (use "git add" and/or "git commit -a")</programlisting>
<simpara>If you set the configuration setting <literal>status.submodulesummary</literal>, Git also shows
a short summary of changes to your submodules.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config status.submodulesummary 1

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   .gitmodules
	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c3f01dc...c87d55d (4):
  &gt; catch non-null terminated lines</programlisting>
<simpara>At this point if we run <literal>git diff</literal> we see both that we&#8217;ve modified <literal>.gitmodules</literal> and
also that there are a number of commits that we&#8217;ve pulled down and are ready to commit to our submodule project.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff
diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
 Submodule DbConnector c3f01dc..c87d55d:
  &gt; catch non-null terminated lines
  &gt; more robust error handling
  &gt; more efficient db routine
  &gt; better connection routine</programlisting>
<simpara>This is pretty cool as we can actually see the list of commits that we&#8217;re about to commit into our submodule.
Once committed, you can see the list after the fact by running <literal>git log -p</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -p --submodule
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Sep 17 16:37:02 2014 +0200

    updating DbConnector for bug fixes

diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  &gt; catch non-null terminated lines
  &gt; more robust error handling
  &gt; more efficient db routine
  &gt; better connection routine</programlisting>
<simpara>Git, by default, tries to update <emphasis role="strong">all</emphasis> your submodules when you run <literal>git submodule update --remote</literal> so
if you have a lot of submodules, you may want to just pass the name of the one you want to update.</simpara>
</section>
<section xml:id="_working_on_a_submodule">
<title>Working on a Submodule</title>
<simpara>It&#8217;s quite likely that if you&#8217;re using submodules, you&#8217;re doing so because you really want to work
on the code in the submodule at the same time that you&#8217;re working on the code in the main project
(or across several submodules). Otherwise you&#8217;d probably instead be using a simpler dependency
management system (such as Maven or Rubygems).</simpara>
<simpara>So now let&#8217;s go through an example of making changes to the submodule at the same time as the main project,
and committing and publishing those changes at the same time.</simpara>
<simpara>So far, when we&#8217;ve run <literal>git submodule update</literal> to fetch changes from the submodule repositories,
Git would get the changes and update the files in the subdirectory but leave the sub-repository in what&#8217;s
called a <literal>detached HEAD</literal> state. This means that there&#8217;s no local working branch (like <literal>master</literal>, for example)
tracking changes. So any changes you make aren&#8217;t being tracked.
With no working branch tracking changes, that means even if you commit changes
to the submodule, those changes quite possibly are lost the next time you
run <literal>git submodule update</literal>. You have to do some extra steps if you want changes
in a submodule to be tracked.</simpara>
<simpara>In order to set up your submodule to be easier to hack on, do two things.
Go into each submodule and check out a branch to work on. Then tell Git what to do if you&#8217;ve
made changes, and then run <literal>git submodule update --remote</literal> to pull new work from upstream.
You can either merge them into your local work, or you can try to rebase your local work
on top of the new changes.</simpara>
<simpara>First of all, let&#8217;s go into our submodule directory and check out a branch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout stable
Switched to branch 'stable'</programlisting>
<simpara>Let&#8217;s try the <literal>--merge</literal> flag. To specify it manually, just add the <literal>--merge</literal> flag to <literal>git submodule update</literal>.
Here we see that there was a change on the server for this submodule which gets merged in.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -&gt; origin/stable
Updating c87d55d..92c7337
Fast-forward
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
Submodule path 'DbConnector': merged in '92c7337b30ef9e0893e758dac2459d07362ab5ea'</programlisting>
<simpara>If we go into the DbConnector directory, we have the new changes already merged into our
local <literal>stable</literal> branch. Now let&#8217;s see what happens when we make our own local change to the library
and someone else pushes another change upstream at the same time.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd DbConnector/
$ vim src/db.c
$ git commit -am 'unicode support'
[stable f906e16] unicode support
 1 file changed, 1 insertion(+)</programlisting>
<simpara>Now if we update our submodule we see what happens when we&#8217;ve made a local change and upstream
also has a change we need to incorporate.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git submodule update --remote --rebase
First, rewinding head to replay your work on top of it...
Applying: unicode support
Submodule path 'DbConnector': rebased into '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</programlisting>
<simpara>If you forget <literal>--rebase</literal> or <literal>--merge</literal>, Git just updates the submodule to whatever is on the remote
server and resets your project to a detached <literal>HEAD</literal> state.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git submodule update --remote
Submodule path 'DbConnector': checked out '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</programlisting>
<simpara>If this happens, don&#8217;t worry. You can simply go back and check out your branch again (which still
contains your work) and merge or rebase <literal>origin/stable</literal> (or any remote branch) manually.</simpara>
<simpara>If you haven&#8217;t committed the changes in your submodule and you run a <literal>git submodule update</literal> that
would cause issues, Git fetches the changes but doesn&#8217;t overwrite unsaved work in your submodule directory.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 4 (delta 0)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a  stable     -&gt; origin/stable
error: Your local changes to the following files would be overwritten by checkout:
	scripts/setup.sh
Please, commit your changes or stash them before you can switch branches.
Aborting
Unable to checkout 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'</programlisting>
<simpara>If you made changes that conflict with something changed upstream, Git lets you know when you run the update.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git submodule update --remote --merge
Auto-merging scripts/setup.sh
CONFLICT (content): Merge conflict in scripts/setup.sh
Recorded preimage for 'scripts/setup.sh'
Automatic merge failed; fix conflicts and then commit the result.
Unable to merge 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'</programlisting>
<simpara>You can go into the submodule directory and fix the conflict just as you normally would.</simpara>
</section>
<section xml:id="_publishing_submodules">
<title>Publishing Submodule Changes</title>
<simpara>Now we have some changes in our submodule directory. Some of these were brought in from upstream
by our updates and others were made locally and aren&#8217;t available to anyone else since we haven&#8217;t
pushed them yet.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff
Submodule DbConnector c87d55d..82d2ad3:
  &gt; Merge from origin/stable
  &gt; updated setup script
  &gt; unicode support
  &gt; remove unnecessary method
  &gt; add new option for conn pooling</programlisting>
<simpara>If we commit in the main project and push without including the submodule changes as well,
other people who try to check out our changes are going to be in trouble since they have no way
to get the necessary submodule changes. Those changes only exist in our local copy.</simpara>
<simpara>In order to make sure this doesn&#8217;t happen, tell Git to check that all your submodules have been
pushed properly before pushing the main project. <literal>git push</literal> takes the <literal>--recurse-submodules</literal> flag
which can be set to either <literal>check</literal> or <literal>on-demand</literal>. The <literal>check</literal> option makes <literal>push</literal> simply fail
if any of the committed submodule changes haven&#8217;t been pushed.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push --recurse-submodules=check
The following submodule paths contain changes that can
not be found on any remote:
  DbConnector

Please try

	git push --recurse-submodules=on-demand

or cd to the path and use

	git push

to push them to a remote.</programlisting>
<simpara>It also gives some helpful advice on what we might want to do next. The simple option is to go into each
submodule and manually push to the remotes to make sure they&#8217;re externally available and then try
this push again. To make the check behavior the default for all pushes,
run <literal>git config push.recurseSubmodules check</literal>.</simpara>
<simpara>The other option is to use the <literal>on-demand</literal> option, which tries to do this for you.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push --recurse-submodules=on-demand
Pushing submodule 'DbConnector'
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 3), reused 0 (delta 0)
To https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3  stable -&gt; stable
Counting objects: 2, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To https://github.com/chaconinc/MainProject
   3d6d338..9a377d1  master -&gt; master</programlisting>
<simpara>As you see, Git went into the DbConnector module and pushed it before pushing the main project.
If that submodule push fails for some reason, the main project push also fails.
To make this behavior the default, run <literal>git config push.recurseSubmodules on-demand</literal>.</simpara>
</section>
<section xml:id="_merging_submodule_changes">
<title>Merging Submodule Changes</title>
<simpara>If you change a submodule reference at the same time as someone else, you may run into problems.
That is, if the submodule histories have diverged and are committed to diverging branches in a superproject,
they may take a bit of work to fix.</simpara>
<simpara>If one of the commits is a direct ancestor of the other (a fast-forward merge),
then Git simply chooses the latter for the merge, so that works fine.</simpara>
<simpara>Git doesn&#8217;t attempt even a trivial merge, however. If the submodule commits diverge and need to be merged,
you see something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1)
Unpacking objects: 100% (2/2), done.
From https://github.com/chaconinc/MainProject
   9a377d1..eb974f8  master     -&gt; origin/master
Fetching submodule DbConnector
warning: Failed to merge submodule DbConnector (merge following commits not found)
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.</programlisting>
<simpara>So basically what happened here is that Git figured out that the two branches record points in the
submodule&#8217;s history that are divergent and need to be merged. It shows the warning <literal>merge following commits not found</literal>,
which is confusing but we explain it in a bit.</simpara>
<simpara>To solve the problem, you need to figure out what state the submodule should be in. Strangely,
Git doesn&#8217;t really give you much information to help out here, not even the SHA-1 hashes of the commits
of both sides of the history. Fortunately, it&#8217;s simple to figure out. If you run <literal>git diff</literal> you get the
SHA-1 hashes of the commits recorded in both branches you were trying to merge.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector</programlisting>
<simpara>So, in this case, <literal>eb41d76</literal> is the commit in our submodule that we had and <literal>c771610</literal> is the commit that
upstream had. If we go into our submodule directory, it should already be on <literal>eb41d76</literal> since the merge
wouldn&#8217;t have touched it. If for whatever reason it&#8217;s not, simply create and checkout a branch pointing to it.</simpara>
<simpara>What&#8217;s important is the SHA-1 hash of the commit from the other side.
This is what you have to merge and resolve. You can either just try the merge with the SHA-1
hash directly, or you can create a branch for it and then try to merge that in. We&#8217;d suggest the latter,
even if only to make a nicer merge commit message.</simpara>
<simpara>So, we go into our submodule directory, create a branch based on that second SHA-1 hash from <literal>git diff</literal>,
and manually merge.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd DbConnector

$ git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

$ git branch try-merge c771610
(DbConnector) $ git merge try-merge
Auto-merging src/main.c
CONFLICT (content): Merge conflict in src/main.c
Recorded preimage for 'src/main.c'
Automatic merge failed; fix conflicts and then commit the result.</programlisting>
<simpara>We got an actual merge conflict here, so if we resolve that and commit,
then we can simply update the main project with the result.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ vim src/main.c <co xml:id="CO3-1"/>
$ git add src/main.c
$ git commit -am 'merged our changes'
Recorded resolution for 'src/main.c'.
[master 9fd905e] merged our changes

$ cd .. <co xml:id="CO3-2"/>
$ git diff <co xml:id="CO3-3"/>
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
@@@ -1,1 -1,1 +1,1 @@@
- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135
 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d
++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
$ git add DbConnector <co xml:id="CO3-4"/>

$ git commit -m "Merge Tom's Changes" <co xml:id="CO3-5"/>
[master 10d2c60] Merge Tom's Changes</programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para>First we resolve the conflict</para>
</callout>
<callout arearefs="CO3-2">
<para>Then we go back to the main project directory</para>
</callout>
<callout arearefs="CO3-3">
<para>We can check the SHA-1s again</para>
</callout>
<callout arearefs="CO3-4">
<para>Resolve the conflicted submodule entry</para>
</callout>
<callout arearefs="CO3-5">
<para>Commit our merge</para>
</callout>
</calloutlist>
<simpara>It can be a bit confusing, but it&#8217;s really not very hard.</simpara>
<simpara>Interestingly, there&#8217;s another case that Git handles.
If a merge commit exists in the submodule directory that contains both commits in its history,
Git suggests it to you as a possible solution. It sees that at some point in the submodule&#8217;s history,
someone merged branches containing these two commits, so maybe you want that one.</simpara>
<simpara>This is why the error message from before was <literal>merge following commits not found</literal>,
because Git couldn&#8217;t do <emphasis role="strong">this</emphasis>. It&#8217;s confusing because who would expect it to try to do this?</simpara>
<simpara>If it does find a single acceptable merge commit, you see something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge origin/master
warning: Failed to merge submodule DbConnector (not fast-forward)
Found a possible merge resolution for the submodule:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: &gt; merged our changes
If this is correct simply add it to the index for example
by using:

  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a "DbConnector"

which will accept this suggestion.
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.</programlisting>
<simpara>It&#8217;s suggesting that you update the index as if you had run <literal>git add</literal>, which clears the conflict,
then commit. You probably shouldn&#8217;t do this though. You can just as easily go into the submodule directory,
see what the difference is, fast-forward to this commit, test it properly, and then commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd DbConnector/
$ git merge 9fd905e
Updating eb41d76..9fd905e
Fast-forward

$ cd ..
$ git add DbConnector
$ git commit -am 'Fast forwarded to a common submodule child'</programlisting>
<simpara>This accomplishes the same thing, but at least this way you can verify that it works and you have the code
in your submodule directory when you&#8217;re done.</simpara>
</section>
</section>
<section xml:id="_submodule_tips">
<title>Submodule Tips</title>
<simpara>There are a few things you can do to make working with submodules a little easier.</simpara>
<section xml:id="_submodule_foreach">
<title>Submodule Foreach</title>
<simpara>There&#8217;s a <literal>git submodule foreach</literal> command to run some arbitrary command in each submodule.
This can be really helpful if you have a number of submodules in the same project.</simpara>
<simpara>For example, let&#8217;s say we want to start a new feature or do a bugfix, and we have work going
on in several submodules. We can easily stash all the work in all our submodules.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git submodule foreach 'git stash'
Entering 'CryptoLibrary'
No local changes to save
Entering 'DbConnector'
Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable
HEAD is now at 82d2ad3 Merge from origin/stable</programlisting>
<simpara>Then we can create a new branch and switch to it in all our submodules.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git submodule foreach 'git checkout -b featureA'
Entering 'CryptoLibrary'
Switched to a new branch 'featureA'
Entering 'DbConnector'
Switched to a new branch 'featureA'</programlisting>
<simpara>You get the idea. One really useful thing you can do is produce a nice unified diff of what&#8217;s
changed in your main project and all your subprojects as well.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff; git submodule foreach 'git diff'
Submodule DbConnector contains modified content
diff --git a/src/main.c b/src/main.c
index 210f1ae..1f0acdc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)

      commit_pager_choice();

+     url = url_decode(url_orig);
+
      /* build alias_argv */
      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));
      alias_argv[0] = alias_string + 1;
Entering 'DbConnector'
diff --git a/src/db.c b/src/db.c
index 1aaefb6..5297645 100644
--- a/src/db.c
+++ b/src/db.c
@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)
        return url_decode_internal(&amp;url, len, NULL, &amp;out, 0);
 }

+char *url_decode(const char *url)
+{
+       return url_decode_mem(url, strlen(url));
+}
+
 char *url_decode_parameter_name(const char **query)
 {
        struct strbuf out = STRBUF_INIT;</programlisting>
<simpara>Here we see that we&#8217;re defining a function in a submodule and calling it in the main project.
This is obviously a simplified example, but hopefully it shows how this may be useful.</simpara>
</section>
<section xml:id="_useful_aliases">
<title>Useful Aliases</title>
<simpara>You may want to set up aliases for some of these commands.
They can be quite long and you can&#8217;t set default configuration options for most of them.
We covered setting up Git aliases in <xref linkend="_git_aliases"/>,
but here&#8217;s an example of what you may want to set up if you plan on working with submodules in Git a lot.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config alias.sdiff '!'"git diff &amp;&amp; git submodule foreach 'git diff'"
$ git config alias.spush 'push --recurse-submodules=on-demand'
$ git config alias.supdate 'submodule update --remote --merge'</programlisting>
<simpara>This way you can simply run <literal>git supdate</literal> when you want to update your submodules,
or <literal>git spush</literal> to push with submodule dependency checking.</simpara>
</section>
</section>
<section xml:id="_issues_with_submodules">
<title>Issues with Submodules</title>
<simpara>Using submodules isn’t without hiccups, however.</simpara>
<simpara>Switching branches containing submodules, for instance, can be tricky.
If you create a new branch, add a submodule there, and then switch back to a branch without that submodule,
you still have the submodule directory as an untracked directory.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'adding crypto library'
[add-crypto 4445836] adding crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

	CryptoLibrary/

nothing added to commit but untracked files present (use "git add" to track)</programlisting>
<simpara>Removing the directory isn&#8217;t difficult, but its presence can be a bit confusing.
If you do remove it and then switch back to the branch that has that submodule,
run <literal>submodule update --init</literal> to repopulate it.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clean -ffdx
Removing CryptoLibrary/

$ git checkout add-crypto
Switched to branch 'add-crypto'

$ ls CryptoLibrary/

$ git submodule update --init
Submodule path 'CryptoLibrary': checked out 'b8dda6aa182ea4464f3f3264b11e0268545172af'

$ ls CryptoLibrary/
Makefile	includes	scripts		src</programlisting>
<simpara>Again, not really very difficult, but it can be a little confusing.</simpara>
<simpara>The other main caveat that many people run into involves switching from subdirectories to submodules.
If you’ve been tracking files in your project that you want to move into a submodule,
be careful or else Git gets angry with you.
Assume that you have files in a subdirectory of your project that you want to switch to a submodule.
If you delete the subdirectory and then run <literal>git submodule add</literal>, Git yells at you.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ rm -Rf CryptoLibrary/
$ git submodule add https://github.com/chaconinc/CryptoLibrary
'CryptoLibrary' already exists in the index</programlisting>
<simpara>You have to unstage the <literal>CryptoLibrary</literal> directory first.
Then you can add the submodule.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rm -r CryptoLibrary
$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.</programlisting>
<simpara>Now suppose you did that in a branch.
If you try to switch back to a branch where those files are still in the actual tree rather than a submodule,
you get this.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout master
error: The following untracked working tree files would be overwritten by checkout:
  CryptoLibrary/Makefile
  CryptoLibrary/includes/crypto.h
  ...
Please move or remove them before you can switch branches.
Aborting</programlisting>
<simpara>You can force a switch by running <literal>git checkout -f</literal>, but be careful that you don&#8217;t have
unsaved changes since they could be overwritten.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -f master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'</programlisting>
<simpara>Then, when you switch back, you get an empty <literal>CryptoLibrary</literal> directory for some reason and
running <literal>git submodule update</literal> may not fix it. You may need to go into your submodule directory
and run <literal>git checkout .</literal> to get all your files back. You could run this in a <literal>submodule foreach</literal>
script if you have multiple submodules.</simpara>
<simpara>It&#8217;s important to note that submodules these days keep all their Git data in the top
project&#8217;s <literal>.git</literal> directory, so unlike much older versions of Git, destroying a submodule directory
doesn&#8217;t lose any commits or branches.</simpara>
<simpara>With these tools, submodules can be a fairly simple and effective method for working on several related
but still separate projects simultaneously.</simpara>
</section>
</section>
<section xml:id="_bundling">
<title>Bundling</title>
<simpara>Though we&#8217;ve covered the common ways (HTTP, SSH, etc) to transfer and sync Git repositories over a network,
there&#8217;s actually one more way that isn&#8217;t common but can actually be quite useful.</simpara>
<simpara>Git is capable of bundling data into a single file. This can be useful in various scenarios.
Maybe your network is down and you want to send changes to your co-workers.
Perhaps you&#8217;re working somewhere offsite and don&#8217;t have access to the Internet for security reasons.
Maybe your network card just broke. Maybe you don&#8217;t have access to a shared server for the moment,
and you want to email someone updates but you don&#8217;t want to transfer 40 commits by running <literal>git format-patch</literal>.</simpara>
<simpara>This is where <literal>git bundle</literal> can be helpful. It packages up everything that <literal>git push</literal> would normally
send over the network into a file that you can email to someone or put on a flash drive,
then unbundle into another repository.</simpara>
<simpara>Let&#8217;s see a simple example. Say you have a repository with two commits.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log
commit 9a466c572fe88b195efd356c3f2bbeccdb504102
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Mar 10 07:34:10 2010 -0800

    second commit

commit b1ec3248f39900d2a406049d762aa68e9641be25
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Mar 10 07:34:01 2010 -0800

    first commit</programlisting>
<simpara>To send that repository to someone and you don&#8217;t have access to a repository to push to,
or are simply too lazy to set one up, bundle it by running <literal>git bundle create</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git bundle create repo.bundle HEAD master
Counting objects: 6, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (6/6), 441 bytes, done.
Total 6 (delta 0), reused 0 (delta 0)</programlisting>
<simpara>Now you have a file named <literal>repo.bundle</literal> that has all the data needed to re-create the repository&#8217;s
<literal>master</literal> branch. When running <literal>git bundle</literal> specify every reference or specific range of commits that you want
to be included. If you intend for what&#8217;s in this bundle to be cloned somewhere else after it&#8217;s extracted,
add <literal>HEAD</literal> as a reference as well, as we&#8217;ve done here.</simpara>
<simpara>You can email <literal>repo.bundle</literal> to someone else, or put it on a USB drive and walk it over.</simpara>
<simpara>On the other side, say you receive <literal>repo.bundle</literal> and want to work on the project.
Clone from the bundle file into a directory, much like you would from a URL.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone repo.bundle repo
Cloning into 'repo'...
...
$ cd repo
$ git log --oneline
9a466c5 second commit
b1ec324 first commit</programlisting>
<simpara>If you don&#8217;t include <literal>HEAD</literal> in the references, you have to also specify <literal>-b master</literal> or whatever
branch is included because otherwise Git doesn&#8217;t know what branch to check out.</simpara>
<simpara>Now let&#8217;s say you make three commits and want to send the new commits back in a bundle.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo
9a466c5 second commit
b1ec324 first commit</programlisting>
<simpara>First determine the range of commits to include. Unlike the network protocols,
which figure out the minimum amount of data to transfer, we have to figure this out manually.
You could just do the same thing and bundle the entire repository, which does work.
But it&#8217;s better to just bundle up the difference - just the three commits we made locally.</simpara>
<simpara>To do that, you have to calculate the difference. As we described in <xref linkend="_commit_ranges"/>,
you can specify a range of commits in a number of ways. To specify the three commits that we have
in our <literal>master</literal> that weren&#8217;t in the branch we originally cloned, use something
like <literal>origin/master..master</literal> or <literal>master ^origin/master</literal>. You can test the specification by running <literal>git log</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline master ^origin/master
71b84da last commit - second repo
c99cf5b fourth commit - second repo
7011d3d third commit - second repo</programlisting>
<simpara>So now that we can specify the range of commits to include in the bundle, let&#8217;s bundle them up.
We do that by running <literal>git bundle create</literal>, giving the filename for our bundle and the range of commits to include.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git bundle create commits.bundle master ^9a466c5
Counting objects: 11, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (9/9), 775 bytes, done.
Total 9 (delta 0), reused 0 (delta 0)</programlisting>
<simpara>Now we have a <literal>commits.bundle</literal> file in our directory. If send it to our partner,
she can then import it into the original repository, even if more work has been done there in the meantime.</simpara>
<simpara>When she gets the bundle, she can inspect it to see what it contains before she imports it
into her repository. The first command to run is <literal>git bundle verify</literal> which makes sure the file
is actually a valid Git bundle and that you have all the necessary ancestors to reconstitute it properly.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git bundle verify ../commits.bundle
The bundle contains 1 ref
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master
The bundle requires these 1 ref
9a466c572fe88b195efd356c3f2bbeccdb504102 second commit
../commits.bundle is okay</programlisting>
<simpara>If the bundler had created a bundle of just the last two commits, rather than all three,
the original repository wouldn&#8217;t be able to import it, since it&#8217;s missing requisite history.
The output of <literal>git bundle verify</literal> would have looked like this instead.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git bundle verify ../commits-bad.bundle
error: Repository lacks these prerequisite commits:
error: 7011d3d8fc200abe0ad561c011c3852a4b7bbe95 third commit - second repo</programlisting>
<simpara>However, our first bundle is valid, so we can fetch commits from it.
To see the branches in the bundle that can be imported, there&#8217;s also a command to just list the heads.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git bundle list-heads ../commits.bundle
71b84daaf49abed142a373b6e5c59a22dc6560dc refs/heads/master</programlisting>
<simpara>The <literal>verify</literal> subcommand shows the heads as well. The point is to see what can be pulled in,
so run <literal>git fetch</literal> or <literal>git pull</literal> to import commits from this bundle. Here we fetch <literal>master</literal> in the
bundle to <literal>other-master</literal> in our repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch ../commits.bundle master:other-master
From ../commits.bundle
 * [new branch]      master     -&gt; other-master</programlisting>
<simpara>Now we see that we have the imported commits on <literal>other-master</literal> as well as any commits we&#8217;ve done
in the meantime in our <literal>master</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline --decorate --graph --all
* 8255d41 (HEAD, master) third commit - first repo
| * 71b84da (other-master) last commit - second repo
| * c99cf5b fourth commit - second repo
| * 7011d3d third commit - second repo
|/
* 9a466c5 second commit
* b1ec324 first commit</programlisting>
<simpara><literal>git bundle</literal> can be really useful for sharing or doing network-type operations when
there&#8217;s no network available.</simpara>
</section>
<section xml:id="_replace">
<title>Replace</title>
<simpara>The objects in a Git repository are immutable, but there&#8217;s an interesting way to pretend to replace objects with
other objects.</simpara>
<simpara><literal>git replace</literal> lets you specify an object and say "every time you see this object,
pretend it&#8217;s this other object". This is most commonly used for replacing one commit in your
history with another one.</simpara>
<simpara>For example, let&#8217;s say you have a huge history and want to split your repository into one short
history for new developers and one much longer and larger history for people interested in data mining.
You can graft one history onto the other by running <literal>git replace</literal> on the earliest commit in the new
repository with the latest commit on the older one. This is nice because it means that you don&#8217;t
actually have to rewrite every commit in the new repository, as you&#8217;d normally have to do to join
them (because the parentage affects the SHA-1 hashes).</simpara>
<simpara>Let&#8217;s try this out. Let&#8217;s take an existing repository, split it into two repositories,
one recent and one historical, and then recombine them by running <literal>git replace</literal> without modifying
the recent repository&#8217;s SHA-1 hashes.</simpara>
<simpara>We use a simple repository with five commits.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline
ef989d8 fifth commit
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</programlisting>
<simpara>We want to break this up into two lines of history. One line goes from commit one to commit
four&#8201;&#8212;&#8201;that&#8217;s the historical one. The second line is just commits four and five&#8201;&#8212;&#8201;that&#8217;s the recent history.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/replace1.png"/>
</imageobject>
<textobject><phrase>replace1</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Creating the historical history is easy. Just put a branch in the local repository and then push that branch
to <literal>master</literal> in a new remote repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch history c6e1e95
$ git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/replace2.png"/>
</imageobject>
<textobject><phrase>replace2</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Now push the new <literal>history</literal> branch to <literal>master</literal> in our new repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add project-history https://github.com/schacon/project-history
$ git push project-history history:master
Counting objects: 12, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (12/12), 907 bytes, done.
Total 12 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (12/12), done.
To git@github.com:schacon/project-history.git
 * [new branch]      history -&gt; master</programlisting>
<simpara>OK, so our history is published. Now the harder part is truncating our recent history so it&#8217;s shorter.
We need an overlap to replace a commit in one branch with an equivalent commit in the other,
so we&#8217;re going to truncate this to just commits four and five (so commit four overlaps).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</programlisting>
<simpara>It&#8217;s useful in this case to create a base commit that has instructions on how to expand the history,
so other developers know what to do if they hit the first commit in the truncated history and need more.
So, create an initial commit object as our base point with instructions, then rebase the remaining
commits (four and five) on top of it.</simpara>
<simpara>To do that, choose a point to split at, which for us is the third commit (<literal>9c68fdc</literal>).
So, our base commit is based off of that tree. We can create our base commit by running <literal>git commit-tree</literal>,
which just takes a tree and gives a brand new, parentless commit object SHA-1 hash back.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo 'get history from blah blah blah' | git commit-tree 9c68fdc^{tree}
622e88e9cbfbacfb75b5279245b9fb38dfea10cf</programlisting>
<note>
<simpara><literal>git commit-tree</literal> is one of a set of commands that are commonly referred to as <emphasis>plumbing</emphasis> commands.
These are commands that aren&#8217;t generally meant to be used directly, but instead are used by other
Git commands to do smaller jobs. When we&#8217;re doing weird things like this, they allow us to do
really low-level things not meant for daily use. Read more about plumbing commands
in <xref linkend="_plumbing_porcelain"/></simpara>
</note>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/replace3.png"/>
</imageobject>
<textobject><phrase>replace3</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>OK, so now that we have a base commit, rebase the rest of our history on top of that by
running <literal>git rebase --onto</literal>. The <literal>--onto</literal> flag gets the SHA-1 hash we just got back from
running <literal>git commit-tree</literal>, and the rebase point is the third commit (the parent of the first
commit we want to keep, <literal>9c68fdc</literal>).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rebase --onto 622e88 9c68fdc
First, rewinding head to replay your work on top of it...
Applying: fourth commit
Applying: fifth commit</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/replace4.png"/>
</imageobject>
<textobject><phrase>replace4</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>We&#8217;ve re-written our recent history on top of a throw away base commit that now contains
instructions on how to reconstitute the entire history. We can push that new history to a new
project so that now when people clone that repository, they only see the most recent two commits and
then a base commit with instructions.</simpara>
<simpara>Let&#8217;s now switch roles to someone cloning the project for the first time who wants the entire history.
To get the history data after cloning this truncated repository, they&#8217;d have to add a second
remote for the historical repository and then run <literal>git fetch</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone https://github.com/schacon/project
$ cd project

$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

$ git remote add project-history https://github.com/schacon/project-history
$ git fetch project-history
From https://github.com/schacon/project-history
 * [new branch]      master     -&gt; project-history/master</programlisting>
<simpara>Now the collaborator has their recent commits in <literal>master</literal> and the historical
commits in <literal>project-history/master</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

$ git log --oneline project-history/master
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</programlisting>
<simpara>To combine them, simply run <literal>git replace</literal> with the commit you want to replace followed by
the commit you want to replace it with. So, to replace the "fourth" commit in <literal>master</literal> with
the "fourth" commit in <literal>project-history/master</literal>, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git replace 81a708d c6e1e95</programlisting>
<simpara>Now, if you look at the history of <literal>master</literal>, you see</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit</programlisting>
<simpara>Cool, right? Without having to change all the SHA-1 hashes upstream, we were able to replace
one commit in our history with an entirely different commit. All the normal
tools (<literal>git bisect</literal>, <literal>git blame</literal>, etc) work how we&#8217;d expect.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/replace5.png"/>
</imageobject>
<textobject><phrase>replace5</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Interestingly, it still shows <literal>81a708d</literal> as the SHA-1 hash, even though it&#8217;s actually using
the <literal>c6e1e95</literal> commit data that we replaced it with. Even if you run a command like <literal>git cat-file</literal>,
you see the replaced data.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p 81a708d
tree 7bc544cf438903b65ca9104a1e30345eee6c083d
parent 9c68fdceee073230f19ebb8b5e7fc71b479c0252
author Scott Chacon &lt;schacon@gmail.com&gt; 1268712581 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1268712581 -0700

fourth commit</programlisting>
<simpara>Remember that the actual parent of <literal>81a708d</literal> was our placeholder commit (<literal>622e88e</literal>),
not <literal>9c68fdce</literal> as it states here.</simpara>
<simpara>Another interesting thing is that this data is kept in our references.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git for-each-ref
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/heads/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/remotes/history/master
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/HEAD
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/replace/81a708dd0e167a3f691541c7a6463343bc457040</programlisting>
<simpara>This means that it&#8217;s easy to share our replacement with others, because we can push this to our server
where other people can easily pull it. This isn&#8217;t that helpful in the history grafting scenario
we&#8217;ve gone over here (since everyone would be pulling both histories anyhow, so why separate them?)
but it can be useful in other circumstances.</simpara>
</section>
<section xml:id="_credential_caching">
<title>Credential Storage</title>
<simpara><indexterm>
<primary>credentials</primary>
</indexterm>
<indexterm>
<primary>git commands</primary><secondary>credential</secondary>
</indexterm>
<indexterm>
<primary>credential</primary>
</indexterm>
If you use the SSH transport for connecting to remotes, it&#8217;s possible to have a private key without a passphrase,
which allows you to securely transfer data without entering your username and password.
However, this isn&#8217;t possible with the HTTP protocols&#8201;&#8212;&#8201;every connection needs a username and password.
Systems with two-factor authentication are even more cumbersome, where the token you use for a
password is randomly generated and hard to remember.</simpara>
<simpara>Fortunately, Git has a credentials system that can help, with the following options:</simpara>
<itemizedlist>
<listitem>
<simpara>The default is to not cache at all.
Every connection attempt results in a prompt for your username and password.</simpara>
</listitem>
<listitem>
<simpara><literal>cache</literal> mode keeps credentials in memory for a certain period of time.
None of the passwords are ever stored on disk, and they&#8217;re purged from the cache after 15 minutes.</simpara>
</listitem>
<listitem>
<simpara><literal>store</literal> mode saves the credentials in a plain-text file on disk, and they never expire.
This means that until you change your password for the remote Git host, you don&#8217;t have to enter your credentials again.
The downside of this approach is that your passwords are stored in cleartext in an unencrypted file.</simpara>
</listitem>
<listitem>
<simpara>If you&#8217;re using a Mac, Git supports <literal>osxkeychain</literal> mode, which caches credentials in the secure keychain that&#8217;s attached to your account.
This method stores the credentials on disk, and they never expire, but they&#8217;re encrypted using the same method used to encrypt HTTPS certificates and Safari auto-fills.</simpara>
</listitem>
<listitem>
<simpara>If you&#8217;re using Windows, install a helper called <literal>Git Credential Manager for Windows.</literal>
This is similar to the <literal>osxkeychain</literal> helper described above, but uses the Windows Credential Store to control sensitive information.  It&#8217;s at <link xl:href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows">https://github.com/Microsoft/Git-Credential-Manager-for-Windows</link>. and is the successor to the <literal>Windows Credential Store for Git</literal> (<literal>git-credential-winstore</literal>, a.k.a. <literal>wincred</literal>), which is no longer being maintained.</simpara>
</listitem>
</itemizedlist>
<simpara>Choose one of these modes by setting a Git configuration value.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global credential.helper cache</programlisting>
<simpara>Some of these helpers accept flags.
The <literal>store</literal> helper accepts the <literal>--file &lt;path&gt;</literal> flag, which determines where the plain-text
file is saved (the default is <literal>~/.git-credentials</literal>). The <literal>cache</literal> helper accepts
the <literal>--timeout &lt;seconds&gt;</literal> flag, which changes the amount of time its daemon is kept running
(the default is <literal>900</literal> seconds, or 15 minutes).
Here&#8217;s how to configure the <literal>store</literal> helper with a custom filename.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global credential.helper 'store --file ~/.my-credentials'</programlisting>
<simpara>Git even allows you to configure several helpers.
When looking for credentials for a particular host, Git queries them in order, and stops
after it gets the first answer.
When saving credentials, Git sends the username and password to <emphasis role="strong">all</emphasis> of the helpers in the list,
and the helpers choose what to do with them.
Here&#8217;s what a <literal>.gitconfig</literal> would look like if you had a credentials file on a thumb drive,
but wanted to use the in-memory cache to save typing if the drive isn&#8217;t plugged in.</simpara>
<programlisting language="ini" linenumbering="unnumbered">[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000</programlisting>
<section xml:id="_under_the_hood">
<title>Under the Hood</title>
<simpara>How does all this work?
The command for the credential-helper system is <literal>git credential</literal>, which takes a command as an argument,
and then more input through stdin.</simpara>
<simpara>This might be easier to understand with an example.
Let&#8217;s say that a credential helper has been configured, and the helper has stored credentials for <literal>mygithost</literal>.
Here&#8217;s a session that uses the <literal>fill</literal> subcommand, which is run when Git tries to find credentials for a host.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git credential fill <co xml:id="CO4-1"/>
protocol=https <co xml:id="CO4-2"/>
host=mygithost
<co xml:id="CO4-3"/>
protocol=https <co xml:id="CO4-4"/>
host=mygithost
username=bob
password=s3cre7
$ git credential fill <co xml:id="CO4-5"/>
protocol=https
host=unknownhost

Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>This initiates the interaction.</para>
</callout>
<callout arearefs="CO4-2">
<para><literal>git credential</literal> is then waiting for input on stdin.
We provide the things we know: the protocol and hostname.</para>
</callout>
<callout arearefs="CO4-3">
<para>A blank line indicates that the input is complete, and the credential system should answer with what it knows.</para>
</callout>
<callout arearefs="CO4-4">
<para><literal>git credential</literal> then takes over, and writes the information it found to stdout.</para>
</callout>
<callout arearefs="CO4-5">
<para>If credentials aren&#8217;t found, Git asks the user for a username and password, and sends them to stdout.</para>
</callout>
</calloutlist>
<simpara>The credential system actually runs a separate program from Git itself. Which one and how it&#8217;s
run depend on the <literal>credential.helper</literal> configuration value. There are several possibilities.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Configuration Value</entry>
<entry align="left" valign="top">Behavior</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>foo</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Runs <literal>git-credential-foo</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>foo -a --opt=bcd</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Runs <literal>git-credential-foo -a --opt=bcd</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/absolute/path/foo -xyz</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Runs <literal>/absolute/path/foo -xyz</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>!f() { echo "password=s3cre7"; }; f</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Code after <literal>!</literal> evaluated in shell</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The helpers described above are actually named <literal>git-credential-cache</literal>, <literal>git-credential-store</literal>,
and so on. We can configure them to take command-line arguments.
The general form for this is <literal>git-credential-foo [args] &lt;action&gt;.</literal>
The stdin/stdout usage is the same as <literal>git credential</literal>, but with a slightly different set of actions.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>get</literal> is a request for a username/password pair.</simpara>
</listitem>
<listitem>
<simpara><literal>store</literal> is a request to save a set of credentials in this helper&#8217;s memory.</simpara>
</listitem>
<listitem>
<simpara><literal>erase</literal> purges the credentials for the given properties from this helper&#8217;s memory.</simpara>
</listitem>
</itemizedlist>
<simpara>For the <literal>store</literal> and <literal>erase</literal> actions, no response is required.
For the <literal>get</literal> action, however, Git is very interested in what the helper has to say.
If the helper doesn&#8217;t know anything useful, it can simply exit with no output,
but if it does know something, it should augment the provided information with the information it has stored.
The output is treated like a series of assignment statements. Anything provided replaces what
Git already knows.</simpara>
<simpara>Here&#8217;s the same example from above, but skipping <literal>git git-credential</literal> and going straight
for <literal>git git-credential-store</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git credential-store --file ~/git.store store <co xml:id="CO5-1"/>
protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <co xml:id="CO5-2"/>
protocol=https
host=mygithost

username=bob <co xml:id="CO5-3"/>
password=s3cre7</programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>Save some credentials: the username <literal>bob</literal> and the password <literal>s3cre7</literal> are to be used when <literal>https://mygithost</literal> is accessed.</para>
</callout>
<callout arearefs="CO5-2">
<para>Retrieve those credentials.
Provide the parts of the connection we already know (<literal>https://mygithost</literal>), and an empty line.</para>
</callout>
<callout arearefs="CO5-3">
<para>Reply with the username and password stored above.</para>
</callout>
</calloutlist>
<simpara>Here&#8217;s how the <literal>~/git.store</literal> file looks.</simpara>
<programlisting language="ini" linenumbering="unnumbered">https://bob:s3cre7@mygithost</programlisting>
<simpara>It&#8217;s just a series of lines, each of which contains a credential-decorated URL.
The <literal>osxkeychain</literal> and <literal>wincred</literal> helpers use the native format of their backing stores,
while <literal>cache</literal> uses its own in-memory format (which no other process can read).</simpara>
</section>
<section xml:id="_a_custom_credential_cache">
<title>A Custom Credential Cache</title>
<simpara>Given that <literal>git-credential-store</literal> and friends are separate programs from Git,
it&#8217;s not much of a leap to realize that <emphasis>any</emphasis> program can be a Git credential helper.
The helpers provided by Git cover many, but not all, common use cases.
For example, let&#8217;s say your team has some credentials that are shared with the entire team,
perhaps for deployment. These are stored in a shared directory, but you don&#8217;t want to copy them
to your own credential store, because they change often.
None of the existing helpers cover this case. Let&#8217;s see what it would take to write our own.
There are several key features this program needs to have.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The only action we need to pay attention to is <literal>get</literal>. <literal>store</literal> and <literal>erase</literal> are write operations, so we just exit cleanly when they&#8217;re received.</simpara>
</listitem>
<listitem>
<simpara>The file format of the shared-credential file is the same as that used by <literal>git-credential-store</literal>.</simpara>
</listitem>
<listitem>
<simpara>The location of that file is fairly standard, but we should allow the user to pass a custom path just in case.</simpara>
</listitem>
</orderedlist>
<simpara>Once again, we write this extension in Ruby, but any language works as long as Git can
execute the finished product. Here&#8217;s the full source code of our new credential helper.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#!/usr/bin/env ruby

require 'optparse'

path = File.expand_path '~/.git-credentials' <co xml:id="CO6-1"/>
OptionParser.new do |opts|
    opts.banner = 'USAGE: git-credential-read-only [options] &lt;action&gt;'
    opts.on('-f', '--file PATH', 'Specify path for backing store') do |argpath|
        path = File.expand_path argpath
    end
end.parse!

exit(0) unless ARGV[0].downcase == 'get' <co xml:id="CO6-2"/>
exit(0) unless File.exists? path

known = {} <co xml:id="CO6-3"/>
while line = STDIN.gets
    break if line.strip == ''
    k,v = line.strip.split '=', 2
    known[k] = v
end

File.readlines(path).each do |fileline| <co xml:id="CO6-4"/>
    prot,user,pass,host = fileline.scan(/^(.*?):\/\/(.*?):(.*?)@(.*)$/).first
    if prot == known['protocol'] and host == known['host'] and user == known['username'] then
        puts "protocol=#{prot}"
        puts "host=#{host}"
        puts "username=#{user}"
        puts "password=#{pass}"
        exit(0)
    end
end</programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>Parse the command-line flags, allowing the user to specify the input file. The default is <literal>~/.git-credentials</literal>.</para>
</callout>
<callout arearefs="CO6-2">
<para>This program only responds if the action is <literal>get</literal> and the backing-store file exists.</para>
</callout>
<callout arearefs="CO6-3">
<para>This loop reads from stdin until the first blank line is reached.
The inputs are stored in the <literal>known</literal> hash for later reference.</para>
</callout>
<callout arearefs="CO6-4">
<para>This loop reads the content of the storage file, looking for matches.
If the protocol and host from <literal>known</literal> match this line, the program prints the results to stdout and exits.</para>
</callout>
</calloutlist>
<simpara>We save our helper as <literal>git-credential-read-only</literal>, put it somewhere in our <literal>PATH</literal>, and mark it executable.
Here&#8217;s what an interactive session looks like.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7</programlisting>
<simpara>Since its name starts with <literal>git-</literal>, we can use the simple syntax for the configuration value.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global credential.helper 'read-only --file /mnt/shared/creds'</programlisting>
<simpara>As you can see, extending this system is pretty straightforward,
and can solve some common problems for you and your team.</simpara>
</section>
</section>
<section xml:id="_summary_9">
<title>Summary</title>
<simpara>You’ve seen a number of advanced tools that manipulate your commits and staging area more precisely.
When you notice issues, you should be able to easily figure out what commit introduced them, when, and by whom.
You’ve learned how to use subprojects to accommodate those needs. At this point, you should be able to
do most of the things in Git that you need day to day and feel comfortable doing so.</simpara>
</section>
</chapter>
<chapter xml:id="ch08-customizing-git">
<title>Customizing Git</title>
<simpara>So far, we&#8217;ve covered the basics of how Git works and how to use it, and we&#8217;ve introduced a number of
tools that help make it easier to use. In this chapter, we see how to customize Git
by introducing the hooks feature and several important configuration settings. With these, it&#8217;s easy
to get Git to work exactly the way you, your company, and/or your group, want.</simpara>
<section xml:id="_git_config">
<title>Git Configuration</title>
<simpara><indexterm>
<primary>git commands</primary><secondary>config</secondary>
</indexterm>
<indexterm>
<primary>config</primary>
</indexterm>
As you briefly saw in <xref linkend="ch01-getting-started"/>,
Git configuration options are specified by running <literal>git config</literal>.
One of the first things you did was to set up your name and email address.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com</programlisting>
<simpara>Now you learn a few of the presumably more interesting options to customize your Git usage.</simpara>
<simpara>First, a quick review. Git uses a layer of configuration files to determine non-default behavior.
The first place Git looks for these options is <literal>/etc/gitconfig</literal>, which contains
the configuration options everyone on the system uses in all repositories.
If you add <literal>--system</literal> to <literal>git config</literal>, it reads and writes from this file,
assuming you have permission to do so.</simpara>
<simpara>The next place Git looks is <literal>~/.gitconfig</literal> (or <literal>~/.config/git/config</literal>), which is specific to each user,
and is used whenever the user accesses any repositories.
<literal>git config</literal> reads from and writes to this file when you add the <literal>--global</literal> flag.</simpara>
<simpara>Finally, Git looks for configuration options in the configuration file in the Git
directory (<literal>.git/config</literal>) of whatever repository you&#8217;re currently using.
These options are specific to that specific repository.</simpara>
<simpara>Each of these levels (system, global, local) overrides options in the previous level,
so options in <literal>.git/config</literal> trump those in <literal>/etc/gitconfig</literal>, for instance.</simpara>
<note>
<simpara>Git&#8217;s configuration files are in plain-text, so you can also configure these options by
manually editing a file. It&#8217;s generally easier to run <literal>git config</literal>, though.</simpara>
</note>
<section xml:id="_basic_client_configuration">
<title>Basic Client Configuration</title>
<simpara>The configuration options recognized by Git fall into two categories: client-side and server-side.
The majority of the options are client-side&#8201;&#8212;&#8201;they configure your personal preferences when you run <literal>git</literal>.
Many, <emphasis>many</emphasis> configuration options are supported, but a large fraction of them are only useful
in certain edge cases. We&#8217;re only covering the most common and most useful here.
To see a list of all the options your version of Git recognizes, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ man git-config</programlisting>
<simpara>This lists all the available options in quite a bit of detail.
You can also see this at <link xl:href="http://git-scm.com/docs/git-config.html">http://git-scm.com/docs/git-config.html</link>.</simpara>
<section xml:id="_literal_core_editor_literal">
<title><literal>core.editor</literal></title>
<simpara><indexterm>
<primary>$EDITOR</primary>
</indexterm><indexterm>
<primary>$VISUAL</primary><secondary>see $EDITOR</secondary>
</indexterm>
<indexterm>
<primary>see $EDITOR</primary>
</indexterm>
By default, Git uses whatever you&#8217;ve set as your default text editor in the <literal>$VISUAL</literal> or <literal>$EDITOR</literal>
environment variables. If neither of these are set, Git falls back to using <literal>vi</literal> to create and edit
commit and tag messages. To change to something else, use the <literal>core.editor</literal> setting.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global core.editor emacs</programlisting>
<simpara>Now, no matter what&#8217;s set as your default text editor, Git uses <literal>emacs</literal> to edit messages.</simpara>
</section>
<section xml:id="_literal_commit_template_literal">
<title><literal>commit.template</literal></title>
<simpara><indexterm>
<primary>commit templates</primary>
</indexterm>
If you set this to the path of a file, Git uses that file as the default message when you commit.
For instance, suppose you create <literal>~/.gitmessage.txt</literal> that contains</simpara>
<programlisting language="text" linenumbering="unnumbered">Subject line (try to keep under 50 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]</programlisting>
<simpara>Note how this commit template reminds the committer to keep the subject line short (for
the sake of <literal>git log --oneline</literal> output), to add further detail to the message, and to refer
to an issue or bug tracker ticket number if one exists.</simpara>
<simpara>Tell Git to use this file as the default message that appears in your editor when you
run <literal>git commit</literal> by setting the <literal>commit.template</literal> configuration value.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global commit.template ~/.gitmessage.txt
$ git commit</programlisting>
<simpara>Then, your editor opens with this as the default commit message when you run <literal>git commit</literal>.</simpara>
<programlisting language="text" linenumbering="unnumbered">Subject line (try to keep under 50 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
# modified:   lib/test.rb
#
~
~
".git/COMMIT_EDITMSG" 14L, 297C</programlisting>
<simpara>If your team has a commit message policy, then putting a template containing the required text
on your system and configuring Git to use it by default helps increase the chance of that policy
being followed.</simpara>
</section>
<section xml:id="_literal_core_pager_literal">
<title><literal>core.pager</literal></title>
<simpara><indexterm>
<primary>pager</primary>
</indexterm>
This option determines which pager Git uses when producing output from commands such
as <literal>git log</literal> and <literal>git diff</literal>. Set it to <literal>more</literal> or to your favorite pager (by default, it&#8217;s <literal>less</literal>),
or turn it off by setting it to a blank string.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global core.pager ''</programlisting>
<simpara>If you run that, Git pages the entire output of all commands, no matter how long they are.</simpara>
</section>
<section xml:id="_literal_user_signingkey_literal">
<title><literal>user.signingkey</literal></title>
<simpara><indexterm>
<primary>GPG</primary>
</indexterm>
If you&#8217;re making signed annotated tags (as discussed in <xref linkend="_signing"/>),
setting your GPG signing key as a configuration option makes things easier.
Set your key ID by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global user.signingkey &lt;gpg-key-id&gt;</programlisting>
<simpara>Now, you can sign tags without having to specify your key every time with the <literal>git tag</literal> command.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag -s &lt;tag-name&gt;</programlisting>
</section>
<section xml:id="_literal_core_excludesfile_literal">
<title><literal>core.excludesfile</literal></title>
<simpara><indexterm>
<primary>excludes</primary>
</indexterm><indexterm>
<primary>.gitignore</primary>
</indexterm>
Put file selection patterns in your project&#8217;s <literal>.gitignore</literal> file so that Git doesn&#8217;t see the files as untracked
or try to stage them when you run <literal>git add</literal> on them,
as discussed in <xref linkend="_ignoring"/>.</simpara>
<simpara>But sometimes you want to ignore certain files for all repositories that you work with.
If your computer is running Mac OS X, you&#8217;re probably familiar with <literal>.DS_Store</literal> files.
If you use <literal>emacs</literal> or <literal>vim</literal>, you know about files whose name ends with a <literal>~</literal> or <literal>.swp</literal>.</simpara>
<simpara>This option lets you write a kind of global <literal>.gitignore</literal> file.
If you create a <literal>~/.gitignore_global</literal> file with this content</simpara>
<programlisting language="ini" linenumbering="unnumbered">*~
.*.swp
.DS_Store</programlisting>
<simpara>and you run <literal>git config --global core.excludesfile ~/.gitignore_global</literal>,
Git never again bothers you about those files.</simpara>
</section>
<section xml:id="_literal_help_autocorrect_literal">
<title><literal>help.autocorrect</literal></title>
<simpara><indexterm>
<primary>autocorrect</primary>
</indexterm>
If you mistype a command, Git shows something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git chekcout master
git: 'chekcout' is not a git command. See 'git --help'.

Did you mean this?
    checkout</programlisting>
<simpara>Git helpfully tries to figure out what you meant, but doesn&#8217;t actually run the command it suggests.
If you set <literal>help.autocorrect</literal> to 1, Git actually runs the suggested command.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git chekcout master
WARNING: You called a Git command named 'chekcout', which does not exist.
Continuing under the assumption that you meant 'checkout'
in 0.1 seconds automatically...</programlisting>
<simpara>Note that <literal>0.1 seconds</literal> business. <literal>help.autocorrect</literal> is actually an integer that represents tenths of a second.
So if you set it to 50, Git gives you 5 seconds to change your mind before executing the suggested command.</simpara>
</section>
</section>
<section xml:id="_colors_in_git">
<title>Colors in Git</title>
<simpara><indexterm>
<primary>color</primary>
</indexterm>
Git fully supports colored terminal output, which greatly aids in visually parsing command
output quickly and easily. A number of options can help set your coloring preference.</simpara>
<section xml:id="_literal_color_ui_literal">
<title><literal>color.ui</literal></title>
<simpara>Git automatically colors most of its output, but there&#8217;s a master switch if you don&#8217;t like this behavior.
To turn off all Git&#8217;s colored terminal output, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global color.ui false</programlisting>
<simpara>The default value is <literal>auto</literal>, which colors output when it&#8217;s going straight to a terminal,
but not when the output is redirected to a pipe or a file.</simpara>
<simpara>You can also set it to <literal>always</literal> to ignore the difference between terminals and pipes.
You rarely want to do this. In most scenarios, if you want color codes in your redirected output,
add the <literal>--color</literal> flag to the Git command to force it to use color codes.
The default value is almost always what you want.</simpara>
</section>
<section xml:id="_literal_color_literal">
<title><literal>color.*</literal></title>
<simpara>To be more specific about which commands are colored and how, Git provides verb-specific coloring options.
Each of these can be set to <literal>true</literal>, <literal>false</literal>, or <literal>always</literal>.</simpara>
<literallayout class="monospaced">color.branch
color.diff
color.interactive
color.status</literallayout>
<simpara>In addition, each of these has suboptions for setting specific colors for parts of the output
to override each color. For example, to set the meta information in your diff output to a blue foreground,
black background, and bold text, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global color.diff.meta "blue black bold"</programlisting>
<simpara>You can set the color to any of the following values: <literal>normal</literal>, <literal>black</literal>, <literal>red</literal>, <literal>green</literal>,
<literal>yellow</literal>, <literal>blue</literal>, <literal>magenta</literal>, <literal>cyan</literal>, or <literal>white</literal>. If you want an attribute like bold in the previous example,
choose from <literal>bold</literal>, <literal>dim</literal>, <literal>ul</literal> (underline), <literal>blink</literal>, or <literal>reverse</literal> (swap foreground and background).</simpara>
</section>
</section>
<section xml:id="_external_merge_tools">
<title>External Merge and Diff Tools</title>
<simpara><indexterm>
<primary>mergetool</primary>
</indexterm><indexterm>
<primary>difftool</primary>
</indexterm>
Although Git has an internal implementation of diff, which is what we&#8217;ve been showing in this book,
you can configure Git to use an external diff tool instead. You can also set up a GUI merge
conflict resolution tool instead of having to resolve conflicts manually.
We demonstrate setting up the Perforce Visual Merge Tool (P4Merge) to do your diffs and merge resolutions,
because it&#8217;s a nice GUI tool and it&#8217;s free.</simpara>
<simpara>P4Merge works on all major platforms, so you should be able to try it out.
We use path names in the examples that work on Mac and Linux systems. For Windows,
make sure <literal>p4merge</literal> is in a directory in your <literal>PATH</literal> environment variable.</simpara>
<simpara>To begin, <link xl:href="https://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools">download
P4Merge from Perforce</link>.
Next, set up external wrapper scripts to run your commands.
We use the Mac path for the executable. In other systems, it&#8217;s where the <literal>p4merge</literal> binary is installed.
Create a merge wrapper script named <literal>extMerge</literal> that calls your binary with all the arguments provided.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*</programlisting>
<simpara>The diff wrapper checks to make sure seven arguments are provided and passes two of them to your merge script.
By default, Git passes the following arguments to the diff program:</simpara>
<screen>path old-file old-hex old-mode new-file new-hex new-mode</screen>
<simpara>Because you only want the <literal>old-file</literal> and <literal>new-file</literal> arguments, use the wrapper script
to pass the ones you need.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat /usr/local/bin/extDiff
#!/bin/sh
[ $# -eq 7 ] &amp;&amp; /usr/local/bin/extMerge "$2" "$5"</programlisting>
<simpara>Make sure the files for these tools are executable.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo chmod +x /usr/local/bin/extMerge
$ sudo chmod +x /usr/local/bin/extDiff</programlisting>
<simpara>Now set up your config file to use your custom merge resolution and diff tools.
This requires a number of custom options&#8201;&#8212;&#8201;<literal>merge.tool</literal> to tell Git what strategy to use,
<literal>mergetool.&lt;tool&gt;.cmd</literal> to specify how to run the command, <literal>mergetool.&lt;tool&gt;.trustExitCode</literal> to tell
Git if the exit code of that command indicates a successful merge resolution,
and <literal>diff.external</literal> to tell Git what command to run to show diffs.
So, either run the following four config commands:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global merge.tool extMerge
$ git config --global mergetool.extMerge.cmd \
  'extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"'
$ git config --global mergetool.extMerge.trustExitCode false
$ git config --global diff.external extDiff</programlisting>
<simpara>or add the following lines to  <literal>~/.gitconfig</literal>:</simpara>
<programlisting language="ini" linenumbering="unnumbered">[merge]
  tool = extMerge
[mergetool "extMerge"]
  cmd = extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"
  trustExitCode = false
[diff]
  external = extDiff</programlisting>
<simpara>After all this is done, if you run diff commands such as</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff 32d1776b1^ 32d1776b1</programlisting>
<simpara>Instead of getting the diff output on the command line, Git fires up P4Merge, which looks something like</simpara>
<figure>
<title>P4Merge.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/p4merge.png"/>
</imageobject>
<textobject><phrase>P4Merge.</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you try to merge two branches and subsequently have merge conflicts, run <literal>git mergetool</literal>.
It runs P4Merge to resolve the conflicts using a GUI tool.</simpara>
<simpara>The nice thing about this wrapper setup is that you can change your diff and merge tools so easily.
For example, to change your <literal>extDiff</literal> and <literal>extMerge</literal> tools to run the KDiff3 tool instead,
all you have to do is edit your <literal>extMerge</literal> file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*</programlisting>
<simpara>Now, Git uses the KDiff3 tool for diff viewing and merge conflict resolution.</simpara>
<simpara>Git comes preconfigured to use a number of other merge-resolution tools so you don&#8217;t
have to set up the command configuration. To see a list of the tools Git supports, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git mergetool --tool-help
'git mergetool --tool=&lt;tool&gt;' may be set to one of the following:
        emerge
        gvimdiff
        gvimdiff2
        opendiff
        p4merge
        vimdiff
        vimdiff2

The following tools are valid, but not currently available:
        araxis
        bc3
        codecompare
        deltawalker
        diffmerge
        diffuse
        ecmerge
        kdiff3
        meld
        tkdiff
        tortoisemerge
        xxdiff

Some of the tools listed above only work in a windowed
environment. If run in a terminal-only session, they will fail.</programlisting>
<simpara>If you&#8217;re not interested in using <literal>kdiff3</literal> for diff but rather want to use it just
for merge resolution, and it&#8217;s in your path, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global merge.tool kdiff3</programlisting>
<simpara>If you run this instead of setting up the <literal>extMerge</literal> and <literal>extDiff</literal> files, Git uses kdiff3
for merge resolution and the normal Git diff tool for diffs.</simpara>
</section>
<section xml:id="_formatting_and_whitespace">
<title>Formatting and Whitespace</title>
<simpara><indexterm>
<primary>whitespace</primary>
</indexterm>
Formatting and whitespace issues are some of the more frustrating and subtle problems
that many developers encounter when collaborating, especially cross-platform.
It&#8217;s very easy for patches or other collaborative work to introduce subtle whitespace changes
because editors silently introduce them, and if your files ever touch a Windows system,
their line endings might be replaced. Git has a few configuration options to help with these issues.</simpara>
<section xml:id="_literal_core_autocrlf_literal">
<title><literal>core.autocrlf</literal></title>
<simpara><indexterm>
<primary>crlf</primary>
</indexterm><indexterm>
<primary>line endings</primary>
</indexterm>
If you&#8217;re on Windows and working with people who aren&#8217;t (or vice-versa), you&#8217;ll probably run into
line-ending issues at some point. This is because Windows uses both a carriage-return character and
a linefeed character at the end of lines, whereas Mac and Linux systems use only a linefeed.
This is a subtle but incredibly annoying fact of cross-platform work. Many editors on Windows
silently replace existing LF-style line endings with CRLF, or insert both characters when
the user types the enter key.</simpara>
<simpara>Git can handle this by converting CRLF line endings into LF when you add a file to the index,
and vice versa when it checks out a file. You can turn on this conversion with the <literal>core.autocrlf</literal> setting.
If you&#8217;re on Windows, set it to <literal>true</literal>&#8201;&#8212;&#8201;this converts LF endings into CRLF when you check out files.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global core.autocrlf true</programlisting>
<simpara>If you&#8217;re on a Linux or Mac system that uses LF line endings, then you don&#8217;t want Git to
automatically convert them when you check out files. However, if a file with CRLF endings
accidentally gets introduced, then you may want Git to fix it.
You can tell Git to convert CRLF to LF on commit but not the other way around by
setting <literal>core.autocrlf</literal> to input.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global core.autocrlf input</programlisting>
<simpara>This setup should leave CRLF endings in Windows checkouts,
but LF endings on Mac and Linux systems and in the repository.</simpara>
<simpara>If you&#8217;re on Windows doing a Windows-only project, then you can turn this off,
storing the CR in the repository by setting the config value to <literal>false</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global core.autocrlf false</programlisting>
</section>
<section xml:id="_literal_core_whitespace_literal">
<title><literal>core.whitespace</literal></title>
<simpara>Git comes preconfigured to detect and fix some whitespace issues.
It can look for six primary whitespace issues&#8201;&#8212;&#8201;three are enabled by default but can be turned off,
and three are disabled by default but can be turned on.</simpara>
<simpara>The three that are turned on by default are <literal>blank-at-eol</literal>, which looks for spaces at the end of a line,
<literal>blank-at-eof</literal>, which looks for  blank lines at the end of a file, and <literal>space-before-tab</literal>,
which looks for spaces before tabs at the beginning of a line.</simpara>
<simpara>The three that are disabled by default but can be turned on are <literal>indent-with-non-tab</literal>,
which looks for lines that begin with spaces instead of tabs (and is controlled by the <literal>tabwidth</literal> option),
<literal>tab-in-indent</literal>, which watches for tabs in the indentation portion of a line, and <literal>cr-at-eol</literal>,
which tells Git that carriage returns at the end of lines are OK.</simpara>
<simpara>You can tell Git which of these you want enabled by setting <literal>core.whitespace</literal> to the values you want
on or off, separated by commas. Disable options by either leaving them out of the option string
or prepending a <literal>-</literal> in front of the value. For example, to set all but <literal>space-before-tab</literal>, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global core.whitespace \
    trailing-space,-space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol</programlisting>
<simpara>(<literal>trailing-space</literal> is short-hand for the combination of <literal>blank-at-eol</literal> and <literal>blank-at-eof</literal>)</simpara>
<simpara>Or specify the customizing part only.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global core.whitespace \
    -space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol</programlisting>
<simpara>Git detects these issues when you run <literal>git diff</literal> and tries to color its output so you can fix
them before you commit. It also uses these values to help when you apply patches by running <literal>git apply</literal>.
When you&#8217;re applying patches, you can ask Git to warn you if it&#8217;s applying patches with the
specified whitespace issues.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git apply --whitespace=warn &lt;patch&gt;</programlisting>
<simpara>Or you can have Git try to automatically fix the issue before applying the patch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git apply --whitespace=fix &lt;patch&gt;</programlisting>
<simpara>These options apply to <literal>git rebase</literal> as well.
If you&#8217;ve committed whitespace issues but haven&#8217;t yet pushed upstream, run <literal>git rebase --whitespace=fix</literal>
to have Git automatically fix whitespace issues as it rewrites the patches.</simpara>
</section>
</section>
<section xml:id="_server_configuration">
<title>Server Configuration</title>
<simpara>Not nearly as many configuration options are available for the server side of Git,
but there are a few interesting ones to take note of.</simpara>
<section xml:id="_literal_receive_fsckobjects_literal">
<title><literal>receive.fsckObjects</literal></title>
<simpara>Git is capable of making sure every object received during a push still matches its SHA-1 hash
and is a valid object. However, it doesn&#8217;t do this by default. This is a fairly expensive operation,
and might slow down a command, especially on large repositories or pushes.
To force Git to check object consistency on every push, set <literal>receive.fsckObjects</literal> to true.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --system receive.fsckObjects true</programlisting>
<simpara>Now, Git checks the integrity of your repository before each push is accepted to make sure faulty
(or malicious) clients aren&#8217;t introducing corrupt data.</simpara>
</section>
<section xml:id="_literal_receive_denynonfastforwards_literal">
<title><literal>receive.denyNonFastForwards</literal></title>
<simpara>If you rebase commits that you&#8217;ve already pushed and then try to push again, or otherwise
try to push a commit to a remote branch that doesn&#8217;t contain the commit that the remote branch
currently points to, your push is denied. This is generally good policy but in the case of the rebase,
you may determine that you know what you&#8217;re doing and can force-update the remote branch
with the <literal>-f</literal> flag to <literal>git push</literal>.</simpara>
<simpara>To tell Git to refuse force-pushes, set <literal>receive.denyNonFastForwards</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --system receive.denyNonFastForwards true</programlisting>
<simpara>The other way to do this is via server-side receive hooks, which we cover in a bit.
That approach lets you do more complex things like deny non-fast-forward commits to a certain subset of users.</simpara>
</section>
<section xml:id="_literal_receive_denydeletes_literal">
<title><literal>receive.denyDeletes</literal></title>
<simpara>One of the workarounds to the <literal>denyNonFastForwards</literal> policy is for the user to delete the
branch and then push it again with the new reference. To avoid this, set <literal>receive.denyDeletes</literal> to true.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --system receive.denyDeletes true</programlisting>
<simpara>This denies any deletion of branches or tags&#8201;&#8212;&#8201;no user can do it.
There are also more interesting ways to allow these deletes on a per-user basis via ACLs,
as you learn in <xref linkend="_an_example_git_enforced_policy"/>.</simpara>
</section>
</section>
</section>
<section xml:id="_git_attributes">
<title>Git Attributes</title>
<simpara><indexterm>
<primary>attributes</primary>
</indexterm>
Some settings can also be specified for a path, so that Git applies them only for a subdirectory
or subset of files. These path-specific settings are called Git attributes and are set either
in a <literal>.gitattributes</literal> file in one of your directories (normally the root of your project)
or in the <literal>.git/info/attributes</literal> file if you don&#8217;t want the attributes file committed with your project.</simpara>
<simpara>Using attributes, you can do things like specify separate merge strategies for individual
files or directories, tell Git how to diff non-text files, or have Git filter content before you check
it in or out. In this section, you learn some of the attributes you can set on paths and see a few
examples of how to use this feature in practice.</simpara>
<section xml:id="_binary_files">
<title>Binary Files</title>
<simpara><indexterm>
<primary>binary files</primary>
</indexterm>
One cool trick for using Git attributes is telling Git which files are binary (in cases when
Git otherwise may not be able to figure it out), and giving Git special instructions
on how to handle those files. For instance, some text files may be machine generated and not diffable,
whereas some binary files can be diffed. You can tell Git which is which.</simpara>
<section xml:id="_identifying_binary_files">
<title>Identifying Binary Files</title>
<simpara>Some files look like they contain text but for all intents and purposes should be treated as binary data.
For instance, Xcode projects on the Mac contain a file that ends in <literal>.pbxproj</literal>, which
is basically a JSON file containing your build settings written by the Xcode IDE.
Although it&#8217;s technically a text file (because it&#8217;s all UTF-8), you don&#8217;t want to
treat it as such because it&#8217;s really a lightweight database. You can&#8217;t merge its content if two
people change it, and diffs generally aren&#8217;t useful. The file is meant to be consumed by a program.
In essence, Git should treat it like a binary file.</simpara>
<simpara>To tell Git to treat all <literal>pbxproj</literal> files as binary files, add the following line to <literal>.gitattributes</literal>:</simpara>
<programlisting language="ini" linenumbering="unnumbered">*.pbxproj binary</programlisting>
<simpara>Now Git doesn&#8217;t try to convert or fix CRLF issues, nor does it try to compute or print a diff
for changes in this file when you run <literal>git show</literal> or <literal>git diff</literal>.</simpara>
</section>
<section xml:id="_diffing_binary_files">
<title>Diffing Binary Files</title>
<simpara>You can also use Git attributes to effectively diff binary files.
You do this by telling Git how to convert the binary data into a text format that a normal diff can compare.</simpara>
<simpara>Here&#8217;s how to use this technique to solve one of the most annoying problems known to humanity:
version-controlling Microsoft Word documents. Everyone knows that Word is the most horrific editor around,
but oddly, everyone still uses it. To version-control Word documents, you can stick them in a
Git repository and commit every once in a while. But what good does that do?
If you run <literal>git diff</literal> normally, you only see something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 88839c4..4afcb7c 100644
Binary files a/chapter1.docx and b/chapter1.docx differ</programlisting>
<simpara>You can&#8217;t directly compare two Word files unless you check them out and examine them manually, right?
It turns out you can do this fairly easily using Git attributes.
Put the following line in <literal>.gitattributes</literal>:</simpara>
<programlisting language="ini" linenumbering="unnumbered">*.docx diff=word</programlisting>
<simpara>This tells Git that any file whose name matches this pattern (<literal>.docx</literal>) should use the <literal>word</literal> filter
when you try to view a diff of Word files. What&#8217;s the <literal>word</literal> filter? You have to install it.
Here you configure Git to use the <literal>docx2txt</literal> program to convert Word documents into readable text files,
which Git can then diff properly.</simpara>
<simpara>First, install <literal>docx2txt</literal>. Download it from <link xl:href="http://docx2txt.sourceforge.net">http://docx2txt.sourceforge.net</link>.
Follow the instructions in the <literal>INSTALL</literal> file to put <literal>docx2txt.pl</literal> in a directory in your
PATH environment variable. Next, write a wrapper script to convert output to the format Git expects.
Create a file called <literal>docx2txt</literal> in a directory in your PATH, and add this content to it.</simpara>
<programlisting language="console" linenumbering="unnumbered">#!/bin/bash
docx2txt.pl "$1" -</programlisting>
<simpara>Don&#8217;t forget to run <literal>chmod a+x</literal> on that file.
Finally, configure Git to use this file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config diff.word.textconv docx2txt</programlisting>
<simpara>Now Git knows that if it tries to diff two files, and any of them end in <literal>.docx</literal>,
it should run those files through the <literal>word</literal> filter, which is defined as the <literal>docx2txt</literal> program.
It makes text-based versions of your Word files before attempting to diff them.</simpara>
<simpara>As an example Chapter 1 of this book was converted to Word format and committed in a Git repository.
Then a new paragraph was added. Here&#8217;s what <literal>git diff</literal> shows.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 0b013ca..ba25db5 100644
--- a/chapter1.docx
+++ b/chapter1.docx
@@ -2,6 +2,7 @@
 This chapter will be about getting started with Git. We will begin at the beginning by explaining some background on version control tools, then move on to how to get Git running on your system and finally how to get it setup to start working with. At the end of this chapter you should understand why Git is around, why you should use it and you should be all setup to do so.
 1.1. About Version Control
 What is "version control", and why should you care? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. For the examples in this book you will use software source code as the files being version controlled, though in reality you can do this with nearly any type of file on a computer.
+Testing: 1, 2, 3.
 If you are a graphic or web designer and want to keep every version of an image or layout (which you would most certainly want to), a Version Control System (VCS) is a very wise thing to use. It allows you to revert files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead.
 1.1.1. Local Version Control Systems
 Many people's version-control method of choice is to copy files into another directory (perhaps a time-stamped directory, if they're clever). This approach is very common because it is so simple, but it is also incredibly error prone. It is easy to forget which directory you're in and accidentally write to the wrong file or copy over files you don't mean to.</programlisting>
<simpara>Git successfully and succinctly tells us that we added the string <literal>Testing: 1, 2, 3.</literal>, which is correct.
It&#8217;s not perfect&#8201;&#8212;&#8201;formatting changes won&#8217;t show up&#8201;&#8212;&#8201;but it certainly works.</simpara>
<simpara>Another interesting problem you can solve this way involves diffing image files.
One way to do this is to run them through a filter that extracts their EXIF information&#8201;&#8212;&#8201;metadata
that&#8217;s recorded with most image formats. If you download and install the <literal>exiftool</literal> program,
you can use it to extract the metadata from an image file, so at least the diff shows any metadata changes.
Put the following line in <literal>.gitattributes</literal>:</simpara>
<programlisting language="ini" linenumbering="unnumbered">*.png diff=exif</programlisting>
<simpara>Configure Git to use this tool.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config diff.exif.textconv exiftool</programlisting>
<simpara>If you replace an image in your project and run <literal>git diff</literal>, you see something like</simpara>
<programlisting language="diff" linenumbering="unnumbered">diff --git a/image.png b/image.png
index 88839c4..4afcb7c 100644
--- a/image.png
+++ b/image.png
@@ -1,12 +1,12 @@
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha</programlisting>
<simpara>You can easily see that the file size and image dimensions have both changed.</simpara>
</section>
</section>
<section xml:id="_keyword_expansion">
<title>Keyword Expansion</title>
<simpara><indexterm>
<primary>keyword expansion</primary>
</indexterm></simpara>
<simpara>SVN- or CVS-style keyword expansion is often requested by developers.
The main problem with this is that in Git you can&#8217;t modify a file with information about the commit
after you&#8217;ve committed, because that would change the SHA-1 hash of the committed file, making the hash invalid.
However, you can inject text into a file when it&#8217;s checked out and remove the text before the
file is added to a commit. Git attributes offer two ways to do this.</simpara>
<simpara>First, inject the SHA-1 hash of a file into an <literal>$Id$</literal> field in the file automatically.
If you set this attribute on a file, then the next time you check out a branch containing the file,
Git replaces that field with the SHA-1 hash of the file.
It&#8217;s important to notice that it isn&#8217;t the SHA-1 hash of the commit, but that of the file itself.
Put the following line in your <literal>.gitattributes</literal> file:</simpara>
<programlisting language="ini" linenumbering="unnumbered">*.txt ident</programlisting>
<simpara>Add an <literal>$Id$</literal> reference to a test file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo '$Id$' &gt; test.txt</programlisting>
<simpara>The next time you check out this file, Git injects its SHA-1 hash.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ rm test.txt
$ git checkout -- test.txt
$ cat test.txt
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $</programlisting>
<simpara>However, that result is of limited use.
If you&#8217;ve used keyword substitution in CVS or Subversion, you know you can include a
datestamp&#8201;&#8212;&#8201;the SHA-1 hash isn&#8217;t all that helpful, because you can&#8217;t tell if one SHA-1 hash
is older or newer than another just by looking at them.</simpara>
<simpara>It turns out that you can write your own filters for doing substitutions in files when they&#8217;re
committed or checked out. These are called <literal>clean</literal> and <literal>smudge</literal> filters.
In <literal>.gitattributes</literal>, you can set a filter for particular paths and then set up scripts
that process files just before they&#8217;re checked out (<literal>smudge</literal>, see <xref linkend="filters_a"/>) and
just before they&#8217;re staged (<literal>clean</literal>, see <xref linkend="filters_b"/>).
These filters can be set to do all sorts of fun things.</simpara>
<figure xml:id="filters_a">
<title>The &#8220;smudge&#8221; filter is run on checkout.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/smudge.png"/>
</imageobject>
<textobject><phrase>The ``smudge'' filter is run on checkout.</phrase></textobject>
</mediaobject>
</figure>
<figure xml:id="filters_b">
<title>The &#8220;clean&#8221; filter is run when files are staged.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/clean.png"/>
</imageobject>
<textobject><phrase>The ``clean'' filter is run when files are staged.</phrase></textobject>
</mediaobject>
</figure>
<simpara>One example of when this might be useful is running all your C source code through the <literal>indent</literal>
program before committing to make sure all your source code is formatted according to your standard.
Set this up by setting the filter attribute in <literal>.gitattributes</literal> to filter <literal>*.c</literal> files
with the <literal>indent</literal> filter.</simpara>
<programlisting language="ini" linenumbering="unnumbered">*.c filter=indent</programlisting>
<simpara>Then, tell Git what the <literal>indent</literal> filter does on smudge and clean.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global filter.indent.clean indent
$ git config --global filter.indent.smudge cat</programlisting>
<simpara>In this case, when you commit files whose name matches the pattern <literal>*.c</literal>, Git runs them through the indent
program before it stages them and then runs them through the <literal>cat</literal> program before it checks them
back out onto disk. The <literal>cat</literal> program does essentially nothing. It outputs the same data that comes in.
This combination effectively filters all C source code files through <literal>indent</literal> before committing.</simpara>
<simpara>Another interesting example implements <literal>$Date$</literal> keyword expansion, RCS style.
To do this properly, you need a small script that takes a filename, figures out the last commit
date for the repository containing the file, and inserts that date into the file.
Here&#8217;s a small Ruby script that does that.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#! /usr/bin/env ruby
data = STDIN.read
last_date = `git log --pretty=format:"%ad" -1`
puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')</programlisting>
<simpara>All the script does is get the latest commit date from <literal>git log</literal>, sticks that into any <literal>$Date$</literal>
strings it sees in stdin, and outputs the results. It should be simple to do in whatever language
you&#8217;re most comfortable in. Name this file <literal>expand_date</literal> and put it in your PATH.
Now, set up a filter in Git (call it <literal>dater</literal>) and tell it to use your <literal>expand_date</literal> filter
to smudge the files on checkout. You can use a Perl expression to clean that up on commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config filter.dater.smudge expand_date
$ git config filter.dater.clean 'perl -pe "s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'</programlisting>
<simpara>This Perl snippet strips out anything it sees in a <literal>$Date$</literal> string, to get back to where you started.
Now that your filter is ready, test it by setting up a Git attribute for that file that engages the
new filter and creating a file with your <literal>$Date$</literal> keyword.</simpara>
<programlisting language="ini" linenumbering="unnumbered">date*.txt filter=dater</programlisting>
<programlisting language="console" linenumbering="unnumbered">$ echo '# $Date$' &gt; date_test.txt</programlisting>
<simpara>If you commit those changes and check out the file again, you see the keyword properly substituted.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git add date_test.txt .gitattributes
$ git commit -m "Testing date expansion in Git"
$ rm date_test.txt
$ git checkout date_test.txt
$ cat date_test.txt
# $Date: Tue Apr 21 07:26:52 2009 -0700$</programlisting>
<simpara>You can see how powerful this technique can be for customized applications.
You have to be careful, though, because <literal>.gitattributes</literal> is committed and passed
around with the project, but the filter (in this case, <literal>dater</literal>) isn&#8217;t, so this technique doesn&#8217;t
work without the filter. When you design these filters, they should be able to fail gracefully
but the project should still work properly.</simpara>
</section>
<section xml:id="_exporting_your_repository">
<title>Exporting Your Repository</title>
<simpara><indexterm>
<primary>archiving</primary>
</indexterm>
Git attributes also allow doing some interesting things when exporting an archive of your project.</simpara>
<section xml:id="_literal_export_ignore_literal">
<title><literal>export-ignore</literal></title>
<simpara>You can tell Git to not export certain files or directories when generating an archive.
If there&#8217;s a subdirectory or file that you don&#8217;t want to include in an archive but that you do
want in your project, specify those files using the <literal>export-ignore</literal> attribute.</simpara>
<simpara>For example, say you have some test files in a <literal>test/</literal> subdirectory, and it doesn&#8217;t make sense
to include them in a tarball export of your project. Add the following line to <literal>.gitattributes</literal>:</simpara>
<programlisting language="ini" linenumbering="unnumbered">test/ export-ignore</programlisting>
<simpara>Now, when you run <literal>git archive</literal> to create a tarball of your project, the files in <literal>test</literal> won&#8217;t be included in the archive.</simpara>
</section>
<section xml:id="_literal_export_subst_literal">
<title><literal>export-subst</literal></title>
<simpara>When exporting files for deployment you can apply the formatting and keyword-expansion processing
of <literal>git log</literal> to selected portions of files marked with the <literal>export-subst</literal> attribute.</simpara>
<simpara>For instance, to include a file named <literal>LAST_COMMIT</literal> in your project, and have metadata about the
last commit automatically injected into it when <literal>git archive</literal> runs, set up <literal>.gitattributes</literal>
and <literal>LAST_COMMIT</literal> like this.</simpara>
<programlisting language="ini" linenumbering="unnumbered">LAST_COMMIT export-subst</programlisting>
<programlisting language="console" linenumbering="unnumbered">$ echo 'Last commit date: $Format:%cd by %aN$' &gt; LAST_COMMIT
$ git add LAST_COMMIT .gitattributes
$ git commit -am 'adding LAST_COMMIT file for archives'</programlisting>
<simpara>When you run <literal>git archive</literal>, the content of the archived file looks like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git archive HEAD | tar xCf ../deployment-testing -
$ cat ../deployment-testing/LAST_COMMIT
Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon</programlisting>
<simpara>The substitutions can include the commit message and any Git notes, for example,
and <literal>git log</literal> can do simple word wrapping.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo '$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$' &gt; LAST_COMMIT
$ git commit -am 'export-subst uses git log'\''s custom formatter

git archive uses git log'\''s `pretty=format:` processor
directly, and strips the surrounding `$Format:` and `$`
markup from the output.
'
$ git archive @ | tar xfO - LAST_COMMIT
Last commit: 312ccc8 by Jim Hill at Fri May 8 09:14:04 2015 -0700
       export-subst uses git log's custom formatter

         git archive uses git log's `pretty=format:` processor directly, and
         strips the surrounding `$Format:` and `$` markup from the output.</programlisting>
<simpara>The resulting archive is suitable for deployment, but like any exported archive it isn&#8217;t suitable
for further development work.</simpara>
</section>
</section>
<section xml:id="_merge_strategies">
<title>Merge Strategies</title>
<simpara><indexterm>
<primary>merging</primary><secondary>strategies</secondary>
</indexterm>
<indexterm>
<primary>strategies</primary>
</indexterm>
You can also use Git attributes to tell Git to use different merge strategies for
specific files. One very useful option is to tell Git to not try merging specific
files when they have conflicts, but rather to use your changes instead of someone else&#8217;s.</simpara>
<simpara>This is helpful if a branch in your project has diverged, but you want to merge changes back in from it,
and you want to ignore certain files. Say you have a database settings file called <literal>database.xml</literal> that&#8217;s
different in two branches, and you want to merge in your other branch without messing up the database file.
You can set up an attribute like</simpara>
<programlisting language="ini" linenumbering="unnumbered">database.xml merge=ours</programlisting>
<simpara>And then define a dummy <literal>ours</literal> merge strategy with</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config --global merge.ours.driver true</programlisting>
<simpara>If you merge in the other branch, instead of having merge conflicts with <literal>database.xml</literal>, you see something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge topic
Auto-merging database.xml
Merge made by recursive.</programlisting>
<simpara>In this case, <literal>database.xml</literal> isn&#8217;t changed.</simpara>
</section>
</section>
<section xml:id="_git_hooks">
<title>Git Hooks</title>
<simpara><indexterm>
<primary>hooks</primary>
</indexterm>
Like many other VCSs, Git has a way to run custom scripts when certain important actions occur.
These scripts are called hooks.
There are two kinds of hooks: client-side and server-side.
Client-side hooks are triggered by operations such as committing and merging,
while server-side hooks key off of network operations such as receiving pushed commits.
You can use these hooks in all sorts of ways.</simpara>
<section xml:id="_installing_a_hook">
<title>Installing a Hook</title>
<simpara>The hooks are all stored in <literal>.git/hooks</literal>.
When you initialize a new repository by running <literal>git init</literal>, Git populates the hooks directory with a
bunch of example scripts, many of which are useful by themselves.
The scripts also document the input values they expect.
All the examples are written as shell scripts, with some Perl thrown in,
but any properly named executable script works fine&#8201;&#8212;&#8201;you can write them in Ruby, Python, or what have you.
To use the bundled hook scripts, you have to rename them. Their filenames all end with <literal>.sample</literal>.</simpara>
<simpara>To enable a hook script, put the file containing the script in the repository&#8217;s`.git/hooks` directory.
The hook script must be named appropriately (without any extension) and be executable.
From that point forward, it runs when the hook event occurs.
We cover most of the major hooks here.</simpara>
</section>
<section xml:id="_client_side_hooks">
<title>Client-Side Hooks</title>
<simpara>There are a lot of client-side hooks.
This section splits them into committing-workflow hooks, email-workflow hooks, and everything else.</simpara>
<note>
<simpara>It&#8217;s important to note that client-side hooks are <emphasis role="strong">not</emphasis> copied when you clone a repository.
If you intend for these scripts to enforce a policy, do that server-side.
See the example in <xref linkend="_an_example_git_enforced_policy"/>.</simpara>
</note>
<section xml:id="_committing_workflow_hooks">
<title>Committing-Workflow Hooks</title>
<simpara>The first four hooks have to do with the committing process.</simpara>
<simpara>The <literal>pre-commit</literal> hook runs first, before you even enter a commit message.
The hook is used to inspect the snapshot that&#8217;s about to be committed to see if you&#8217;ve forgotten something,
to make sure tests run, or to examine whatever you need to inspect in the commit.
Exiting non-zero from this hook aborts the commit, although you can override this behavior by
running <literal>git commit --no-verify</literal>. You can do things like check for code style (by running <literal>lint</literal> or something
equivalent), check for trailing whitespace (the default hook does exactly this),
or check for appropriate documentation on new methods.</simpara>
<simpara>The <literal>prepare-commit-msg</literal> hook runs before the commit message editor starts but after
the default message is created. This hook can edit the commit message before the committer sees it.
This hook takes a few parameters&#8201;&#8212;&#8201;the path to the file that holds the commit message so far,
the type of commit, and the commit&#8217;s SHA-1 hash if this is an amended commit.
This hook generally isn&#8217;t useful for normal commits. Rather, it&#8217;s good for commits where the
default message is auto-generated, such as templated commit messages, merge commits,
squashed commits, and amended commits. You may use it in conjunction with a commit template
to programmatically insert information.</simpara>
<simpara>The <literal>commit-msg</literal> hook takes one parameter, which again is the path to a temporary file that
contains the commit message written by the developer. If this script exits non-zero,
Git aborts the commit process, so you can use the hook to validate your project state
or commit message before allowing a commit to complete.
In the last section of this chapter, we demonstrate using this hook to check that your commit
message is conformant to a required pattern.</simpara>
<simpara>After the entire commit process is completed, the <literal>post-commit</literal> hook runs.
It doesn&#8217;t take any parameters, but you can easily get the last commit by running <literal>git log -1 HEAD</literal>.
Generally, this script is used for notification or something similar.</simpara>
</section>
<section xml:id="_email_hooks">
<title>Email Workflow Hooks</title>
<simpara>You can set up three client-side hooks for an email-based workflow.
They&#8217;re all invoked by running <literal>git am</literal>, so if you aren&#8217;t using that command in your workflow,
you can safely skip to the next section.
If you&#8217;re taking patches over email prepared by <literal>git format-patch</literal>, then some of these may be helpful to you.</simpara>
<simpara>The first hook  to run is <literal>applypatch-msg</literal>.
It takes a single argument&#8201;&#8212;&#8201;the name of the temporary file that contains the proposed commit message.
Git aborts the patch if this script exits non-zero.
You can use this to make sure the commit message is properly formatted, or to normalize the
message by having the script edit it in place.</simpara>
<simpara>The next hook to run when applying patches via <literal>git am</literal> is <literal>pre-applypatch</literal>.
Somewhat confusingly, it&#8217;s run <emphasis>after</emphasis> the patch is applied but before the commit is made,
so you can use it to inspect the snapshot before making the commit.
You can run tests or otherwise inspect the working directory with this script.
If something is missing or the tests don&#8217;t pass, exiting non-zero aborts <literal>git am</literal> without
committing the change.</simpara>
<simpara>The last hook to run during <literal>git am</literal> is <literal>post-applypatch</literal>, which runs after the commit is made.
You can use it to notify a group or the author of the patch that the patch has been applied and committed.
You can&#8217;t stop the patching process with this script.</simpara>
</section>
<section xml:id="_other_client_hooks">
<title>Other Client Hooks</title>
<simpara>The <literal>pre-rebase</literal> hook runs before you rebase anything. It can halt the process by exiting non-zero.
You can use this hook to disallow rebasing any commits that have already been pushed.
The example <literal>pre-rebase</literal> hook that Git installs does this,
although it makes some assumptions that may not match your workflow.</simpara>
<simpara>The <literal>post-rewrite</literal> hook is run by commands that replace commits, such as <literal>git commit --amend</literal>
and <literal>git rebase</literal> (though not by <literal>git filter-branch</literal>). Its single argument is the command that
triggered the rewrite, and it receives a list of rewrites on <literal>stdin</literal>.
This hook has many of the same uses as the <literal>post-checkout</literal> and <literal>post-merge</literal> hooks.</simpara>
<simpara>After you run a successful <literal>git checkout</literal>, the <literal>post-checkout</literal> hook runs.
You can use it to set up your working directory properly for your project environment.
This may mean moving in large binary files that you don&#8217;t want source controlled,
auto-generating documentation, or something along those lines.</simpara>
<simpara>The <literal>post-merge</literal> hook runs after a successful <literal>git merge</literal>.
You can use it to restore data in the working directory that Git can&#8217;t track, such as permissions data.
This hook can likewise validate the presence of files external to Git control that you want copied
in when the working directory changes.</simpara>
<simpara>The <literal>pre-push</literal> hook runs during <literal>git push</literal>, after the remote refs have been updated but
before any objects have been transferred.
It receives the name and location of the remote as parameters,
and a list of to-be-updated refs through <literal>stdin</literal>. You can use it to validate a set of ref updates
before a push occurs. A non-zero exit code aborts the push.</simpara>
<simpara>Git occasionally does garbage collection as part of its normal operation by running <literal>git gc --auto</literal>.
The <literal>pre-auto-gc</literal> hook is invoked just before garbage collection takes place,
and can be used to notify you that this is happening so that you can abort garbage collection if now isn&#8217;t a good time.</simpara>
</section>
</section>
<section xml:id="_server_side_hooks">
<title>Server-Side Hooks</title>
<simpara>In addition to the client-side hooks, There are a couple of important server-side hooks a system
administrator can use to enforce nearly any kind of policy. These scripts run before and after pushes
to the server. The pre hooks can exit non-zero at any time to reject the push as well as to send
an error message back to the client. You can set up a push policy that&#8217;s as complex as you wish.</simpara>
<section xml:id="_literal_pre_receive_literal">
<title><literal>pre-receive</literal></title>
<simpara>The first script that runs when handling a push from a client is <literal>pre-receive</literal>.
It takes a list of references that are being pushed from stdin. If it exits non-zero,
none of them are accepted. You can use this hook to do things like make sure none of the updated
references are non-fast-forwards, or to do access control for all the refs and files they&#8217;re modifying.</simpara>
</section>
<section xml:id="_literal_update_literal">
<title><literal>update</literal></title>
<simpara>The <literal>update</literal> script is very similar to the <literal>pre-receive</literal> script, except that it&#8217;s run once for each
branch being updated. If the pusher is trying to push to multiple branches, <literal>pre-receive</literal> runs only once,
whereas <literal>update</literal> runs once per branch. Instead of reading from stdin,
this script takes three arguments&#8201;&#8212;&#8201;the name of the reference (branch), the SHA-1 hash that
reference pointed to before the push, and the SHA-1 hash of what the user is trying to push.
If the update script exits non-zero, only that reference is rejected. Other references can still be updated.</simpara>
</section>
<section xml:id="_literal_post_receive_literal">
<title><literal>post-receive</literal></title>
<simpara>The <literal>post-receive</literal> hook runs after the entire process is completed and can be used to update
other services or notify users. It reads the same data from stdin as the <literal>pre-receive</literal> hook.
Examples include emailing a list, notifying a continuous integration server, or updating
a ticket-tracking system. You can even parse the commit messages to see if any tickets need to be opened,
modified, or closed. This script can&#8217;t stop the push, but the client doesn&#8217;t disconnect until the
script has completed, so be careful if you try to do anything that may take a long time.</simpara>
</section>
</section>
</section>
<section xml:id="_an_example_git_enforced_policy">
<title>An Example Git-Enforced Policy</title>
<simpara><indexterm>
<primary>policy example</primary>
</indexterm>
In this section, you use what you&#8217;ve learned to establish a Git workflow that checks for a custom
commit message format, and allows only certain users to modify certain subdirectories in a project.
You build client scripts that help the developer know if their push is rejected and
server scripts that actually enforce the policies.</simpara>
<simpara>The scripts we show are written in Ruby, partly because of our intellectual inertia, but also
because Ruby is easy to read, even if you can&#8217;t write it.
However, any language works. All the sample hook scripts distributed with Git are in either Perl or Bash,
so you can see plenty of examples of hooks in those languages by looking at the samples.</simpara>
<section xml:id="_server_side_hook">
<title>Server-Side Hook</title>
<simpara>All the server-side work goes into the <literal>update</literal> file in your <literal>hooks</literal> directory.
The <literal>update</literal> hook runs once per branch being pushed and takes the following three arguments:</simpara>
<itemizedlist>
<listitem>
<simpara>The name of the reference being pushed to</simpara>
</listitem>
<listitem>
<simpara>The branch&#8217;s old revision</simpara>
</listitem>
<listitem>
<simpara>The new revision being pushed</simpara>
</listitem>
</itemizedlist>
<simpara>You also have access to the username of the user doing the pushing if the push is being run over SSH.
If you&#8217;ve allowed everyone to connect using a single username (like <literal>git</literal>) via public-key authentication,
you may have to give that user a shell wrapper that determines which user is actually connecting based
on the public key, and set an environment variable accordingly.
Here we assume the connecting username is in the <literal>$USER</literal> environment variable,
so your update script begins by gathering all the information you need.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#!/usr/bin/env ruby

$refname = ARGV[0]
$oldrev  = ARGV[1]
$newrev  = ARGV[2]
$user    = ENV['USER']

puts "Enforcing Policies..."
puts "(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})"</programlisting>
<simpara>Yes, those are global variables.
Don&#8217;t judge&#8201;&#8212;&#8201;it&#8217;s easier to demonstrate this way.</simpara>
<section xml:id="_enforcing_commit_message_format">
<title>Enforcing a Specific Commit-Message Format</title>
<simpara>Your first challenge is to enforce a format that each commit message must adhere to.
Just to have a target, assume that each message must include a string that looks like <literal>ref: 1234</literal> because
you want each commit to link to an item in your ticketing system.
You must look at each commit being pushed, see if the required string is in the commit message, and,
if the string is absent from any of the commits, exit non-zero so the push is rejected.</simpara>
<simpara>You can get a list of the SHA-1 hashes of all the commits that are being pushed by taking
the <literal>$newrev</literal> and <literal>$oldrev</literal> values and passing them to the plumbing command <literal>git rev-list</literal>.
This is basically the same output as that produced by <literal>git log</literal>, but by default it shows only the
SHA-1 hashes and no other information.
So, to get a list of all the commit SHA-1 hashes introduced between one commit and another, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rev-list 538c33..d14fc7
d14fc7c847ab946ec39590d87783c69b031bdfb7
9f585da4401b0a3999e84113824d15245c13f0be
234071a1be950e2a8d078e6141f5cd20c1e61ad3
dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475</programlisting>
<simpara>You can take that output, loop through each of those commit SHA-1 hashes, grab the message for it, and test that message against a regular expression that looks for a pattern.</simpara>
<simpara>You have to figure out how to get the commit message from each of these commits to test.
To get the raw commit data, use another plumbing command called <literal>git cat-file</literal>.
We go over all these plumbing commands in detail in <xref linkend="ch10-git-internals"/> but for now,
here&#8217;s what that command shows.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file commit ca82a6
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the version number</programlisting>
<simpara>A simple way to get the commit message from a commit when you have its SHA-1 hash is to go to
the first blank line and take everything after that.
You can do so by running the <literal>sed</literal> command on Unix systems.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file commit ca82a6 | sed '1,/^$/d'
changed the version number</programlisting>
<simpara>You can use that command to grab the commit message from each commit that&#8217;s being pushed and exit
if you see anything that doesn&#8217;t match. To exit the script and reject the push, exit non-zero.
The whole method looks like</simpara>
<programlisting language="ruby" linenumbering="unnumbered">$regex = /\[ref: (\d+)\]/

# enforced custom commit message format
def check_message_format
  missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  missed_revs.each do |rev|
    message = `git cat-file commit #{rev} | sed '1,/^$/d'`
    if !$regex.match(message)
      puts "[POLICY] Your message is not formatted correctly"
      exit 1
    end
  end
end
check_message_format</programlisting>
<simpara>Putting that in your <literal>update</literal> script rejects updates that contain commits that have messages
that don&#8217;t adhere to your message formatting rule.</simpara>
</section>
<section xml:id="_enforcing_a_user_based_acl_system">
<title>Enforcing a User-Based ACL System</title>
<simpara>Suppose you want to add a mechanism that uses an access control list (ACL) to specify which users are allowed
to push changes to certain parts of your projects. Some people have full access, and others can only push
changes to certain subdirectories or specific files.
To enforce this, put those rules in a file named <literal>acl</literal> in your bare Git repository on the server.
Have the <literal>update</literal> hook look at those rules, see what files are being introduced in all
the commits being pushed, and determine whether the user doing the push is allowed to update all those files.</simpara>
<simpara>The first thing to do is write your ACL.
Here you use a format very much like the CVS ACL mechanism. The format uses a series of lines,
where the first field is <literal>avail</literal> or <literal>unavail</literal>, the next field is a comma-delimited list of the
users to which the rule applies, and the last field is the path to which the rule applies
(blank meaning open access).
All of these fields are delimited by vertical bar (<literal>|</literal>) characters.</simpara>
<simpara>In this case, you have a couple of administrators, some documentation writers with access to
the <literal>doc</literal> directory, and one developer who only has access to the <literal>lib</literal> and <literal>tests</literal> directories.
Your ACL file looks like</simpara>
<screen>avail|nickh,pjhyett,defunkt,tpw
avail|usinclair,cdickens,ebronte|doc
avail|schacon|lib
avail|schacon|tests</screen>
<simpara>Begin by reading this data into a structure.
In this case, to keep the example simple, only enforce the <literal>avail</literal> directives.
Here&#8217;s a method that gives an associative array where the key is the user name and the value
is an array of paths to which the user has write access.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def get_acl_access_data(acl_file)
  # read in ACL data
  acl_file = File.read(acl_file).split("\n").reject { |line| line == '' }
  access = {}
  acl_file.each do |line|
    avail, users, path = line.split('|')
    next unless avail == 'avail'
    users.split(',').each do |user|
      access[user] ||= []
      access[user] &lt;&lt; path
    end
  end
  access
end</programlisting>
<simpara>In the ACL file you looked at earlier, this <literal>get_acl_access_data</literal> method returns a data structure that
looks like</simpara>
<programlisting language="ruby" linenumbering="unnumbered">{"defunkt"=&gt;[nil],
 "tpw"=&gt;[nil],
 "nickh"=&gt;[nil],
 "pjhyett"=&gt;[nil],
 "schacon"=&gt;["lib", "tests"],
 "cdickens"=&gt;["doc"],
 "usinclair"=&gt;["doc"],
 "ebronte"=&gt;["doc"]}</programlisting>
<simpara>Now that you have the permissions sorted out, determine what paths the commits being pushed have
modified, so you can make sure the user who&#8217;s pushing has access to all of them.</simpara>
<simpara>You can pretty easily see what files have been modified in a single commit by adding the <literal>--name-only</literal>
option to <literal>git log</literal> (mentioned briefly in <xref linkend="ch02-git-basics-chapter"/>).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -1 --name-only --pretty=format:'' 9f585d

README
lib/test.rb</programlisting>
<simpara>If you use the ACL structure returned from the <literal>get_acl_access_data</literal> method and check it against the
listed files in each of the commits, you determine whether the user has access to push all of their commits.</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('acl')

  # see if anyone is trying to push something they can't
  new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  new_commits.each do |rev|
    files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`.split("\n")
    files_modified.each do |path|
      next if path.size == 0
      has_file_access = false
      access[$user].each do |access_path|
        if !access_path  # user has access to everything
           || (path.start_with? access_path) # access to this path
          has_file_access = true
        end
      end
      if !has_file_access
        puts "[POLICY] You do not have access to push to #{path}"
        exit 1
      end
    end
  end
end

check_directory_perms</programlisting>
<simpara>You get a list of new commits being pushed to your server with <literal>git rev-list</literal>.
Then, for each of those commits, find which files are modified and make sure the user who&#8217;s
pushing has access to all the paths being modified.</simpara>
<simpara>Now your users can&#8217;t push any commits with badly formed messages or with modified files
outside of their designated paths.</simpara>
</section>
<section xml:id="_testing_it_out">
<title>Testing It Out</title>
<simpara>If you run <literal>chmod u+x .git/hooks/update</literal>, and then try to push a commit with a non-compliant message,
you get something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push -f origin master
Counting objects: 5, done.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 323 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
Enforcing Policies...
(refs/heads/master) (8338c5) (c5b616)
[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
To git@gitserver:project.git
 ! [remote rejected] master -&gt; master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'</programlisting>
<simpara>There are a couple of interesting things here.
First, you see the hook start running.</simpara>
<programlisting language="console" linenumbering="unnumbered">Enforcing Policies...
(refs/heads/master) (fb8c72) (c56860)</programlisting>
<simpara>Remember that you printed that at the very beginning of your update script.
Anything your script echoes to <literal>stdout</literal> is transferred to the client.</simpara>
<simpara>The next thing you notice is the error message.</simpara>
<programlisting language="console" linenumbering="unnumbered">[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master</programlisting>
<simpara>The first line was printed by you, the other two were Git telling you that the update script
exited non-zero and that your push is being declined.
Lastly, you have</simpara>
<programlisting language="console" linenumbering="unnumbered">To git@gitserver:project.git
 ! [remote rejected] master -&gt; master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'</programlisting>
<simpara>You see a remote reject message for each reference that your hook declined,
saying that it was declined specifically because of a hook failure.</simpara>
<simpara>Furthermore, if someone tries to edit a file they don&#8217;t have access to and push a commit containing it,
they see something similar. For instance, if a documentation author tries to push a commit
modifying something in the <literal>lib</literal> directory, they see</simpara>
<programlisting language="console" linenumbering="unnumbered">[POLICY] You do not have access to push to lib/test.rb</programlisting>
<simpara>From now on, as long as that <literal>update</literal> script is present and executable,
your repository never has a commit message without the required pattern in it.</simpara>
</section>
</section>
<section xml:id="_client_side_hooks_2">
<title>Client-Side Hooks</title>
<simpara>The downside to this approach is the whining that inevitably results when your users' commit
pushes are rejected. Having their carefully crafted work rejected at the last minute can be extremely
frustrating and confusing. Furthermore, they have to edit their history to correct it,
which isn&#8217;t always for the faint of heart.</simpara>
<simpara>The answer to this dilemma is to provide client-side hooks that notify users when they&#8217;re doing
something that the server is likely to reject. That way, the users can correct any problems before
committing and before those issues become more difficult to fix. Because hooks aren&#8217;t transferred when
a project is cloned, you must distribute these scripts some other way and then have your users copy
them to their <literal>.git/hooks</literal> directory and make them executable.
You can distribute these hooks within the project or in a separate project,
but Git doesn&#8217;t get them automatically.</simpara>
<simpara>To begin, check your commit message just before each commit is recorded,
so you know the server isn&#8217;t going to reject your changes due to badly formatted commit messages.
To do this, add the <literal>commit-msg</literal> hook.
If it reads the message from the file passed as the first argument and compares it to the required pattern,
you can force Git to abort the commit if there&#8217;s no match.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#!/usr/bin/env ruby
message_file = ARGV[0]
message = File.read(message_file)

$regex = /\[ref: (\d+)\]/

if !$regex.match(message)
  puts "[POLICY] Your message is not formatted correctly"
  exit 1
end</programlisting>
<simpara>If that script is present (in <literal>.git/hooks/commit-msg</literal>) and executable,
and you commit with a message that isn&#8217;t properly formatted, you see</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit -am 'test'
[POLICY] Your message is not formatted correctly</programlisting>
<simpara>No commit was completed.
However, if your message contains the proper pattern, Git allows the commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit -am 'test [ref: 132]'
[master e05c914] test [ref: 132]
 1 file changed, 1 insertions(+), 0 deletions(-)</programlisting>
<simpara>Next, make sure you aren&#8217;t modifying files that aren&#8217;t allowed by your ACL.
If your project&#8217;s <literal>.git</literal> directory contains a copy of the ACL file you used previously,
then the following <literal>pre-commit</literal> script enforces those constraints:</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#!/usr/bin/env ruby

$user    = ENV['USER']

# [ insert acl_access_data method from above ]

# only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('.git/acl')

  files_modified = `git diff-index --cached --name-only HEAD`.split("\n")
  files_modified.each do |path|
    next if path.size == 0
    has_file_access = false
    access[$user].each do |access_path|
    if !access_path || (path.index(access_path) == 0)
      has_file_access = true
    end
    if !has_file_access
      puts "[POLICY] You do not have access to push to #{path}"
      exit 1
    end
  end
end

check_directory_perms</programlisting>
<simpara>This is roughly the same script as the server-side part, but with two important differences.
First, the ACL file is in a different place, because this script runs from your working directory,
not from your <literal>.git</literal> directory. You have to change the path to the ACL file from this</simpara>
<programlisting language="ruby" linenumbering="unnumbered">access = get_acl_access_data('acl')</programlisting>
<simpara>to this.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">access = get_acl_access_data('.git/acl')</programlisting>
<simpara>The other important difference is the way you get a listing of the changed files.
Because the server-side method looks at the log of commits, and, at this point, the commit
hasn&#8217;t been recorded yet, you must get your changed file list from the staging area instead.
Instead of</simpara>
<programlisting language="ruby" linenumbering="unnumbered">files_modified = `git log -1 --name-only --pretty=format:'' #{ref}`</programlisting>
<simpara>you have to use</simpara>
<programlisting language="ruby" linenumbering="unnumbered">files_modified = `git diff-index --cached --name-only HEAD`</programlisting>
<simpara>But those are the only two differences&#8201;&#8212;&#8201;otherwise, the script works the same way.
One caveat is that it expects you to be running locally as the same user you push as.
If this isn&#8217;t true, you must set the <literal>$USER</literal> environment variable manually.</simpara>
<simpara>One other thing we can do here is make sure the user doesn&#8217;t push non-fast-forwarded references.
To get a reference that isn&#8217;t a fast-forward, you either have to rebase past a commit you&#8217;ve
already pushed or try pushing a different local branch to the same remote branch.</simpara>
<simpara>Presumably, the server is already configured with <literal>receive.denyDeletes</literal> and <literal>receive.denyNonFastForwards</literal>
to enforce this policy, so the only accidental thing you can try to catch is rebasing commits that have
already been pushed.</simpara>
<simpara>Here&#8217;s an example pre-rebase script that checks for that.
It gets a list of all the commits you&#8217;re about to rewrite and checks whether they exist in any of
your remote references. If it sees one that&#8217;s reachable from one of your remote references,
it aborts the rebase.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#!/usr/bin/env ruby

base_branch = ARGV[0]
if ARGV[1]
  topic_branch = ARGV[1]
else
  topic_branch = "HEAD"
end

target_shas = `git rev-list #{base_branch}..#{topic_branch}`.split("\n")
remote_refs = `git branch -r`.split("\n").map { |r| r.strip }

target_shas.each do |sha|
  remote_refs.each do |remote_ref|
    shas_pushed = `git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
    if shas_pushed.split("\n").include?(sha)
      puts "[POLICY] Commit #{sha} has already been pushed to #{remote_ref}"
      exit 1
    end
  end
end</programlisting>
<simpara>This script uses a syntax that wasn&#8217;t covered in <xref linkend="_revision_selection"/>.
You get a list of commits that have already been pushed by running</simpara>
<programlisting language="ruby" linenumbering="unnumbered">`git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`</programlisting>
<simpara>The <literal>sha^@</literal> syntax resolves to all the parents of that commit.
You&#8217;re looking for any commit that&#8217;s reachable from the last commit on the remote that isn&#8217;t
reachable from any parent of any of the SHA-1 hash you&#8217;re trying to push up&#8201;&#8212;&#8201;meaning it&#8217;s a fast-forward.</simpara>
<simpara>The main drawback to this approach is that it can be very slow and is often unnecessary.
If you don&#8217;t try to force the push with <literal>-f</literal>, the server warns you and doesn&#8217;t accept the push.
However, it&#8217;s an interesting exercise and can in theory help avoid a rebase that you might later
have to go back and fix.</simpara>
</section>
</section>
<section xml:id="_summary_10">
<title>Summary</title>
<simpara>We&#8217;ve covered most of the major ways to customize your Git client and server.
You&#8217;ve learned about all sorts of configuration settings, file-based attributes, event hooks,
and you&#8217;ve built an example policy-enforcing server.
You should now be able to make Git fit nearly any workflow you can dream up.</simpara>
</section>
</chapter>
<chapter xml:id="ch09-git-and-other-systems">
<title>Git and Other Version Control Systems</title>
<simpara>The world isn&#8217;t perfect.
You can&#8217;t always immediately convert every project you come in contact with to Git.
Sometimes you&#8217;re stuck on a project using another VCS.
We spend the first part of this chapter learning about how to use Git as a client when the project
you&#8217;re working on is hosted on a different VCS.</simpara>
<simpara>The second part of this chapter covers how to migrate an existing project from several VCSs
into Git, as well as a method that works if no pre-built import tool exists.</simpara>
<section xml:id="_git_as_a_client">
<title>Git as a Client</title>
<simpara><indexterm>
<primary>Git as a client</primary>
</indexterm>
Git provides such a nice experience that many people prefer to use it,
even if the rest of their team is using an entirely different VCS.
For this to happen, a "bridge" must exist between Git and the other VCS.
Fortunately, many bridges have been created.
Here we cover the ones you&#8217;re most likely to run into.</simpara>
<section xml:id="_git_svn">
<title>Git and Subversion</title>
<simpara><indexterm>
<primary>Subversion</primary>
</indexterm><indexterm>
<primary>Interoperation with other VCSs</primary><secondary>Subversion</secondary>
</indexterm>
<indexterm>
<primary>Subversion</primary>
</indexterm>
A large fraction of open source development projects and a good number of corporate projects use Subversion.
It&#8217;s been around for more than a decade, and for most of that time was the <emphasis>de facto</emphasis> VCS
choice for open-source projects. It&#8217;s also very similar in many ways to CVS, which was the big boy
of the VCS world before Subversion came out. <indexterm>
<primary>git commands</primary><secondary>svn</secondary>
</indexterm>
<indexterm>
<primary>svn</primary>
</indexterm><indexterm>
<primary>git-svn</primary>
</indexterm></simpara>
<simpara>One of Git&#8217;s great features is a bidirectional bridge to Subversion called <literal>git svn</literal>.
This tool allows you to use Git as a client to a Subversion server, so you can use all the local
features of Git and then push to a Subversion server.
This means you can do local branching and merging, use the staging area, rebasing, and cherry-picking,
and so on, while your collaborators continue to work in their dark and ancient ways.
It&#8217;s a good way to sneak Git into the corporate environment and help your fellow developers become
more efficient while you lobby to get the infrastructure changed to accept Git.
The Subversion bridge is a gateway drug to the DVCS world.</simpara>
<section xml:id="_literal_git_svn_literal">
<title><literal>git svn</literal></title>
<simpara>The base Git command for all the Subversion bridging commands is <literal>git svn</literal>.
It takes quite a few subcommands, so we show the most common while going through a few simple workflows.</simpara>
<simpara>It&#8217;s important to note that when you&#8217;re using <literal>git svn</literal>, you&#8217;re interacting with Subversion,
which works very differently than Git.
Although you <emphasis role="strong">can</emphasis> do local branching and merging, it&#8217;s generally best to keep your history as
linear as possible by rebasing your work, and avoiding doing things like simultaneously interacting
with a Git remote repository.</simpara>
<simpara>Don&#8217;t rewrite your history and try to push again, and don&#8217;t push to a parallel Git repository
to collaborate with fellow Git developers at the same time.
Subversion can have only a single linear history, and confusing it is very easy.
If you&#8217;re working with a team, and some are using Subversion and others are using Git,
make sure everyone is using the Subversion server to collaborate. This makes your life easier.</simpara>
</section>
<section xml:id="_setting_up">
<title>Setting Up</title>
<simpara>To demonstrate this, you need an Subversion repository that you have write access to.
To copy these examples, make a writeable copy of a Subversion repository.
To do that, run the <literal>svnsync</literal> tool that comes with Subversion.
For these tests, we created a new Subversion repository on Google Code that was a partial copy
of the <literal>protobuf</literal> project, which is a tool that encodes structured data for network transmission.</simpara>
<simpara>To follow along, first create a new local Subversion repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ mkdir /tmp/test-svn
$ svnadmin create /tmp/test-svn</programlisting>
<simpara>Then, enable all users to change revprops. The easy way to do this is to add a <literal>pre-revprop-change</literal>
script that always exits 0.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat /tmp/test-svn/hooks/pre-revprop-change
#!/bin/sh
exit 0;
$ chmod +x /tmp/test-svn/hooks/pre-revprop-change</programlisting>
<simpara>Now sync this project to your local machine by running <literal>svnsync init</literal> with the destination
and source repositories.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ svnsync init file:///tmp/test-svn \
  http://your-svn-server.example.org/svn/</programlisting>
<simpara>This sets up the properties to run the sync. Then clone the code by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ svnsync sync file:///tmp/test-svn
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .............................[...]
Committed revision 2.
Copied properties for revision 2.
[…]</programlisting>
<simpara>Although this operation may take only a few minutes, if you try to copy the original repository
to another remote repository instead of a local one, the process takes nearly an hour, even
though there are fewer than 100 commits.
Subversion has to clone one revision at a time and then push it to another repository.
This is ridiculously inefficient, but it&#8217;s the only easy way to do it.</simpara>
</section>
<section xml:id="_getting_started">
<title>Getting Started</title>
<simpara>Now that you have a Subversion repository to which you have write access, you can go through a
typical workflow. Start with <literal>git svn clone</literal>, which imports an entire Subversion repository into a local
Git repository. Remember that if you&#8217;re importing from a real hosted Subversion repository,
you should replace the <literal>file:///tmp/test-svn</literal> here with the URL of the Subversion repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn clone file:///tmp/test-svn -T trunk -b branches -t tags
Initialized empty Git repository in /private/tmp/progit/test-svn/.git/
r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)
    A	m4/acx_pthread.m4
    A	m4/stl_hash.m4
    A	java/src/test/java/com/google/protobuf/UnknownFieldSetTest.java
    A	java/src/test/java/com/google/protobuf/WireFormatTest.java
…
r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)
Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/my-calc-branch, 75
Found branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae
Following parent with do_switch
Successfully followed parent
r76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)
Checked out HEAD:
  file:///tmp/test-svn/trunk r75</programlisting>
<simpara>This runs the equivalent of two commands&#8201;&#8212;&#8201;<literal>git svn init</literal> followed by <literal>git svn fetch</literal>&#8201;&#8212;&#8201;using
the URL you provide. This can take a while. The test project has only about 75 commits and
the codebase isn&#8217;t that big, but Git has to check out each version, one at a time, and commit it individually.
For a project with hundreds or thousands of commits, this can literally take hours or even days to finish.</simpara>
<simpara>The <literal>-T trunk -b branches -t tags</literal> flags tell Git that this Subversion repository follows
the basic branching and tagging conventions. If you name your trunk, branches, or tags differently,
change these flags. Because this is so common, you can replace these three flags with <literal>-s</literal>,
which means standard layout and implies all those flags. The following command is equivalent:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn clone file:///tmp/test-svn -s</programlisting>
<simpara>At this point, you should have a valid Git repository containing your imported branches and tags.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch -a
* master
  remotes/origin/my-calc-branch
  remotes/origin/tags/2.0.2
  remotes/origin/tags/release-2.0.1
  remotes/origin/tags/release-2.0.2
  remotes/origin/tags/release-2.0.2rc1
  remotes/origin/trunk</programlisting>
<simpara>Note how this tool manages Subversion tags as remote refs.
<indexterm>
<primary>git commands</primary><secondary>show-ref</secondary>
</indexterm>
<indexterm>
<primary>show-ref</primary>
</indexterm>
Let&#8217;s take a closer look by running the Git plumbing command <literal>git show-ref</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show-ref
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master
0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branch
bfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2
285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1
cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2
a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk</programlisting>
<simpara>Git doesn&#8217;t do this when it clones from a Git server. Here&#8217;s what a repository with tags looks like
after a fresh clone.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git show-ref
c3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master
32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-1
75f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-2
23f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.0
7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.0
6dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0</programlisting>
<simpara>Git fetches the tags directly into <literal>refs/tags</literal>, rather than treating them as remote branches.</simpara>
</section>
<section xml:id="_committing_back_to_subversion">
<title>Committing Back to Subversion</title>
<simpara>Now that you have a working repository, you can work on the project and push your commits back upstream,
using Git as an Subversion client. If you edit a file and commit it, you have a commit that exists in
Git locally that doesn&#8217;t exist on the Subversion server:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git commit -am 'Adding git-svn instructions to the README'
[master 4af61fd] Adding git-svn instructions to the README
 1 file changed, 5 insertions(+)</programlisting>
<simpara>Next, push your change upstream.
Notice how this changes the way you work with Subversion. You do several commits offline and then
push them all at once to the Subversion server.
To push to a Subversion server, run <literal>git svn dcommit</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r77
    M	README.txt
r77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)
No changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</programlisting>
<simpara>This takes all the commits you&#8217;ve made on top of the Subversion server code, does a
Subversion commit for each, and then rewrites your local Git commit to include a unique identifier.
This is important because it means that all the SHA-1 hashes for your commits change.
Partly for this reason, working with Git-based remote versions of your projects concurrently
with a Subversion server isn&#8217;t a good idea.
If you look at the last commit, you see the new <literal>git-svn-id</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -1
commit 95e0222ba6399739834380eb10afcd73e0670bc5
Author: ben &lt;ben@0b684db3-b064-4277-89d1-21af03df0a68&gt;
Date:   Thu Jul 24 03:08:36 2014 +0000

    Adding git-svn instructions to the README

    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68</programlisting>
<simpara>Notice that the SHA-1 hash that originally started with <literal>4af61fd</literal> when you committed now begins with <literal>95e0222</literal>.
To push to both a Git server and a Subversion server, you have to push (<literal>dcommit</literal>) to the
Subversion server first, because that changes your commit data.</simpara>
</section>
<section xml:id="_pulling_in_new_changes">
<title>Pulling in New Changes</title>
<simpara>If you&#8217;re working with other developers, then at some point one of you pushes, and then another
developer tries to push a change that conflicts with the first developer&#8217;s changes.
That second push is rejected until the conflicts are resolved. In <literal>git svn</literal>, it looks like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M	README.txt
Current branch master is up to date.
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.</programlisting>
<simpara>To resolve this, run <literal>git svn rebase</literal>, which pulls any changes on the server that you don&#8217;t
have yet and rebases any work you have on top of what&#8217;s on the server.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn rebase
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M	README.txt
First, rewinding head to replay your work on top of it...
Applying: update foo
Using index info to reconstruct a base tree...
M	README.txt
Falling back to patching base and 3-way merge...
Auto-merging README.txt
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.</programlisting>
<simpara>Now, all your work is on top of what&#8217;s on the Subversion server, so you can successfully run <literal>git svn dcommit</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r85
    M	README.txt
r85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)
No changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</programlisting>
<simpara>Note that unlike Git, which requires you to merge upstream work you don&#8217;t yet have locally
before you can push, <literal>git svn</literal> makes you do that only if the changes conflict (much like how
Subversion works). If someone else pushes a change to one file and then you push a change to another file,
<literal>git svn dcommit</literal> works fine.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	configure.ac
Committed r87
    M	autogen.sh
r86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)
    M	configure.ac
r87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)
W: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase:
:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M	autogen.sh
First, rewinding head to replay your work on top of it...</programlisting>
<simpara>This is important to remember, because the outcome is a project state that didn&#8217;t exist on
either computer when you pushed. If the changes are incompatible but don&#8217;t conflict,
you may get issues that are difficult to diagnose.
This is different than when using a Git server. In Git, you can fully test the state on your
client system before publishing it, whereas in Subversion, you can&#8217;t ever be certain that the
states immediately before and after commit are identical.</simpara>
<simpara>You should also run this command to pull in changes from the Subversion server, even if you&#8217;re not
ready to commit. Run <literal>git svn fetch</literal> to grab the new data, but <literal>git svn rebase</literal> does the fetch
and then updates your local commits.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn rebase
    M	autogen.sh
r88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)
First, rewinding head to replay your work on top of it...
Fast-forwarded master to refs/remotes/origin/trunk.</programlisting>
<simpara>Running <literal>git svn rebase</literal> every once in a while makes sure your repository is always up to date.
Be sure your working directory is clean when you run this, though.
If you have local changes, you must either stash your work or temporarily commit it before
running <literal>git svn rebase</literal>. Otherwise, the command stops if it sees that the rebase results in a merge conflict.</simpara>
</section>
<section xml:id="_git_branching_issues">
<title>Git Branching Issues</title>
<simpara>When you&#8217;ve become comfortable with a Git workflow, you probably create topic branches, work on them,
and then merge them. If you&#8217;re pushing to a Subversion server by running <literal>git svn</literal>, you may
want to rebase your work onto a single branch each time instead of merging branches.
The reason to prefer rebasing is that Subversion has a linear history and doesn&#8217;t deal with
merges like Git does, so <literal>git svn</literal> follows only the first parent when converting the snapshots
into Subversion commits.</simpara>
<simpara>Suppose you created an <literal>experiment</literal> branch, made two commits, and then merged them back into <literal>master</literal>.
When you run <literal>git svn dcommit</literal>, you see</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	CHANGES.txt
Committed r89
    M	CHANGES.txt
r89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)
    M	COPYING.txt
    M	INSTALL.txt
Committed r90
    M	INSTALL.txt
    M	COPYING.txt
r90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)
No changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</programlisting>
<simpara>Running <literal>git svn dcommit</literal> on a branch with merged history works fine, except that when you look
at your Git project history, it hasn&#8217;t rewritten either of the commits you made on <literal>experiment</literal>.
Instead, all those changes appear in the Subversion version of the single merge commit.</simpara>
<simpara>When someone else clones that work, all they see is the merge commit with all the work squashed into it,
as though you ran <literal>git merge --squash</literal>. They don&#8217;t see the commit data about where it came
from or when it was committed.</simpara>
</section>
<section xml:id="_subversion_branching">
<title>Subversion Branching</title>
<simpara>Branching in Subversion isn&#8217;t the same as branching in Git. It&#8217;s probably best to avoid it.
However, you can create and commit to branches in Subversion by running <literal>git svn</literal>.</simpara>
</section>
<section xml:id="_creating_a_new_svn_branch">
<title>Creating a New SVN Branch</title>
<simpara>To create a new branch in Subversion, run <literal>git svn branch [branchname]</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn branch opera
Copying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...
Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/opera, 90
Found branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0
Following parent with do_switch
Successfully followed parent
r91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)</programlisting>
<simpara>This does the equivalent of the <literal>svn copy trunk branches/opera</literal> command on the Subversion server.
It&#8217;s important to note that it doesn&#8217;t checkout <literal>opera</literal>. If you commit at this point,
that commit goes to <literal>trunk</literal> on the server, not <literal>opera</literal>.</simpara>
</section>
<section xml:id="_switching_active_branches">
<title>Switching Active Branches</title>
<simpara>Git figures out what branch your dcommits go to by looking for the tip of any of your Subversion
branches in your history. You should have only one, and it should be the last one with
a <literal>git-svn-id</literal> in your current branch history.</simpara>
<simpara>To work on more than one branch simultaneously, set up local branches to <literal>dcommit</literal> to
specific Subversion branches by starting them at the imported Subversion commit for that branch.
If you want an <literal>opera</literal> branch to work on separately, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch opera remotes/origin/opera</programlisting>
<simpara>Now, to merge <literal>opera</literal> into <literal>trunk</literal> (your <literal>master</literal>), run a normal <literal>git merge</literal>.
But you need to provide a descriptive commit message, or the merge says <literal>Merge branch opera</literal> instead
of something useful.</simpara>
<simpara>Remember that although you&#8217;re running <literal>git merge</literal>, and the merge is probably much easier than it
would be in Subversion (because Git automatically detects the appropriate merge base for you),
this isn&#8217;t a normal Git merge commit. You have to push this data back to a Subversion server that can&#8217;t
handle a commit that tracks more than one parent. So, after you push it, it looks like a single
commit that squashed all the work of another branch under a single commit. After you merge one branch
into another, you can&#8217;t easily go back and continue working on that branch, as you normally can in Git.
The <literal>dcommit</literal> erases any information that says what branch was merged in, so subsequent merge-base
calculations are wrong. The <literal>dcommit</literal> makes your <literal>git merge</literal> result look like you ran <literal>git merge --squash</literal>.
Unfortunately, there&#8217;s no good way to avoid this situation. Subversion can&#8217;t store this information,
so you&#8217;re always crippled by its limitations. To avoid such issues, delete the local branch (in this
case, <literal>opera</literal>) after you merge it into trunk.</simpara>
</section>
<section xml:id="_subversion_commands">
<title>Subversion Commands</title>
<simpara><literal>git svn</literal> provides a number of subcommands to help ease the transition to Git by doing some
of the same things that you could do in Subversion. Here are a few subcommands that do what Subversion does.</simpara>
<section xml:id="_svn_style_history">
<title>SVN Style History</title>
<simpara>If you&#8217;re used to Subversion and want to see your history in Subversion output style, run <literal>git svn log</literal>
to view your commit history in Subversion format.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn log
------------------------------------------------------------------------
r87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 lines

autogen change

------------------------------------------------------------------------
r86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 lines

Merge branch 'experiment'

------------------------------------------------------------------------
r85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 lines

updated the changelog</programlisting>
<simpara>You should know two important things about <literal>git svn log</literal>.
First, it works offline, unlike the real <literal>svn log</literal>, which gets the data from the Subversion server.
Second, it only shows commits that have been committed on the Subversion server.
Local Git commits that you haven&#8217;t run <literal>git svn dcommit</literal> on don&#8217;t show up.
Neither do commits made to the Subversion server in the meantime.</simpara>
<simpara>What you see is more like the last known state of the Subversion server.</simpara>
</section>
<section xml:id="_svn_annotation">
<title>SVN Annotation</title>
<simpara>Much as the <literal>git svn log</literal> command simulates <literal>svn log</literal> offline, you can get the equivalent
of <literal>svn annotate</literal> by running <literal>git svn blame [FILE]</literal>. The output looks like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn blame README.txt
 2   temporal Protocol Buffers - Google's data interchange format
 2   temporal Copyright 2008 Google Inc.
 2   temporal http://code.google.com/apis/protocolbuffers/
 2   temporal
22   temporal C++ Installation - Unix
22   temporal =======================
 2   temporal
79    schacon Committing in git-svn.
78    schacon
 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol
 2   temporal Buffer compiler (protoc) execute the following:
 2   temporal</programlisting>
<simpara>Again, it doesn&#8217;t show commits that you made locally in Git or that have been pushed to Subversion
in the meantime.</simpara>
</section>
<section xml:id="_svn_server_information">
<title>SVN Server Information</title>
<simpara>You can also get the same sort of information that <literal>svn info</literal> shows by running <literal>git svn info</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn info
Path: .
URL: https://schacon-test.googlecode.com/svn/trunk
Repository Root: https://schacon-test.googlecode.com/svn
Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029
Revision: 87
Node Kind: directory
Schedule: normal
Last Changed Author: schacon
Last Changed Rev: 87
Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)</programlisting>
<simpara>This is like <literal>git blame</literal> and <literal>git log</literal> in that it runs offline and is up to date only as
of the last time you communicated with the Subversion server.</simpara>
</section>
<section xml:id="_ignoring_what_subversion_ignores">
<title>Ignoring What Subversion Ignores</title>
<simpara>If you clone a Subversion repository that has <literal>svn:ignore</literal> properties set anywhere, you likely
want to set corresponding <literal>.gitignore</literal> files so you don&#8217;t accidentally commit files that you shouldn&#8217;t.
<literal>git svn</literal> has two subcommands to help with this.</simpara>
<simpara>The first is <literal>git svn create-ignore</literal>, which automatically creates corresponding <literal>.gitignore</literal> files
for your next commit to include.</simpara>
<simpara>The second command is <literal>git svn show-ignore</literal>, which outputs the lines you need to put in a <literal>.gitignore</literal>
file to redirect the output into your project exclude file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn show-ignore &gt; .git/info/exclude</programlisting>
<simpara>That way, you don&#8217;t litter the project with <literal>.gitignore</literal> files.
This is a good option if you&#8217;re the only Git user on a Subversion team, and your teammates
don&#8217;t want <literal>.gitignore</literal> files in the project.</simpara>
</section>
</section>
<section xml:id="_git_svn_summary">
<title>Git-Svn Summary</title>
<simpara><literal>git svn</literal> is useful if you&#8217;re stuck with a Subversion server.
You should think of it as a crippled Git, however, or you hit issues in translation that may
confuse you and your collaborators. To stay out of trouble, follow the following guidelines:</simpara>
<itemizedlist>
<listitem>
<simpara>Keep a linear Git history that doesn&#8217;t contain merge commits made by <literal>git merge</literal>.
Rebase any work you do outside of your mainline branch back onto it. Don&#8217;t merge it in.</simpara>
</listitem>
<listitem>
<simpara>Don&#8217;t set up and collaborate on a separate Git server.
Possibly have a Git server to speed up clones for new developers, but don&#8217;t push anything to it that doesn&#8217;t have a <literal>git-svn-id</literal> entry.
You may even want to add a <literal>pre-receive</literal> hook that checks each commit message for a <literal>git-svn-id</literal> and rejects pushes without it.</simpara>
</listitem>
</itemizedlist>
<simpara>If you follow those guidelines, working with a Subversion server can be more bearable.</simpara>
</section>
</section>
<section xml:id="_git_and_mercurial">
<title>Git and Mercurial</title>
<simpara><indexterm>
<primary>Interoperation with other VCSs</primary><secondary>Mercurial</secondary>
</indexterm>
<indexterm>
<primary>Mercurial</primary>
</indexterm>
<indexterm>
<primary>Mercurial</primary>
</indexterm>
The DVCS universe is larger than just Git.
In fact, there are many other systems in this space, each with its own angle on how to do
distributed version control correctly. Apart from Git, the most popular is Mercurial.
The two are very similar.</simpara>
<simpara>The good news, if you prefer Git&#8217;s client-side behavior but are working with a project under
Mercurial control, is that there&#8217;s a bridge that lets you use Git as a client for
Mercurial-hosted repositories. Since the way Git talks to server repositories is through remotes,
it should come as no surprise that this bridge is implemented as a remote helper.
The bridge&#8217;s name is <literal>git-remote-hg</literal>, and it can be found at <link xl:href="https://github.com/felipec/git-remote-hg">https://github.com/felipec/git-remote-hg</link>.</simpara>
<section xml:id="_git_remote_hg">
<title>git-remote-hg</title>
<simpara>First, install <literal>git-remote-hg</literal>.
This basically entails dropping it into a directory in your PATH environment variable.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ curl -o ~/bin/git-remote-hg \
  https://raw.githubusercontent.com/felipec/git-remote-hg/master/git-remote-hg
$ chmod +x ~/bin/git-remote-hg</programlisting>
<simpara>This assumes <literal>~/bin</literal> is in your PATH.
<literal>git-remote-hg</literal> has one other dependency&#8201;&#8212;&#8201;the <literal>mercurial</literal> library for Python.
If you have Python installed, satisfying this dependency is as simple as running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ pip install mercurial</programlisting>
<simpara>(If you don&#8217;t have Python installed, visit <link xl:href="https://www.python.org/">https://www.python.org/</link> and install it first.)</simpara>
<simpara>The last thing you need is the Mercurial client.
Go to <link xl:href="http://www.mercurial-scm.org/">http://www.mercurial-scm.org/</link> and install it if it isn&#8217;t already installed.</simpara>
<simpara>Now you&#8217;re ready to rock.
All you need is a Mercurial repository you can push to
so we just clone the "hello world" repository everyone uses to learn Mercurial.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ hg clone http://selenic.com/repo/hello /tmp/hello</programlisting>
</section>
<section xml:id="_getting_started_2">
<title>Getting Started</title>
<simpara>Now that we have a suitable <literal>server-side</literal> repository, we can go through a typical workflow.
As you see, these two systems are similar enough that there isn&#8217;t much friction.</simpara>
<simpara>As always with Git, first we clone.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone hg::/tmp/hello /tmp/hello-git
$ cd /tmp/hello-git
$ git log --oneline --graph --decorate
* ac7955c (HEAD, origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master, master) Create a makefile
* 65bb417 Create a standard "hello, world" program</programlisting>
<simpara>Notice that working with a Mercurial repository uses the standard <literal>git clone</literal> command.
That&#8217;s because <literal>git-remote-hg</literal> works at a fairly low level, using a similar mechanism to how
Git&#8217;s HTTP/S protocol uses remote helpers.
Since Git and Mercurial are both designed so that every client has a full copy of the repository,
this makes a full clone, including all the project&#8217;s history, and does so fairly quickly.</simpara>
<simpara><literal>git log</literal> shows two commits, the latest of which is pointed to by a whole slew of refs.
It turns out some of these aren&#8217;t actually there.
Let&#8217;s take a look at what&#8217;s actually in the <literal>.git</literal> directory.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ tree .git/refs
.git/refs
├── heads
│   └── master
├── hg
│   └── origin
│       ├── bookmarks
│       │   └── master
│       └── branches
│           └── default
├── notes
│   └── hg
├── remotes
│   └── origin
│       └── HEAD
└── tags

9 directories, 5 files</programlisting>
<simpara><literal>git-remote-hg</literal> is trying to make things more idiomatically Git-esque, but under the hood it&#8217;s
managing the conceptual mapping between two slightly different systems.
The <literal>refs/hg</literal> directory is where the actual remote refs are stored.
For example, <literal>refs/hg/origin/branches/default</literal> is a Git ref file that contains a SHA-1 hash
starting with <literal>ac7955c</literal>, which is the commit that <literal>master</literal> points to.
So the <literal>refs/hg</literal> directory is kind of a fake <literal>refs/remotes/origin</literal>.</simpara>
<simpara>The <literal>notes/hg</literal> file is the starting point for how <literal>git-remote-hg</literal> maps Git commit hashes
to Mercurial changeset IDs. Let&#8217;s explore a bit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat notes/hg
d4c10386...

$ git cat-file -p d4c10386...
tree 1781c96...
author remote-hg &lt;&gt; 1408066400 -0800
committer remote-hg &lt;&gt; 1408066400 -0800

Notes for master

$ git ls-tree 1781c96...
100644 blob ac9117f...	65bb417...
100644 blob 485e178...	ac7955c...

$ git cat-file -p ac9117f
0a04b987be5ae354b710cefeba0e2d9de7ad41a9</programlisting>
<simpara>So <literal>refs/notes/hg</literal> points to a tree, which in the Git repository is a list of other objects with names.
<literal>git ls-tree</literal> outputs the mode, type, object hash, and filename for items inside a tree.
Once we dig down to one of the tree items, we find that inside it is something named <literal>ac9117f</literal>
(the SHA-1 hash of the commit pointed to by <literal>master</literal>), with content <literal>0a04b98</literal>
(which is the ID of the Mercurial changeset at the tip of the <literal>default</literal> branch).</simpara>
<simpara>The good news is that we mostly don&#8217;t have to worry about all of this.
The typical workflow isn&#8217;t very different from working with a Git remote.</simpara>
<simpara>There&#8217;s one more thing we should attend to before we continue&#8201;&#8212;&#8201;ignores.
Mercurial and Git use a very similar mechanism for this, but it&#8217;s likely you don&#8217;t want to
actually commit a <literal>.gitignore</literal> file into a Mercurial repository.
Fortunately, Git has a way to ignore files that are local to a repository,
and the Mercurial format is compatible with Git, so you just have to copy the <literal>.hgignore</literal> file over.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cp .hgignore .git/info/exclude</programlisting>
<simpara><literal>.git/info/exclude</literal> acts just like a <literal>.gitignore</literal>, but isn&#8217;t included in commits.</simpara>
</section>
<section xml:id="_workflow">
<title>Workflow</title>
<simpara>Let&#8217;s assume we&#8217;ve done some work and made some commits on <literal>master</literal>, and you&#8217;re ready to push
it to the remote repository. Here&#8217;s what our repository looks like right now.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline --graph --decorate
* ba04a2a (HEAD, master) Update makefile
* d25d16f Goodbye
* ac7955c (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Create a makefile
* 65bb417 Create a standard "hello, world" program</programlisting>
<simpara>Our <literal>master</literal> is two commits ahead of <literal>origin/master</literal>, but those two commits exist only on our local machine.
Let&#8217;s see if anyone else has been doing important work at the same time.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch
From hg::/tmp/hello
   ac7955c..df85e87  master     -&gt; origin/master
   ac7955c..df85e87  branches/default -&gt; origin/branches/default
$ git log --oneline --graph --decorate --all
* 7b07969 (refs/notes/hg) Notes for default
* d4c1038 Notes for master
* df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
| * ba04a2a (HEAD, master) Update makefile
| * d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard "hello, world" program</programlisting>
<simpara>Since we used the <literal>--all</literal> flag, we see the <literal>notes</literal> refs that are used internally by <literal>git-remote-hg</literal>,
but we can ignore them. The rest is what we expected. <literal>origin/master</literal> has advanced by one commit,
and our history has now diverged. Unlike the other systems we work with in this chapter, Mercurial
is capable of handling merges, so we don&#8217;t have to do anything fancy.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge origin/master
Auto-merging hello.c
Merge made by the 'recursive' strategy.
 hello.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git log --oneline --graph --decorate
*   0c64627 (HEAD, master) Merge remote-tracking branch 'origin/master'
|\
| * df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
* | ba04a2a Update makefile
* | d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard "hello, world" program</programlisting>
<simpara>Perfect.
We run the tests and everything passes, so we&#8217;re ready to share our work with the rest of the team.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push
To hg::/tmp/hello
   df85e87..0c64627  master -&gt; master</programlisting>
<simpara>That&#8217;s it!
If you take a look at the Mercurial repository, you see that this did what we expect.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ hg log -G --style compact
o    5[tip]:4,2   dc8fa4f932b8   2014-08-14 19:33 -0700   ben
|\     Merge remote-tracking branch 'origin/master'
| |
| o  4   64f27bcefc35   2014-08-14 19:27 -0700   ben
| |    Update makefile
| |
| o  3:1   4256fc29598f   2014-08-14 19:27 -0700   ben
| |    Goodbye
| |
@ |  2   7db0b4848b3c   2014-08-14 19:30 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program</programlisting>
<simpara>The changeset numbered <emphasis>2</emphasis> was made by Mercurial, and the changesets numbered <emphasis>3</emphasis> and <emphasis>4</emphasis> were
made by <literal>git-remote-hg</literal>, by pushing commits made with Git.</simpara>
</section>
<section xml:id="_branches_and_bookmarks">
<title>Branches and Bookmarks</title>
<simpara>Git has only one kind of branch&#8201;&#8212;&#8201;a reference that moves when commits are made.
In Mercurial, this kind of reference is called a <literal>bookmark,</literal> and it behaves much the same way as a Git branch.</simpara>
<simpara>Mercurial&#8217;s concept of a <literal>branch</literal> is more heavyweight.
The branch that a changeset is made on is recorded <emphasis>with the changeset</emphasis>, which means it&#8217;s
always in the repository history.
Here&#8217;s an example of a commit that was made on <literal>develop</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ hg log -l 1
changeset:   6:8f65e5e02793
branch:      develop
tag:         tip
user:        Ben Straub &lt;ben@straub.cc&gt;
date:        Thu Aug 14 20:06:38 2014 -0700
summary:     More documentation</programlisting>
<simpara>Note the line that begins with <literal>branch</literal>.
Git can&#8217;t really replicate this (and doesn&#8217;t need to since both types of branches can be represented
as a Git ref), but <literal>git-remote-hg</literal> needs to understand the difference because Mercurial cares.</simpara>
<simpara>Creating Mercurial bookmarks is as easy as creating Git branches.
On the Git side</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b featureA
Switched to a new branch 'featureA'
$ git push origin featureA
To hg::/tmp/hello
 * [new branch]      featureA -&gt; featureA</programlisting>
<simpara>That&#8217;s all there is to it.
On the Mercurial side, it looks like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ hg bookmarks
   featureA                  5:bd5ac26f11f9
$ hg log --style compact -G
@  6[tip]   8f65e5e02793   2014-08-14 20:06 -0700   ben
|    More documentation
|
o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
|\     Merge remote-tracking branch 'origin/master'
| |
| o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| |    update makefile
| |
| o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |    goodbye
| |
o |  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program</programlisting>
<simpara>Note the new <literal>[featureA]</literal> tag on revision 5.
This acts exactly like a Git branch on the Git side, with one exception&#8201;&#8212;&#8201;you can&#8217;t delete a bookmark
from the Git side (this is a limitation of remote helpers).</simpara>
<simpara>You can work on a <literal>heavyweight</literal> Mercurial branch also. Just put a branch in the <literal>branches</literal> namespace.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git checkout -b branches/permanent
Switched to a new branch 'branches/permanent'
$ vi Makefile
$ git commit -am 'A permanent change'
$ git push origin branches/permanent
To hg::/tmp/hello
 * [new branch]      branches/permanent -&gt; branches/permanent</programlisting>
<simpara>Here&#8217;s what that looks like on the Mercurial side.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ hg branches
permanent                      7:a4529d07aad4
develop                        6:8f65e5e02793
default                        5:bd5ac26f11f9 (inactive)
$ hg log -G
o  changeset:   7:a4529d07aad4
|  branch:      permanent
|  tag:         tip
|  parent:      5:bd5ac26f11f9
|  user:        Ben Straub &lt;ben@straub.cc&gt;
|  date:        Thu Aug 14 20:21:09 2014 -0700
|  summary:     A permanent change
|
| @  changeset:   6:8f65e5e02793
|/   branch:      develop
|    user:        Ben Straub &lt;ben@straub.cc&gt;
|    date:        Thu Aug 14 20:06:38 2014 -0700
|    summary:     More documentation
|
o    changeset:   5:bd5ac26f11f9
|\   bookmark:    featureA
| |  parent:      4:0434aaa6b91f
| |  parent:      2:f098c7f45c4f
| |  user:        Ben Straub &lt;ben@straub.cc&gt;
| |  date:        Thu Aug 14 20:02:21 2014 -0700
| |  summary:     Merge remote-tracking branch 'origin/master'
[...]</programlisting>
<simpara>The branch name <literal>permanent</literal> was recorded with the changeset marked <emphasis>7</emphasis>.</simpara>
<simpara>From the Git side, working with either of these branch styles is the same. Just checkout, commit,
fetch, merge, pull, and push as you normally would.
One thing you should know is that Mercurial doesn&#8217;t support rewriting history, only adding to it.
Here&#8217;s what our Mercurial repository looks like after an interactive rebase and a force-push.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ hg log --style compact -G
o  10[tip]   99611176cbc9   2014-08-14 20:21 -0700   ben
|    A permanent change
|
o  9   f23e12f939c3   2014-08-14 20:01 -0700   ben
|    Add some documentation
|
o  8:1   c16971d33922   2014-08-14 20:00 -0700   ben
|    goodbye
|
| o  7:5   a4529d07aad4   2014-08-14 20:21 -0700   ben
| |    A permanent change
| |
| | @  6   8f65e5e02793   2014-08-14 20:06 -0700   ben
| |/     More documentation
| |
| o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
| |\     Merge remote-tracking branch 'origin/master'
| | |
| | o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| | |    update makefile
| | |
+---o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |      goodbye
| |
| o  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program</programlisting>
<simpara>Changesets <emphasis>8</emphasis>, <emphasis>9</emphasis>, and <emphasis>10</emphasis> have been created and belong to <literal>permanent</literal>,
but the old changesets are still there.
This can be <emphasis role="strong">very</emphasis> confusing for your teammates who are using Mercurial, so try to avoid it.</simpara>
</section>
<section xml:id="_mercurial_summary">
<title>Mercurial Summary</title>
<simpara>Git and Mercurial are similar enough that working across the boundary is fairly painless.
If you avoid changing history that&#8217;s left your machine (as is generally recommended),
you may not even be aware that the other end is Mercurial.</simpara>
</section>
</section>
<section xml:id="_git_and_bazaar">
<title>Git and Bazaar</title>
<simpara>Another famous DVCS is <link xl:href="http://bazaar.canonical.com/">Bazaar</link>.
Bazaar is free and open source, and is part of the <link xl:href="http://www.gnu.org/">GNU Project</link>.
It behaves very differently from Git.
Sometimes, to do the same thing as with Git, you have to use a different keyword,
and some keywords they have in common don&#8217;t have the same meaning.
In particular, branch management is very different and may cause confusion,
especially for someone used to Git.
Nevertheless, it is possible to work on a Bazaar repository from Git.</simpara>
<simpara>There are many projects that allow you to use Git as a Bazaar client.
Here we&#8217;ll use Felipe Contreras' project that you may find at <link xl:href="https://github.com/felipec/git-remote-bzr">https://github.com/felipec/git-remote-bzr</link>.
To install it, download the file <literal>git-remote-bzr</literal> into a folder contained in your <literal>$PATH</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ wget https://raw.github.com/felipec/git-remote-bzr/master/git-remote-bzr -O ~/bin/git-remote-bzr
$ chmod +x ~/bin/git-remote-bzr</programlisting>
<simpara>You also need to have Bazaar installed.
That&#8217;s all!</simpara>
<section xml:id="_create_a_git_repository_from_a_bazaar_repository">
<title>Create a Git repository from a Bazaar repository</title>
<simpara>It&#8217;s simple to use.
To clone a Bazaar repository just prefix the URL with <literal>bzr::</literal>.
Since Git and Bazaar both create full local clones, it&#8217;s possible to connect a Git clone to your
local Bazaar clone, but it isn&#8217;t recommended.
It&#8217;s much easier to attach your Git clone directly to the same place your Bazaar clone is attached to&#8201;&#8212;&#8201;the
central repository.</simpara>
<simpara>Let&#8217;s suppose that you&#8217;re working with the remote repository <literal>bzr+ssh://developer@mybazaarserver:myproject</literal>.
Clone it by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone bzr::bzr+ssh://developer@mybazaarserver:myproject myProject-Git
$ cd myProject-Git</programlisting>
<simpara>At this point, your Git repository is created but isn&#8217;t compacted, resulting in sub-optimal disk use.
That&#8217;s why you should also clean and compact your Git repository, especially if it&#8217;s large.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git gc --aggressive</programlisting>
</section>
<section xml:id="_bazaar_branches">
<title>Bazaar branches</title>
<simpara>Bazaar only allows branches to be cloned, but a repository may contain several branches,
and <literal>git-remote-bzr</literal> can clone both. For example, to clone a branch run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone bzr::bzr://bzr.savannah.gnu.org/emacs/trunk emacs-trunk</programlisting>
<simpara>And to clone the whole repository run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone bzr::bzr://bzr.savannah.gnu.org/emacs emacs</programlisting>
<simpara>The second command clones all the branches contained in the emacs repository. Nevertheless, it&#8217;s
possible to select certain branches.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config remote-bzr.branches 'trunk, xwindow'</programlisting>
<simpara>Some remote repositories don&#8217;t allow you to list their branches, in which case you must manually
specify the branches. Even though you could specify the configuration in the cloning command,
you may find this easier.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git init emacs
$ git remote add origin bzr::bzr://bzr.savannah.gnu.org/emacs
$ git config remote-bzr.branches 'trunk, xwindow'
$ git fetch</programlisting>
</section>
<section xml:id="_ignore_what_s_ignored_with_bzrignore">
<title>Ignore what&#8217;s ignored with .bzrignore</title>
<simpara>Since you&#8217;re working on a project managed by Bazaar, you shouldn&#8217;t create a <literal>.gitignore</literal> file
because you <emphasis>may</emphasis> accidentally put it under version control which would disturb the other people working with Bazaar.
The solution is to create the <literal>.git/info/exclude</literal> file either as a symbolic link or as a regular file.
We&#8217;ll see later how to solve this problem.</simpara>
<simpara>Bazaar uses the same model as Git to ignore files, but also has two features which don&#8217;t have
an equivalent in Git.
The complete description may be found in
<link xl:href="http://doc.bazaar.canonical.com/bzr.2.7/en/user-reference/ignore-help.html">the documentation</link>.
The two features are</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>"!!" allows you to ignore certain file patterns even if they&#8217;re specified using a "!" rule.</simpara>
</listitem>
<listitem>
<simpara>"RE:" at the beginning of a line allows you to specify
a <link xl:href="https://docs.python.org/3/library/re.html">Python regular expression</link> (Git only allows shell globs).</simpara>
</listitem>
</orderedlist>
<simpara>As a consequence, there are two different situations to consider.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>If <literal>.bzrignore</literal> doesn&#8217;t contain any of these two specific prefixes, then you can simply make
a symbolic link to it in the repository by running <literal>ln -s .bzrignore .git/info/exclude</literal></simpara>
</listitem>
<listitem>
<simpara>Otherwise, you must create <literal>.git/info/exclude</literal> and modify it to ignore exactly
the same files in <literal>.bzrignore</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>Whatever the case, you have to remain vigilant against any change of <literal>.bzrignore</literal> to make sure
that <literal>.git/info/exclude</literal> always reflects <literal>.bzrignore</literal>.
Indeed, if <literal>.bzrignore</literal> were to change and contained one or more lines starting with "!!" or "RE:",
Git isn&#8217;t  able to interpret these lines. So,  you must adapt <literal>.git/info/exclude</literal> to ignore the same
files as the ones ignored with <literal>.bzrignore</literal>.
Moreover, if <literal>.git/info/exclude</literal> is a symbolic link, you must first delete the symbolic link,
copy <literal>.bzrignore</literal> to <literal>.git/info/exclude</literal>, and then adapt the latter.
However, be careful doing this because with Git it&#8217;s impossible to re-include a file if
a parent directory of that file is excluded.</simpara>
</section>
<section xml:id="_fetch_the_changes_of_the_remote_repository">
<title>Fetch the changes of the remote repository</title>
<simpara>To fetch the changes of the remote, pull changes as usual, using Git commands.
Supposing that your changes are on <literal>master</literal>, merge or rebase your work on <literal>origin/master</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git pull --rebase origin</programlisting>
</section>
<section xml:id="_push_your_work_on_the_remote_repository">
<title>Push your work on the remote repository</title>
<simpara>Because Bazaar also has the concept of merge commits, there will be no problem if you push a merge commit.
So, you can work on a branch, merge the changes into <literal>master</literal>, and push.
Then, create your branches, test, and commit your work as usual.
Finally push your work to the Bazaar repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin master</programlisting>
</section>
<section xml:id="_caveats">
<title>Caveats</title>
<simpara>Git&#8217;s remote-helpers framework has some limitations.
In particular, these commands don&#8217;t work:</simpara>
<itemizedlist>
<listitem>
<simpara>git push origin :branch-to-delete (Bazaar can&#8217;t accept ref deletions in this way.)</simpara>
</listitem>
<listitem>
<simpara>git push origin old:new (it will push <emphasis>old</emphasis>)</simpara>
</listitem>
<listitem>
<simpara>git push --dry-run origin branch (it will push)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_summary_11">
<title>Summary</title>
<simpara>Since Git&#8217;s and Bazaar&#8217;s models are similar, there isn&#8217;t a lot of resistance when crossing the boundary.
As long as you watch out for the limitations, and you&#8217;re always aware that the remote repository isn&#8217;t really
Git, you&#8217;ll be fine.</simpara>
</section>
</section>
<section xml:id="_git_and_perforce">
<title>Git and Perforce</title>
<simpara><indexterm>
<primary>Interoperation with other VCSs</primary><secondary>Perforce</secondary>
</indexterm>
<indexterm>
<primary>Perforce</primary>
</indexterm>
<indexterm>
<primary>Perforce</primary>
</indexterm>
Perforce is a very popular VCS in corporate environments.
It&#8217;s been around since 1995, which makes it the oldest VCS covered in this chapter.
As such, it was designed with the constraints of its day.
It assumes you&#8217;re always connected to a single central server, and only one version of a file is kept
on your local disk. To be sure, its features and constraints are well-suited to several specific problems,
but there are lots of projects using Perforce where Git would actually work better.</simpara>
<simpara>There are two options if you&#8217;d like to mix Perforce and Git.
The first one we cover is the <literal>Git Fusion</literal> bridge from Perforce,
which lets you expose subtrees of your Perforce depot as read-write Git repositories.
The second is <literal>git-p4</literal>, a client-side bridge that lets you use Git as a Perforce client,
without requiring any reconfiguration of the Perforce server.</simpara>
<section xml:id="_p4_git_fusion">
<title>Git Fusion</title>
<simpara><indexterm>
<primary>Perforce</primary><secondary>Git Fusion</secondary>
</indexterm>
<indexterm>
<primary>Git Fusion</primary>
</indexterm>
Perforce provides Git Fusion (available at <link xl:href="http://www.perforce.com/git-fusion">http://www.perforce.com/git-fusion</link>), which synchronizes
a Perforce server with Git repositories.</simpara>
<section xml:id="_setting_up_2">
<title>Setting Up</title>
<simpara>For our examples, we use the easiest installation method, which is downloading a virtual machine
that runs the Perforce daemon and Git Fusion.
You can get the virtual machine image from <link xl:href="http://www.perforce.com/downloads/Perforce/20-User">http://www.perforce.com/downloads/Perforce/20-User</link>.
Import it into your favorite virtualization software (we use VirtualBox).</simpara>
<simpara>Upon first starting the machine, it asks you to customize the password for three Linux users (<literal>root</literal>,
<literal>perforce</literal>, and <literal>git</literal>), and provide an instance name, which is used to distinguish this installation
from others on the same network. When all that&#8217;s done, you see</simpara>
<figure>
<title>The Git Fusion virtual machine boot screen.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/git-fusion-boot.png"/>
</imageobject>
<textobject><phrase>The Git Fusion virtual machine boot screen.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Take note of the IP address that&#8217;s shown here since we use it later on.
Next, create a Perforce user.
Select the <literal>Login</literal> option at the bottom, press enter (or SSH to the machine), and log in as <literal>root</literal>.
Then run the following commands to create a user:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ p4 -p localhost:1666 -u super user -f john
$ p4 -p localhost:1666 -u john passwd
$ exit</programlisting>
<simpara>The first one opens a text editor to customize the user, but you can accept the defaults by just
writing out the default and existing the editor. The second one prompts twice for a password.
That&#8217;s all we need a shell for, so exit the session.</simpara>
<simpara>Next tell Git to not verify SSL certificates.
The Git Fusion image comes with a certificate, but it&#8217;s for a domain that doesn&#8217;t match your
virtual machine&#8217;s IP address, so Git rejects any HTTPS connections.
If this is going to be a permanent installation, consult the Perforce Git Fusion manual
to install a different certificate. For our example purposes, certificate verification isn&#8217;t
necessary.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ export GIT_SSL_NO_VERIFY=true</programlisting>
<simpara>Now test that everything is working.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone https://10.0.1.254/Talkhouse
Cloning into 'Talkhouse'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 630, done.
remote: Compressing objects: 100% (581/581), done.
remote: Total 630 (delta 172), reused 0 (delta 0)
Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.
Resolving deltas: 100% (172/172), done.
Checking connectivity... done.</programlisting>
<simpara>The virtual machine image contains a sample project that you can clone.
Here we&#8217;re cloning over HTTPS, using the <literal>john</literal> user that we created above.
Git asks for credentials for this connection, but the credential cache allows us to skip
this step for any subsequent requests.</simpara>
</section>
<section xml:id="_fusion_configuration">
<title>Fusion Configuration</title>
<simpara>Once Git Fusion is installed, tweak its configuration.
This is actually fairly easy to do using your favorite Perforce client.
Just map the <literal>//.git-fusion</literal> directory on the Perforce server into your workspace.
The file structure looks like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ tree
.
├── objects
│   ├── repos
│   │   └── [...]
│   └── trees
│       └── [...]
│
├── p4gf_config
├── repos
│   └── Talkhouse
│       └── p4gf_config
└── users
    └── p4gf_usermap

498 directories, 287 files</programlisting>
<simpara>The <literal>objects</literal> directory is used internally by Git Fusion to map Perforce objects to Git, and vice versa.
You don&#8217;t have to mess with anything in there. There&#8217;s a global <literal>p4gf_config</literal> file in this directory,
as well as one for each repository. These are the configuration files that determine how Git Fusion behaves.
Let&#8217;s take a look at the file in the root.</simpara>
<programlisting language="ini" linenumbering="unnumbered">[repo-creation]
charset = utf8

[git-to-perforce]
change-owner = author
enable-git-branch-creation = yes
enable-swarm-reviews = yes
enable-git-merge-commits = yes
enable-git-submodules = yes
preflight-commit = none
ignore-author-permissions = no
read-permission-check = none
git-merge-avoidance-after-change-num = 12107

[perforce-to-git]
http-url = none
ssh-url = none

[@features]
imports = False
chunked-push = False
matrix2 = False
parallel-push = False

[authentication]
email-case-sensitivity = no</programlisting>
<simpara>We don&#8217;t go into what these options do, but note that this is just an INI-formatted text file,
much like Git uses for storing configuration data. This file specifies the global options,
which can then be overridden by repository-specific configuration files, like <literal>repos/Talkhouse/p4gf_config</literal>.
You see a <literal>[@repo]</literal> section with settings that are different than the global defaults.
You also see sections that look like</simpara>
<programlisting language="ini" linenumbering="unnumbered">[Talkhouse-master]
git-branch-name = master
view = //depot/Talkhouse/main-dev/... ...</programlisting>
<simpara>This is a mapping between a Perforce branch and a Git branch.
The section can be named whatever you like, as long as the name is unique.
<literal>git-branch-name</literal> converts a depot path that would be cumbersome under Git to a more friendly name.
The <literal>view</literal> setting controls how Perforce files are mapped into the Git repository,
using the standard view mapping syntax.  More than one mapping can be specified, like in this example.</simpara>
<programlisting language="ini" linenumbering="unnumbered">[multi-project-mapping]
git-branch-name = master
view = //depot/project1/main/... project1/...
       //depot/project2/mainline/... project2/...</programlisting>
<simpara>This way, if your normal workspace mapping includes changes in the structure of the directories,
you can replicate that with a Git repository.</simpara>
<simpara>The last file we discuss is <literal>users/p4gf_usermap</literal>, which maps Perforce users to Git users.
You may not even need this. When converting from a Perforce changeset to a Git commit,
Git Fusion&#8217;s default behavior is to look up the Perforce user, and use their email address and full
name for the author/committer field in Git. When converting the other way, the default is to look up
the Perforce user&#8217;s email address using the address stored in the Git commit&#8217;s author field,
and submit the changeset as that user (with proper permissions applied).
In most cases, this behavior works just fine, but consider the following mapping file:</simpara>
<screen>john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"</screen>
<simpara>Each line is of the format <literal>&lt;user&gt; &lt;email&gt; "&lt;full name&gt;"</literal>, and creates a single user mapping.
The first two lines map two distinct email addresses to the same Perforce user account.
This is useful if you&#8217;ve created Git commits using several different email addresses
(or you&#8217;ve changed email addresses), but want them to be mapped to the same Perforce user.
When creating a Git commit from a Perforce changeset, the first line matching the Perforce
user is used as the Git author.</simpara>
<simpara>The last two lines mask Bob and Joe&#8217;s actual names and email addresses from the Git commits.
This is nice if you want to open-source an internal project, but don&#8217;t want to publish
your employee directory to the entire world. Note that the email addresses and full names should be unique,
unless you want all Git commits to be attributed to a single fictional author.</simpara>
</section>
<section xml:id="_workflow_2">
<title>Workflow</title>
<simpara>Perforce Git Fusion is a two-way bridge between Perforce and Git.
Let&#8217;s have a look at how it feels from the Git side.
Assume we&#8217;ve mapped in the <literal>Jam</literal> project using a configuration file as shown above, which we clone like this.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone https://10.0.1.254/Jam
Cloning into 'Jam'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 2070, done.
remote: Compressing objects: 100% (1704/1704), done.
Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.
remote: Total 2070 (delta 1242), reused 0 (delta 0)
Resolving deltas: 100% (1242/1242), done.
Checking connectivity... done.
$ git branch -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/master
  remotes/origin/rel2.1
$ git log --oneline --decorate --graph --all
* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.
| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.
| * bd2f54a Put in fix for jam's NT handle leak.
| * c0f29e7 Fix URL in a jam doc
| * cc644ac Radstone's lynx port.
[...]</programlisting>
<simpara>The first time you do this, it may take some time.
What&#8217;s happening is that Git Fusion is converting all the applicable changesets in the Perforce
history into Git commits. This happens locally on the server, so it&#8217;s relatively fast,
but if you have a lot of history, it can still take some time.
Subsequent fetches do incremental conversions, so it feels more like Git&#8217;s native speed.</simpara>
<simpara>As you see, our repository looks exactly like any other Git repository.
There are three branches, and Git has helpfully created a local <literal>master</literal> that tracks <literal>origin/master</literal>.
Let&#8217;s do a bit of work, and create a couple of new commits.</simpara>
<programlisting language="console" linenumbering="unnumbered"># ...
$ git log --oneline --decorate --graph --all
* cfd46ab (HEAD, master) Add documentation for new feature
* a730d77 Whitespace
* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]</programlisting>
<simpara>We have two new commits.
Now let&#8217;s check if anyone else has done anything.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://10.0.1.254/Jam
   d254865..6afeb15  master     -&gt; origin/master
$ git log --oneline --decorate --graph --all
* 6afeb15 (origin/master, origin/HEAD) Update copyright
| * cfd46ab (HEAD, master) Add documentation for new feature
| * a730d77 Whitespace
|/
* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]</programlisting>
<simpara>It looks like someone has!
You wouldn&#8217;t know it from this view, but the <literal>6afeb15</literal> commit was actually created using a Perforce client.
It just looks like another commit from Git&#8217;s point of view, which is exactly the point.
Let&#8217;s see how the Perforce server deals with a merge commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git merge origin/master
Auto-merging README
Merge made by the 'recursive' strategy.
 README | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git push
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 6), reused 0 (delta 0)
remote: Perforce: 100% (3/3) Loading commit tree into memory...
remote: Perforce: 100% (5/5) Finding child commits...
remote: Perforce: Running git fast-export...
remote: Perforce: 100% (3/3) Checking commits...
remote: Processing will continue even if connection is closed.
remote: Perforce: 100% (3/3) Copying changelists...
remote: Perforce: Submitting new Git commit objects to Perforce: 4
To https://10.0.1.254/Jam
   6afeb15..89cba2b  master -&gt; master</programlisting>
<simpara>Git thinks it worked.
Let&#8217;s take a look at the history of <literal>README</literal> from Perforce&#8217;s point of view,
using the revision graph feature of <literal>p4v</literal>.</simpara>
<figure>
<title>Perforce revision graph resulting from Git push.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/git-fusion-perforce-graph.png"/>
</imageobject>
<textobject><phrase>Perforce revision graph resulting from Git push.</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you&#8217;ve never seen this view before, it may seem confusing, but it shows the same concepts as a
GUI Git history viewer. We&#8217;re looking at the history of <literal>README</literal>, so the directory tree
at top left only shows that file as it surfaces in various branches.
At top right, we have a visual graph of how different revisions of the file are related,
and the big-picture view of this graph is at bottom right.
The rest of the view shows the detail view for the selected revision (<literal>2</literal> in this case).</simpara>
<simpara>One thing to notice is that the graph looks exactly like the one in Git&#8217;s history.
Perforce didn&#8217;t have a named branch to store the <literal>1</literal> and <literal>2</literal> commits, so it made an <literal>anonymous</literal> branch
in the <literal>.git-fusion</literal> directory to hold them. This also happens for named Git branches that don&#8217;t
correspond to a named Perforce branch (and you can later map them to a Perforce branch using
the configuration file).</simpara>
<simpara>Most of this happens behind the scenes, but the end result is that one person on a team can be using Git,
another can be using Perforce, and neither of them knows about the other&#8217;s choice.</simpara>
</section>
<section xml:id="_git_fusion_summary">
<title>Git-Fusion Summary</title>
<simpara>If you have (or can get) access to a Perforce server, Git Fusion is a great way to make Git
and Perforce talk to each other. There&#8217;s a bit of configuration involved, but the learning curve isn&#8217;t
very steep. This is one of the few sections in this chapter where cautions about using Git&#8217;s full
power don&#8217;t appear. That&#8217;s not to say that Perforce is happy with everything you throw at it&#8201;&#8212;&#8201;if you try to
rewrite history that&#8217;s already been pushed, Git Fusion rejects it&#8201;&#8212;&#8201;but Git Fusion tries
very hard to feel native. You can even use Git submodules (though they look strange to Perforce users),
and merge branches (they&#8217;re recorded as an integration on the Perforce side).</simpara>
<simpara>If you can&#8217;t convince your server administrator to set up Git Fusion,
there&#8217;s still a way to use Git and Perforce together.</simpara>
</section>
</section>
<section xml:id="_git_p4_client">
<title>Git-p4</title>
<simpara><indexterm>
<primary>git commands</primary><secondary>p4</secondary>
</indexterm>
<indexterm>
<primary>p4</primary>
</indexterm>
<literal>git-p4</literal> is a two-way bridge between Git and Perforce.
It runs entirely inside your Git repository, so you don&#8217;t need any kind of access to a
Perforce server (other than user credentials, of course).
<literal>git-p4</literal> isn&#8217;t as flexible or as complete a solution as Git Fusion, but it does allow most of what you&#8217;d
want to do without being invasive to the server environment.</simpara>
<note>
<simpara>You need the <literal>p4</literal> tool somewhere in your <literal>PATH</literal> to work with <literal>git-p4</literal>.
As of this writing, it&#8217;s freely available at <link xl:href="http://www.perforce.com/downloads/Perforce/20-User">http://www.perforce.com/downloads/Perforce/20-User</link>.</simpara>
</note>
<section xml:id="_setting_up_3">
<title>Setting Up</title>
<simpara>For example purposes, we run the Perforce server from the Git Fusion virtual machine image, as shown above,
but we bypass the Git Fusion server and go directly to Perforce.</simpara>
<simpara>In order to run the <literal>p4</literal> command-line client (which <literal>git-p4</literal> depends on), you need to set
a couple of environment variables.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ export P4PORT=10.0.1.254:1666
$ export P4USER=john</programlisting>
</section>
<section xml:id="_getting_started_3">
<title>Getting Started</title>
<simpara>As with anything in Git, start by cloning.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git p4 clone //depot/www/live www-shallow
Importing from //depot/www/live into www-shallow
Initialized empty Git repository in /private/tmp/www-shallow/.git/
Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master</programlisting>
<simpara>This creates what in Git terms is a <literal>shallow</literal> clone. Only the very latest Perforce revision is imported
into Git. Remember, Perforce isn&#8217;t designed to make every revision available to every user.
This is enough to use Git as a Perforce client, but just barely.</simpara>
<simpara>Once it&#8217;s finished, we have a fully-functional Git repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd myproject
$ git log --oneline --all --graph --decorate
* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head</programlisting>
<simpara>Note how there&#8217;s a <literal>p4</literal> remote for the Perforce server, but everything else looks like a standard clone.
Actually, that&#8217;s a bit misleading&#8201;&#8212;&#8201;there isn&#8217;t actually a remote there.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote -v</programlisting>
<simpara>No remotes exist in this repository at all.
<literal>git-p4</literal> has created some refs to represent the state of the server, and they look like
remote refs to <literal>git log</literal>, but they&#8217;re not managed by Git itself, and you can&#8217;t push to them.</simpara>
</section>
<section xml:id="_workflow_3">
<title>Workflow</title>
<simpara>OK, let&#8217;s do some work.
Let&#8217;s assume you&#8217;ve made some progress on a very important feature, and you&#8217;re ready to show
it to the rest of your team.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline --all --graph --decorate
* 018467c (HEAD, master) Change page title
* c0fb617 Update link
* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head</programlisting>
<simpara>We&#8217;ve made two new commits that we&#8217;re ready to submit to the Perforce server.
Let&#8217;s check if anyone else made any changes today.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git p4 sync
git p4 sync
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12142 (100%)
$ git log --oneline --all --graph --decorate
* 75cd059 (p4/master, p4/HEAD) Update copyright
| * 018467c (HEAD, master) Change page title
| * c0fb617 Update link
|/
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</programlisting>
<simpara>Looks like they were, and <literal>master</literal> and <literal>p4/master</literal> have diverged.
Perforce&#8217;s branching system is <emphasis>nothing</emphasis> like Git&#8217;s, so submitting merge commits doesn&#8217;t make any sense.
<literal>git-p4</literal> recommends that you rebase your commits, and even comes with a shortcut for doing so.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git p4 rebase
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
No changes to import!
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
Applying: Update link
Applying: Change page title
 index.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</programlisting>
<simpara>You can probably tell from the output, but <literal>git p4 rebase</literal> is a shortcut for <literal>git p4 sync</literal> followed
by <literal>git rebase p4/master</literal>. It&#8217;s a bit smarter than that, especially when working with multiple branches,
but this is a good approximation.</simpara>
<simpara>Now our history is linear again, and we&#8217;re ready to contribute our changes back to Perforce.
<literal>git p4 submit</literal> tries to create a new Perforce revision for every Git commit between <literal>p4/master</literal> and <literal>master</literal>.
Running it drops us into our editor, and the content of the buffer looks something like</simpara>
<programlisting language="console" linenumbering="unnumbered"># A Perforce Change Specification.
#
#  Change:      The change number. 'new' on a new changelist.
#  Date:        The date this specification was last modified.
#  Client:      The client on which the changelist was created.  Read-only.
#  User:        The user who created the changelist.
#  Status:      Either 'pending' or 'submitted'. Read-only.
#  Type:        Either 'public' or 'restricted'. Default is 'public'.
#  Description: Comments about the changelist.  Required.
#  Jobs:        What opened jobs are to be closed by this changelist.
#               You may delete jobs from this list.  (New changelists only.)
#  Files:       What opened files from the default changelist are to be added
#               to this changelist.  You may delete files from this list.
#               (New changelists only.)

Change:  new

Client:  john_bens-mbp_8487

User: john

Status:  new

Description:
   Update link

Files:
   //depot/www/live/index.html   # edit


######## git author ben@straub.cc does not match your p4 account.
######## Use option --preserve-user to modify authorship.
######## Variable git-p4.skipUserNameCheck hides this message.
######## everything below this line is just the diff #######
--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000
@@ -60,7 +60,7 @@
 &lt;/td&gt;
 &lt;td valign=top&gt;
 Source and documentation for
-&lt;a href="http://www.perforce.com/jam/jam.html"&gt;
+&lt;a href="jam.html"&gt;
 Jam/MR&lt;/a&gt;,
 a software build tool.
 &lt;/td&gt;</programlisting>
<simpara>This is mostly the same content you&#8217;d see by running <literal>p4 submit</literal>, except the stuff at the end,
which <literal>git-p4</literal> has helpfully added. <literal>git-p4</literal> tries to honor your Git and Perforce settings individually
when it has to provide a name for a commit or changeset, but in some cases you want to override it.
For example, if the Git commit you&#8217;re importing was written by a contributor who doesn&#8217;t have a
Perforce user account, you may still want the resulting changeset to look like they wrote it (and not you).</simpara>
<simpara><literal>git-p4</literal> has helpfully imported the message from the Git commit as the content for this
Perforce changeset, so all we have to do is save and quit, twice (once for each commit).
The resulting output looks something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git p4 submit
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Synchronizing p4 checkout...
... - file(s) up-to-date.
Applying dbac45b Update link
//depot/www/live/index.html#4 - opened for edit
Change 12143 created with 1 open file(s).
Submitting change 12143.
Locking 1 files ...
edit //depot/www/live/index.html#5
Change 12143 submitted.
Applying 905ec6a Change page title
//depot/www/live/index.html#5 - opened for edit
Change 12144 created with 1 open file(s).
Submitting change 12144.
Locking 1 files ...
edit //depot/www/live/index.html#6
Change 12144 submitted.
All commits applied!
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12144 (100%)
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
$ git log --oneline --all --graph --decorate
* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</programlisting>
<simpara>The result is as though we just ran <literal>git push</literal>, which is the closest analogy to what actually did happen.</simpara>
<simpara>Note that during this process every Git commit is turned into a Perforce changeset.
To squash multiple commits down into a single changeset, do an interactive
rebase before running <literal>git p4 submit</literal>.
Also note that the SHA-1 hashes of all the commits that were submitted as changesets have changed.
This is because <literal>git-p4</literal> adds a line to the end of each commit it converts.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Author: John Doe &lt;john@example.com&gt;
Date:   Sun Aug 31 10:31:44 2014 -0800

    Change page title

    [git-p4: depot-paths = "//depot/www/live/": change = 12144]</programlisting>
<simpara>What happens if you try to submit a merge commit?
Let&#8217;s give it a try.
Here&#8217;s the situation we&#8217;ve gotten ourselves into.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline --all --graph --decorate
* 3be6fd8 (HEAD, master) Correct email address
*   1dcbf21 Merge remote-tracking branch 'p4/master'
|\
| * c4689fc (p4/master, p4/HEAD) Grammar fix
* | cbacd0a Table borders: yes please
* | b4959b6 Trademark
|/
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</programlisting>
<simpara>The Git and Perforce history diverge after <literal>775a46f</literal>.
The Git side has two commits, then a merge commit with the Perforce head, then another commit.
We&#8217;re going to try to submit these on top of a single changeset on the Perforce side.
Let&#8217;s see what would happen if we try to submit now.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git p4 submit -n
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would apply
  b4959b6 Trademark
  cbacd0a Table borders: yes please
  3be6fd8 Correct email address</programlisting>
<simpara>The <literal>-n</literal> flag is short for <literal>--dry-run</literal>, which tries to report what would happen if <literal>git p4 submit</literal>
were run for real. In this case, it looks like we&#8217;d be creating three Perforce changesets,
which correspond to the three non-merge commits that don&#8217;t yet exist on the Perforce server.
That sounds like exactly what we want. Let&#8217;s see how it turns out.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git p4 submit
[…]
$ git log --oneline --all --graph --decorate
* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address
* 1b79a80 Table borders: yes please
* 0097235 Trademark
* c4689fc Grammar fix
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</programlisting>
<simpara>Our history became linear, just as though we had rebased before submitting (which is in fact exactly
what happened). This means you&#8217;re free to create, work on, throw away, and merge branches on the Git
side without fear of your history somehow becoming incompatible with Perforce.
If you can rebase a change, you can contribute it to a Perforce server.</simpara>
</section>
<section xml:id="_git_p4_branches">
<title>Branching</title>
<simpara>If your Perforce project has multiple branches, you&#8217;re not out of luck. <literal>git-p4</literal> can handle that in a
way that makes it feel like Git. Let&#8217;s say your Perforce depot is laid out like</simpara>
<screen>//depot
  └── project
      ├── main
      └── dev</screen>
<simpara>And let&#8217;s say you have a <literal>dev</literal> branch, which has a view spec that looks like</simpara>
<screen>//depot/project/main/... //depot/project/dev/...</screen>
<simpara><literal>git-p4</literal> can automatically detect that situation and do the right thing.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git p4 clone --detect-branches //depot/project@all
Importing from //depot/project@all into project
Initialized empty Git repository in /private/tmp/project/.git/
Importing revision 20 (50%)
    Importing new branch project/dev

    Resuming with change 20
Importing revision 22 (100%)
Updated branches: main dev
$ cd project; git log --oneline --all --graph --decorate
* eae77ae (HEAD, p4/master, p4/HEAD, master) main
| * 10d55fb (p4/project/dev) dev
| * a43cfae Populate //depot/project/main/... //depot/project/dev/....
|/
* 2b83451 Project init</programlisting>
<simpara>Note the <literal>@all</literal> specifier in the depot path. That tells <literal>git-p4</literal> to not clone just the
latest changeset for that subtree, but all changesets that have ever touched those paths.
This is closer to Git&#8217;s concept of a clone, but if you&#8217;re working on a project with a long history,
it could take a while.</simpara>
<simpara>The <literal>--detect-branches</literal> flag tells <literal>git-p4</literal> to use Perforce&#8217;s branch specs to map the branches to Git refs.
If these mappings aren&#8217;t present on the Perforce server (which is a perfectly valid way to use Perforce),
you can tell <literal>git-p4</literal> what the branch mappings are, and you get the same result.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git init project
Initialized empty Git repository in /tmp/project/.git/
$ cd project
$ git config git-p4.branchList main:dev
$ git clone --detect-branches //depot/project@all .</programlisting>
<simpara>Setting the <literal>git-p4.branchList</literal> configuration variable to <literal>main:dev</literal> tells <literal>git-p4</literal> that <literal>main</literal>
and <literal>dev</literal> are both branches, and the second is a child of the first.</simpara>
<simpara>If we now run <literal>git checkout -b dev p4/project/dev</literal> and make some commits, <literal>git-p4</literal> is smart
enough to target the right branch when we run <literal>git p4 submit</literal>.
Unfortunately, <literal>git-p4</literal> can&#8217;t mix shallow clones and multiple branches. If you have a huge project
and want to work on more than one branch, you have to run <literal>git p4 clone</literal> once for each branch
you want to submit to.</simpara>
<simpara>For creating or integrating branches, you have to use a Perforce client.
<literal>git-p4</literal> can only sync and submit to existing branches, and it can only do it one linear changeset at a time.
If you merge two branches in Git and try to submit the new changeset, all that&#8217;s recorded
is a bunch of file changes. The metadata about which branches are involved in the integration are lost.</simpara>
</section>
</section>
<section xml:id="_git_and_perforce_summary">
<title>Git and Perforce Summary</title>
<simpara><literal>git-p4</literal> makes it possible to use a Git workflow with a Perforce server, and it&#8217;s pretty good.
However, it&#8217;s important to remember that Perforce is in charge of the source,
and you&#8217;re only using Git to work locally. Just be really careful about sharing Git commits.
If you have a remote that other people use, don&#8217;t push any commits that haven&#8217;t already been
submitted to the Perforce server.</simpara>
<simpara>Git Fusion makes using Git a first-class version-control
client for a Perforce server, if you can convince the server administrator to install it.</simpara>
</section>
</section>
<section xml:id="_git_and_tfs">
<title>Git and TFS</title>
<simpara><indexterm>
<primary>Interoperation with other VCSs</primary><secondary>TFS</secondary>
</indexterm>
<indexterm>
<primary>TFS</primary>
</indexterm>
<indexterm>
<primary>TFS</primary>
</indexterm><indexterm>
<primary>TFVC</primary><secondary>see=TFS</secondary>
</indexterm>
<indexterm>
<primary>see=TFS</primary>
</indexterm>
Git is becoming popular with Windows developers, and if you&#8217;re working on
Windows, there&#8217;s a good chance you&#8217;re using Microsoft&#8217;s Team Foundation Server
(TFS).  TFS is a collaboration suite that includes defect and work-item
tracking, process support for Scrum and others, code review, and version
control.  There&#8217;s a bit of confusion ahead&#8201;&#8212;&#8201;<emphasis role="strong">TFS</emphasis> is the server, which
supports source code control using both Git and their own custom VCS, which
they&#8217;ve dubbed <emphasis role="strong">TFVC</emphasis> (Team Foundation Version Control).  Git support is a
somewhat new feature for TFS (shipping with the 2013 version), so all of the
tools that predate that refer to the version-control portion as <literal>TFS</literal>, even
though they mostly work with TFVC.</simpara>
<simpara>If you find yourself on a team using TFVC but you&#8217;d rather use Git as your VCS
client, there&#8217;s hope.</simpara>
<section xml:id="_which_tool">
<title>Which Tool</title>
<simpara><indexterm>
<primary>git-tf</primary>
</indexterm><indexterm>
<primary>git-tfs</primary>
</indexterm>
In fact, there are two possibilities: <literal>git-tf</literal> and <literal>git-tfs</literal>.</simpara>
<simpara><literal>git-tfs</literal> (found at <link xl:href="https://github.com/<literal>git-tfs</literal>/<literal>git-tfs</literal>">https://github.com/<literal>git-tfs</literal>/<literal>git-tfs</literal></link>) is a .NET
project, and (as of this writing) only runs on Windows.  To work with Git
repositories, it uses the .NET bindings for libgit2, a library structured
implementation of Git which has excellent performance and has no trouble
accessing a Git repository.  Libgit2 is not a complete implementation of Git,
so to make up for any missing features, <literal>git-tfs</literal> actually calls the
command-line Git client for some operations, so there are no artificial limits
on what it can do.  Its support of TFVC features is very mature, since it uses
the Visual Studio assemblies for communicating with servers.  This does mean
you need access to those assemblies, which means you need to install a recent
version of Visual Studio (any edition since version 2010, including Express
since version 2012), or the Visual Studio SDK.</simpara>
<simpara><literal>git-tf</literal> (whose home is <link xl:href="https://gittf.codeplex.com">https://gittf.codeplex.com</link>) is a Java project, and as
such runs on any computer with a Java runtime environment.  It interfaces with
Git repositories through JGit (a JVM implementation of Git), which means it has
virtually no limitations in terms of Git functions.  However, its support for
TFVC is limited compared to <literal>git-tfs</literal>&#8201;&#8212;&#8201;it doesn&#8217;t support branches, for
instance.</simpara>
<simpara>So each tool has pros and cons, and there are plenty of situations that favor
one over the other.  We cover the basic usage of both in this book.</simpara>
<note>
<simpara>You need access to a TFVC-based repository to follow along with these instructions.
These aren&#8217;t as plentiful in the wild as Git or Subversion repositories,
so you may need to create one of your own.
Codeplex (<link xl:href="https://www.codeplex.com">https://www.codeplex.com</link>) or Visual Studio Online (<link xl:href="http://www.visualstudio.com">http://www.visualstudio.com</link>)
are both good choices for where to look.</simpara>
</note>
</section>
<section xml:id="_getting_started_literal_git_tf_literal">
<title>Getting Started: <literal>git-tf</literal></title>
<simpara>The first thing to do, just as with any Git project, is clone.  Here&#8217;s how to
do that when running <literal>git-tf</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git</programlisting>
<simpara>The first argument is the URL of a TFVC collection, the second is of the form
<literal>$/project/branch</literal>, and the third is the path to the local Git repository
that&#8217;s to be created (this is optional).  <literal>git-tf</literal> can only work with
one branch at a time. To make checkins on a different TFVC branch, you have to
make a new clone from that branch.</simpara>
<simpara>This creates a fully functional Git repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd project_git
$ git log --all --oneline --decorate
512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message</programlisting>
<simpara>This is called a <emphasis>shallow</emphasis> clone, meaning it only contains the latest
changeset.  TFVC isn&#8217;t designed for each client to have a full copy of the
history, so <literal>git-tf</literal> defaults to only getting the latest version, which is much
faster.</simpara>
<simpara>If you have some time, go ahead and clone the entire project history, using the
<literal>--deep</literal> flag:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main \
  project_git --deep
Username: domain\user
Password:
Connecting to TFS...
Cloning $/myproject into /tmp/project_git: 100%, done.
Cloned 4 changesets. Cloned last changeset 35190 as d44b17a
$ cd project_git
$ git log --all --oneline --decorate
d44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye
126aa7b (tag: TFS_C35189)
8f77431 (tag: TFS_C35178) FIRST
0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
        Team Project Creation Wizard</programlisting>
<simpara>Notice the tags with names like <literal>TFS_C35189</literal>. This is a feature that shows
which Git commits are associated with which TFVC changesets.  This is a
nice way to present this information, since you can run a simple <literal>git log</literal> to
see which of your commits is associated with a snapshot that also exists in
TFVC.  They aren&#8217;t necessary (and in fact you can turn them off by running <literal>git
config git-tf.tag false</literal>)&#8201;&#8212;&#8201;<literal>git-tf</literal> keeps the real commit-changeset mappings
in the <literal>.git/git-tf</literal> file.</simpara>
</section>
<section xml:id="_getting_started_literal_git_tfs_literal">
<title>Getting Started: <literal>git-tfs</literal></title>
<simpara><literal>git-tfs</literal> cloning behaves a bit differently.
Observe:</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; git tfs clone --with-branches \
    https://username.visualstudio.com/DefaultCollection \
    $/project/Trunk project_git
Initialized empty Git repository in C:/Users/ben/project_git/.git/
C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9
C16 = c403405f4989d73a2c3c119e79021cb2104ce44a
Tfs branches found:
- $/tfvc-test/featureA
The name of the local branch will be : featureA
C17 = d202b53f67bde32171d5078968c644e562f1c439
C18 = 44cd729d8df868a8be20438fdeeefb961958b674</programlisting>
<simpara>Notice the <literal>--with-branches</literal> flag.  <literal>git-tfs</literal> is capable of mapping TFVC
branches to Git branches, and this flag tells it to set up a local Git branch
for every TFVC branch.  This is highly recommended if you&#8217;ve ever branched or
merged in TFS, but it doesn&#8217;t work with a server older than TFS 2010. Before
that release, <literal>branches</literal> were just folders, so <literal>git-tfs</literal> can&#8217;t tell them apart
from regular folders.</simpara>
<simpara>Let&#8217;s take a look at the resulting Git repository.</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; git log --oneline --graph --decorate --all
* 44cd729 (tfs/featureA, featureA) Goodbye
* d202b53 Branched from $/tfvc-test/Trunk
* c403405 (HEAD, tfs/default, master) Hello
* b75da1a New project
PS&gt; git log -1
commit c403405f4989d73a2c3c119e79021cb2104ce44a
Author: Ben Straub &lt;ben@straub.cc&gt;
Date:   Fri Aug 1 03:41:59 2014 +0000

    Hello

    git-tfs-id: [https://username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16</programlisting>
<simpara>There are two local branches, <literal>master</literal> and <literal>featureA</literal>, which represent the
initial starting point of the clone (<literal>Trunk</literal> in TFVC) and a child branch
(<literal>featureA</literal> in TFVC).  You can also see that the <literal>git-tfs</literal> remote has a couple
of refs too&#8201;&#8212;&#8201;<literal>default</literal> and <literal>featureA</literal>, which represent TFVC branches.
<literal>git-tfs</literal> maps the branch you cloned from to <literal>tfs/default</literal>, and others get
their own names.</simpara>
<simpara>Another thing to notice is the <literal>git-tfs-id:</literal> lines in the commit messages.
Instead of tags, <literal>git-tfs</literal> uses these markers to map TFVC changesets to Git
commits.  This has the implication that your Git commits have a different SHA-1
hash before and after they have been pushed to TFVC.</simpara>
</section>
<section xml:id="_git_tf_s_workflow">
<title>Git-tf[s] Workflow</title>
<note>
<simpara>Regardless of the tool you&#8217;re using, set the following Git configuration values
to avoid running into issues:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git config set --local core.ignorecase=true
$ git config set --local core.autocrlf=false</programlisting>
</note>
<simpara>The obvious next thing to do is start working on the project.  TFVC and TFS
have several features that may add complexity to your workflow.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Feature branches that aren&#8217;t represented in TFVC add complexity.
This has to do with the <emphasis role="strong">very</emphasis> different ways that TFVC and Git represent branches.</simpara>
</listitem>
<listitem>
<simpara>Be aware that TFVC allows users to <literal>checkout</literal> files from the server, locking them so nobody else can edit them.
This obviously doesn&#8217;t stop you from editing them in your local repository, but it could get in the way when it comes time to push your changes to the TFVC server.</simpara>
</listitem>
<listitem>
<simpara>TFS has the concept of <literal>gated</literal> checkins, where a TFS build-test cycle has to complete successfully before the checkin is allowed.
This uses the <literal>shelve</literal> function in TFVC, which we don&#8217;t cover in detail here.
  You can fake this manually with <literal>git-tf</literal>, and <literal>git-tfs</literal> provides the <literal>checkintool</literal> command which is gate-aware.</simpara>
</listitem>
</orderedlist>
<simpara>In the interest of brevity, what we cover here is the happy path, which sidesteps or avoids most of these issues.</simpara>
</section>
<section xml:id="_workflow_literal_git_tf_literal">
<title>Workflow: <literal>git-tf</literal></title>
<simpara>Let&#8217;s say you&#8217;ve done some work, made a couple of Git commits on <literal>master</literal>, and
you&#8217;re ready to share your progress on the TFVC server.  Here&#8217;s our Git
repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline --graph --decorate --all
* 4178a82 (HEAD, master) update code
* 9df2ae3 update readme
* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</programlisting>
<simpara>We want to take the snapshot that&#8217;s in the <literal>4178a82</literal> commit and push it to the
TFVC server.  First things first&#8201;&#8212;&#8201;let&#8217;s see if any of our teammates changed
anything since we last connected.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tf fetch
Username: domain\user
Password:
Connecting to TFS...
Fetching $/myproject at latest changeset: 100%, done.
Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.
$ git log --oneline --graph --decorate --all
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
| * 4178a82 (HEAD, master) update code
| * 9df2ae3 update readme
|/
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</programlisting>
<simpara>Looks like someone else has been working, too, and now we have divergent
history.  This is where Git shines, but we have two choices of how to proceed.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Making a merge commit feels natural as a Git user (after all, that&#8217;s what <literal>git pull</literal> does), and <literal>git-tf</literal> does this with a simple <literal>git tf pull</literal>.
Be aware, however, that TFVC doesn&#8217;t think this way, and if you push merge commits your history starts to look different on both sides, which can be confusing.
However, if you plan on submitting all of your changes as one changeset, this is probably the easiest choice.</simpara>
</listitem>
<listitem>
<simpara>Rebasing makes our commit history linear, which means we have the option of converting each of our Git commits into a TFVC changeset.
Since this leaves the most options open, we recommend you do it this way. <literal>git-tf</literal> even makes it easy for you with the <literal>pull --rebase</literal> subcommand.</simpara>
</listitem>
</orderedlist>
<simpara>The choice is yours. For this example, we&#8217;re rebasing.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rebase FETCH_HEAD
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</programlisting>
<simpara>Now we&#8217;re ready to make a checkin to the TFVC server.  <literal>git-tf</literal> gives the
choice of making a single changeset that represents all the changes since the
last one (<literal>--shallow</literal>, which is the default), or creating a new changeset for
each Git commit (<literal>--deep</literal>).  For this example, we just create one changeset.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tf checkin -m 'Updating readme and code'
Username: domain\user
Password:
Connecting to TFS...
Checking in to $/myproject: 100%, done.
Checked commit 5a0e25e in as changeset 35348
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</programlisting>
<simpara>There&#8217;s a new <literal>TFS_C35348</literal> tag, indicating that TFVC is storing the exact same
snapshot as the <literal>5a0e25e</literal> commit.  It&#8217;s important to note that not every Git
commit needs to have an exact counterpart in TFVC. The <literal>6eb3eb5</literal> commit, for
example, doesn&#8217;t exist anywhere on the server.</simpara>
<simpara>That&#8217;s the main workflow.  There are a couple of other considerations to keep in mind.</simpara>
<itemizedlist>
<listitem>
<simpara>There&#8217;s no branching.
<literal>git-tf</literal> can only create Git repositories from one TFVC branch at a time.</simpara>
</listitem>
<listitem>
<simpara>Collaborate using either TFVC or Git, but not both.
Different <literal>git-tf</literal> clones of the same TFVC repository may have different commit SHA-1 hashes, which causes no end of headaches.</simpara>
</listitem>
<listitem>
<simpara>If your team&#8217;s workflow includes collaborating in Git and syncing periodically with TFVC, only connect to TFVC with one of the Git repositories.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_workflow_literal_git_tfs_literal">
<title>Workflow: <literal>git-tfs</literal></title>
<simpara>Let&#8217;s walk through the same scenario using <literal>git-tfs</literal>.
Here are the new commits we&#8217;ve made to <literal>master</literal> in our repository.</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; git log --oneline --graph --all --decorate
* c3bd3ae (HEAD, master) update code
* d85e5a2 update readme
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 (tfs/default) Hello
* b75da1a New project</programlisting>
<simpara>Now let&#8217;s see if anyone else has done work while we were hacking away.</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; git tfs fetch
C19 = aea74a0313de0a391940c999e51c5c15c381d91d
PS&gt; git log --all --oneline --graph --decorate
* aea74a0 (tfs/default) update documentation
| * c3bd3ae (HEAD, master) update code
| * d85e5a2 update readme
|/
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</programlisting>
<simpara>Yes, it turns out a coworker has added a new TFVC changeset, which shows up as
the new <literal>aea74a0</literal> commit, and the <literal>tfs/default</literal> remote branch has moved.</simpara>
<simpara>As with <literal>git-tf</literal>, we have two fundamental options for how to resolve this divergent history.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Rebase to preserve a linear history.</simpara>
</listitem>
<listitem>
<simpara>Merge to preserve what actually happened.</simpara>
</listitem>
</orderedlist>
<simpara>In this case, we&#8217;re going to do a <literal>deep</literal> checkin, where every Git commit
becomes a TFVC changeset, so we want to rebase.</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; git rebase tfs/default
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
PS&gt; git log --all --oneline --graph --decorate
* 10a75ac (HEAD, master) update code
* 5cec4ab update readme
* aea74a0 (tfs/default) update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</programlisting>
<simpara>Now we&#8217;re ready to complete our contribution by checking in our code to the
TFVC server.  We run the <literal>rcheckin</literal> sub-command here to create a TFVC changeset for
each Git commit in the path from <literal>HEAD</literal> to the first <literal>tfs</literal> remote branch found
(the <literal>checkin</literal> command would only create one changeset, sort of like squashing
Git commits).</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; git tfs rcheckin
Working with tfs remote: default
Fetching changes from TFS to minimize possibility of late conflict...
Starting checkin of 5cec4ab4 'update readme'
 add README.md
C20 = 71a5ddce274c19f8fdc322b4f165d93d89121017
Done with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, rebasing tail onto new TFS-commit...
Rebase done successfully.
Starting checkin of b1bf0f99 'update code'
 edit .git\tfs\default\workspace\ConsoleApplication1/ConsoleApplication1/Program.cs
C21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b
Done with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, rebasing tail onto new TFS-commit...
Rebase done successfully.
No more to rcheckin.
PS&gt; git log --all --oneline --graph --decorate
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</programlisting>
<simpara>Notice how after every successful checkin to the TFVC server, <literal>git-tfs</literal> rebases
the remaining work onto what it just did.  That&#8217;s because it&#8217;s adding the
<literal>git-tfs-id</literal> field to the bottom of the commit messages, which changes the
SHA-1 hashes.  This is exactly as designed, and there&#8217;s nothing to worry about,
but you should be aware that it&#8217;s happening, especially if you&#8217;re sharing Git
commits with others.</simpara>
<simpara>TFS has many features that integrate with its VCS, such as work items,
designated reviewers, gated checkins, and so on.  It can be cumbersome to work
with these features using only a command-line tool, but fortunately <literal>git-tfs</literal>
lets you launch a graphical checkin tool very easily:</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; git tfs checkintool
PS&gt; git tfs ct</programlisting>
<simpara>It looks a bit like</simpara>
<figure>
<title>The git-tfs checkin tool.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/git-tfs-ct.png"/>
</imageobject>
<textobject><phrase>The git-tfs checkin tool.</phrase></textobject>
</mediaobject>
</figure>
<simpara>This looks familiar to TFS users, since it&#8217;s the same dialog box that&#8217;s launched
from within Visual Studio.</simpara>
<simpara><literal>git-tfs</literal> also lets you control TFVC branches from your Git repository.
As an example, let&#8217;s create one.</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; git tfs branch $/tfvc-test/featureBee
The name of the local branch will be : featureBee
C26 = 1d54865c397608c004a2cadce7296f5edc22a7e5
PS&gt; git log --oneline --graph --decorate --all
* 1d54865 (tfs/featureBee) Creation branch $/myproject/featureBee
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</programlisting>
<simpara>Creating a branch in TFVC means adding a changeset where that branch now
exists, which is projected as a Git commit.  Note also that <literal>git-tfs</literal> <emphasis role="strong">created</emphasis>
the <literal>tfs/featureBee</literal> remote branch, but <literal>HEAD</literal> is still pointing to <literal>master</literal>.
To work on the newly-minted branch, base your new commits on the <literal>1d54865</literal>
commit, perhaps by creating a topic branch from that commit.</simpara>
</section>
<section xml:id="_git_and_tfs_summary">
<title>Git and TFS Summary</title>
<simpara><literal>git-tf</literal> and <literal>git-tfs</literal> are both great tools for interfacing with a TFVC server.
They allow using the power of Git locally, without having to constantly make
round-trips to the central TFVC server, and make your life as a developer much
easier, without forcing your entire team to migrate to Git.  If you&#8217;re working
on Windows (which is likely if your team is using TFS), you probably want to
use <literal>git-tfs</literal>, since its feature set is more complete, but if you&#8217;re working on
another platform, you&#8217;re probably using <literal>git-tf</literal>, which is more limited.  As
with most of the tools in this chapter, you should choose one of these VCSs as
your standard, and use the other one in a subordinate fashion&#8201;&#8212;&#8201;either Git or
TFVC should be the center of collaboration, but not both.</simpara>
</section>
</section>
</section>
<section xml:id="_migrating">
<title>Migrating to Git</title>
<simpara><indexterm>
<primary>Migrating to Git</primary>
</indexterm>
If you have an existing project in another VCS but you&#8217;ve decided to switch to Git,
you must somehow migrate everything over.
This section goes over importers for common VCSs, and then demonstrates how to develop
your own custom importer. You learn how to import from several of the popular professional VCSs,
because they&#8217;re used by the majority of users who are switching, and because high-quality
tools for making the switch are easy to come by.</simpara>
<section xml:id="_subversion">
<title>Subversion</title>
<simpara><indexterm>
<primary>Subversion</primary>
</indexterm>
<indexterm>
<primary>Importing</primary><secondary>from Subversion</secondary>
</indexterm>
<indexterm>
<primary>from Subversion</primary>
</indexterm>
If you read the previous section about using <literal>git svn</literal>, you can easily use those instructions to run
<literal>git svn clone</literal> to clone a repository. Then, stop using the Subversion server, push to a new Git server,
and start using that. If you want the repository&#8217;s history, you can accomplish that as quickly as
you can pull the data out of the Subversion server (which may take a while).</simpara>
<simpara>However, the clone isn&#8217;t perfect, and because it takes so long, you may as well do it right.
The first problem is the author information.
In Subversion, the account name of the person making the commit is recorded in the commit information.
The examples in the previous section show <literal>schacon</literal> in some places, such as the <literal>git blame</literal> and
the <literal>git svn log</literal> output.
To map this better to Git author data, you need a mapping from Subversion users to Git authors.
Create a file called <literal>users.txt</literal> that has this mapping in a format like</simpara>
<screen>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;</screen>
<simpara>To get a list of the author names that SVN uses, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ svn log --xml --quiet | grep author | sort -u | \
  perl -pe 's/.*&gt;(.*?)&lt;.*/$1 = /'</programlisting>
<simpara>That generates the log output in XML format, then keeps only the lines with author information, discards duplicates, and strips out the XML tags.
(Obviously this only works on a machine with <literal>grep</literal>, <literal>sort</literal>, and <literal>perl</literal> installed.)
Then, redirect that output into <literal>users.txt</literal> so you can add the equivalent Git user data next to each entry.</simpara>
<simpara>You can provide this file to <literal>git svn</literal> to help it map the author data more accurately.
You can also tell <literal>git svn</literal> to not include the metadata that Subversion normally imports by passing the <literal>--no-metadata</literal> flag to the <literal>git svn clone</literal> or <literal>git init</literal> command.
However this isn&#8217;t recommended because it breaks the two-way synchronization
between the Git and Subversion repositories.
This makes your <literal>import</literal> command look like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git svn clone http://my-project.googlecode.com/svn/ \
      --authors-file=users.txt --no-metadata --prefix "" -s my_project
$ cd my_project</programlisting>
<simpara>Now you should have a nicer Subversion import in your <literal>my_project</literal> directory.
Instead of commits that look like this</simpara>
<screen>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029</screen>
<simpara>they look like</simpara>
<screen>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk</screen>
<simpara>Not only does the Author field look a lot better, but <literal>git-svn-id</literal> is no longer there, either.</simpara>
<simpara>You should also do a bit of post-import cleanup.
For one thing, you should clean up the weird references that <literal>git svn</literal> sets up.
First, move the tags so they&#8217;re actual tags rather than strange remote branches, and then move
the rest of the branches so they&#8217;re local.</simpara>
<simpara>To move the tags to be proper Git tags, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ for t in $(git for-each-ref --format='%(refname:short)' refs/remotes/tags); do git tag ${t/tags\//} $t &amp;&amp; git branch -D -r $t; done</programlisting>
<simpara>This takes the references that were remote branches whose names started with <literal>remotes/origin/tags/</literal> and
makes them real (lightweight) tags.</simpara>
<simpara>Next, move the rest of the references under <literal>refs/remotes</literal> to be local branches.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ for b in $(git for-each-ref --format='%(refname:short)' refs/remotes); do git branch $b refs/remotes/$b &amp;&amp; git branch -D -r $b; done</programlisting>
<simpara>You might see some extra branches which are suffixed by <literal>@xxx</literal> (where xxx is a number), while
in Subversion you only see one branch. This is actually a Subversion feature called "peg-revisions",
which is something that Git simply has no syntactic counterpart for. For this reason, <literal>git svn</literal>
simply adds the Subversion version number to the branch name in the same way as you would have
written it in Subversion to address the peg-revision of that branch. If you don&#8217;t care about the
peg-revisions, simply remove them by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ for p in $(git for-each-ref --format='%(refname:short)' | grep @); do git branch -D $p; done</programlisting>
<simpara>Now all the old branches are real Git branches and all the old tags are real Git tags.</simpara>
<simpara>There&#8217;s one last thing to clean up. Unfortunately, <literal>git svn</literal> creates an extra branch named <literal>trunk</literal>,
which maps to Subversion&#8217;s default branch, but the <literal>trunk</literal> ref points to the same place as <literal>master</literal>.
Since <literal>master</literal> is more idiomatically Git, here&#8217;s how to remove the extra branch.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch -d trunk</programlisting>
<simpara>The last thing to do is add your new Git server as a remote and push to it.
Here&#8217;s an example of adding your server as a remote.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add origin git@my-git-server:myrepository.git</programlisting>
<simpara>Because you want all your branches and tags to be transferred, now run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin --tags</programlisting>
<simpara>All your branches and tags should be on your new Git server in a nice, clean import.</simpara>
</section>
<section xml:id="_mercurial">
<title>Mercurial</title>
<simpara><indexterm>
<primary>Mercurial</primary>
</indexterm><indexterm>
<primary>Importing</primary><secondary>from Mercurial</secondary>
</indexterm>
<indexterm>
<primary>from Mercurial</primary>
</indexterm>
Since Mercurial and Git have fairly similar models for representing versions, and since Git is a bit
more flexible, converting a repository from Mercurial to Git is fairly straightforward.
You use a tool called <literal>hg-fast-export</literal>, which you need to install first.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone http://repo.or.cz/r/fast-export.git /tmp/fast-export</programlisting>
<simpara>The first step in the conversion is to get a full clone of the Mercurial repository you want to convert.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ hg clone &lt;remote repo URL&gt; /tmp/hg-repo</programlisting>
<simpara>The next step is to create an author mapping file.
Mercurial is a bit more forgiving than Git for what it puts in the author field in changesets,
so this is a good time to clean house. Generating this is a one-line command in <literal>bash</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd /tmp/hg-repo
$ hg log | grep user: | sort | uniq | sed 's/user: *//' &gt; ../authors</programlisting>
<simpara>This takes a few seconds, depending on how long your project&#8217;s history is, and afterwards
the <literal>/tmp/authors</literal> file looks something like</simpara>
<screen>bob
bob@localhost
bob &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;
Bob Jones &lt;bob@company.com&gt;
Joe Smith &lt;joe@company.com&gt;</screen>
<simpara>In this example, the same person (Bob) created changesets under four different names, one of which
actually looks correct, and one of which would be completely invalid in a Git commit.
<literal>hg-fast-export</literal> fixes this by adding <literal>={new name and email address}</literal> at the end of every line we
want to change, and removing the lines containing any usernames that we want to ignore.
If all the usernames look fine, we don&#8217;t need this file at all.
In this example, we want our file to look like</simpara>
<screen>bob=Bob Jones &lt;bob@company.com&gt;
bob@localhost=Bob Jones &lt;bob@company.com&gt;
bob &lt;bob@company.com&gt;=Bob Jones &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;=Bob Jones &lt;bob@company.com&gt;</screen>
<simpara>The next step is to create our new Git repository, and run the export script.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git init /tmp/converted
$ cd /tmp/converted
$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</programlisting>
<simpara>The <literal>-r</literal> flag tells <literal>hg-fast-export</literal> where to find the Mercurial repository to convert,
and the <literal>-A</literal> flag tells it where to find the author-mapping file.
The script parses Mercurial changesets and converts them into a script for Git&#8217;s "fast-import" feature
(which we discuss in detail a bit later on).
This takes a bit (though it&#8217;s <emphasis>much</emphasis> faster than it would be over the network), and the
output is fairly verbose.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
Loaded 4 authors
master: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files
master: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files
master: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files
[…]
master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed files
master: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed files
master: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed files
Exporting tag [0.4c] at [hg r9] [git :10]
Exporting tag [0.4d] at [hg r16] [git :17]
[…]
Exporting tag [3.1-rc] at [hg r21926] [git :21927]
Exporting tag [3.1] at [hg r21973] [git :21974]
Issued 22315 commands
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:     120000
Total objects:       115032 (    208171 duplicates                  )
      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)
      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)
      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:         109 (         2 loads     )
      marks:        1048576 (     22208 unique    )
      atoms:           1952
Memory total:          7860 KiB
       pools:          2235 KiB
     objects:          5625 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =      90430
pack_report: pack_mmap_calls          =      46771
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =  340852700 /  340852700
---------------------------------------------------------------------

$ git shortlog -sn
   369  Bob Jones
   365  Joe Smith</programlisting>
<simpara>That&#8217;s pretty much all there is to it.
All of the Mercurial tags have been converted to Git tags, and Mercurial branches and bookmarks
have been converted to Git branches.
Now you&#8217;re ready to push the repository to its new server-side home.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add origin git@my-git-server:myrepository.git
$ git push origin --all</programlisting>
</section>
<section xml:id="_bazaar">
<title>Bazaar</title>
<simpara><indexterm>
<primary>Bazaar</primary>
</indexterm><indexterm>
<primary>Importing</primary><secondary>from Bazaar</secondary>
</indexterm>
<indexterm>
<primary>from Bazaar</primary>
</indexterm></simpara>
<simpara>Bazaar is a DVCS tool much like Git, and as a result it&#8217;s pretty straightforward to convert a Bazaar
repository into a Git one.
To accomplish this, install the <literal>bzr-fastimport</literal> plugin.</simpara>
<section xml:id="_getting_the_bzr_fastimport_plugin">
<title>Getting the bzr-fastimport plugin</title>
<simpara>The procedure for installing the <literal>bzr-fastimport</literal> plugin is different on UNIX-like operating systems than
on Windows. On Unix-like operating systems, it&#8217;s best to install the <literal>bzr-fastimport</literal> package which will
also install all the required dependencies.</simpara>
<simpara>For example, on a Debian-based OS, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo apt-get install bzr-fastimport</programlisting>
<simpara>On RHEL-based OSs, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo yum install bzr-fastimport</programlisting>
<simpara>On Fedora, since release 22, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ sudo dnf install bzr-fastimport</programlisting>
<simpara>If the package isn&#8217;t available, install it as a plugin.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ mkdir --parents ~/.bazaar/plugins     # creates the necessary folders for the plugins
$ cd ~/.bazaar/plugins
$ bzr branch lp:bzr-fastimport fastimport   # imports the fastimport plugin
$ cd fastimport
$ sudo python setup.py install --record=files.txt   # installs the plugin</programlisting>
<simpara>For this plugin to work, you also need the <literal>fastimport</literal> Python module.
Install it by running the following commands:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ python -c "import fastimport"
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
ImportError: No module named fastimport
$ pip install fastimport</programlisting>
<simpara>If the module isn&#8217;t available, download it from <link xl:href="https://pypi.python.org/pypi/fastimport/">https://pypi.python.org/pypi/fastimport/</link>.</simpara>
<simpara>On Windows <literal>bzr-fastimport</literal> is automatically installed with the standalone version of Python
using the default installation options.</simpara>
<simpara>At this point, the way to import a Bazaar repository differs according to whether you have
a single branch or you&#8217;re working with a repository with several branches.</simpara>
</section>
<section xml:id="_project_with_a_single_branch">
<title>Project with a single branch</title>
<simpara>First, <literal>cd</literal> to the directory that contains your Bazaar repository and initialize the Git repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd /path/to/the/bzr/repository
$ git init</programlisting>
<simpara>Now, simply export your Bazaar repository and convert it into a Git repository using the following command:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ bzr fast-export --plain . | git fast-import</programlisting>
<simpara>Your Git repository is built in anywhere from a few seconds to a few minutes,
depending on the size of your project.</simpara>
</section>
<section xml:id="_a_project_with_a_main_branch_and_a_working_branch">
<title>A project with a main branch and a working branch</title>
<simpara>You can also import a Bazaar repository that contains branches.
Let&#8217;s suppose that you have two branches&#8201;&#8212;&#8201;the main branch (myProject.trunk) and the working branch (myProject.work).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ ls
myProject.trunk myProject.work</programlisting>
<simpara>Create the Git repository and <literal>cd</literal> into it.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git init git-repo
$ cd git-repo</programlisting>
<simpara>Pull the master branch into Git.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ bzr fast-export --export-marks=../marks.bzr ../myProject.trunk | \
git fast-import --export-marks=../marks.git</programlisting>
<simpara>Pull the working branch into Git.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ bzr fast-export --marks=../marks.bzr --git-branch=work ../myProject.work | \
git fast-import --import-marks=../marks.git --export-marks=../marks.git</programlisting>
<simpara>Now <literal>git branch</literal> shows <literal>master</literal> as well as <literal>work</literal>.
Check the logs to make sure the import is complete. Then remove <literal>marks.bzr</literal> and <literal>marks.git</literal>.</simpara>
</section>
<section xml:id="_synchronizing_the_staging_area">
<title>Synchronizing the staging area</title>
<simpara>Whatever the number of branches you had and the import method you used,
your staging area is not synchronized with <literal>HEAD</literal>. Neither is your working directory.
Correct this by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git reset --hard HEAD</programlisting>
</section>
<section xml:id="_ignoring_the_files_that_were_ignored_with_bzrignore">
<title>Ignoring the files that were ignored with .bzrignore</title>
<simpara>Now let&#8217;s have a look at the files to ignore.
The first thing to do is to rename <literal>.bzrignore</literal> to <literal>.gitignore</literal>.</simpara>
<simpara>Finally, create a commit that contains this modification.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git mv .bzrignore .gitignore
$ # modify .gitignore if needed
$ git commit -am 'Migration from Bazaar to Git'</programlisting>
</section>
<section xml:id="_sending_your_repository_to_the_server">
<title>Sending your repository to the server</title>
<simpara>Here we are! Now push the repository onto its new home server.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add origin git@my-git-server:mygitrepository.git
$ git push origin --all
$ git push origin --tags</programlisting>
<simpara>Your Git repository is ready to use.</simpara>
</section>
</section>
<section xml:id="_perforce_import">
<title>Perforce</title>
<simpara><indexterm>
<primary>Perforce</primary>
</indexterm><indexterm>
<primary>Importing</primary><secondary>from Perforce</secondary>
</indexterm>
<indexterm>
<primary>from Perforce</primary>
</indexterm>
The next system we look at importing from is Perforce.
As we discussed above, there are two ways for Git and Perforce to talk to each other&#8201;&#8212;&#8201;<literal>git-p4</literal>
and Perforce Git Fusion.</simpara>
<section xml:id="_perforce_git_fusion">
<title>Perforce Git Fusion</title>
<simpara>Git Fusion makes this process fairly painless.
Just configure your project settings, user mappings, and branches using a configuration file
(as discussed in <xref linkend="_p4_git_fusion"/>), and clone the repository.
Git Fusion leaves what looks like a native Git repository, which is then ready to be pushed to an actual Git server.
You could even run Perforce on your Git server.</simpara>
</section>
<section xml:id="_git_p4">
<title><literal>git-p4</literal></title>
<simpara><literal>git-p4</literal> can also act as an import tool.
As an example, we import the Jam project from the Perforce Public Depot.
To set up your client, point the P4PORT environment variable to the Perforce depot and export P4PORT.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ export P4PORT=public.perforce.com:1666</programlisting>
<note>
<simpara>In order to follow along, you need a Perforce depot to connect with.
We&#8217;re using the public depot at public.perforce.com for our examples, but you can use any depot you have access to.</simpara>
</note>
<simpara><indexterm>
<primary>git commands</primary><secondary>p4</secondary>
</indexterm>
<indexterm>
<primary>p4</primary>
</indexterm>
Run <literal>git p4 clone</literal> to import the Jam project from the Perforce server, supplying the depot and project path, and the path into which you want to import the project.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git-p4 clone //guest/perforce_software/jam@all p4import
Importing from //guest/perforce_software/jam@all into p4import
Initialized empty Git repository in /private/tmp/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 9957 (100%)</programlisting>
<simpara>This particular project has only one branch, but if you have branches that are configured with branch views (or just a set of directories), add the <literal>--detect-branches</literal> flag to <literal>git p4 clone</literal> to import all the project&#8217;s branches as well.
See <xref linkend="_git_p4_branches"/> for a bit more detail.</simpara>
<simpara>At this point you&#8217;re almost done.
If you go to the <literal>p4import</literal> directory and run <literal>git log</literal>, you see your imported work.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

    [git-p4: depot-paths = "//public/jam/src/": change = 8068]

commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).

    [git-p4: depot-paths = "//public/jam/src/": change = 7304]</programlisting>
<simpara>You can see that <literal>git-p4</literal> has left an identifier in each commit message.
It&#8217;s fine to keep that identifier there, in case you need to reference the Perforce change number later.
However, if you&#8217;d like to remove the identifier, now is the time to do so&#8201;&#8212;&#8201;before you start doing work
on the new repository.
<indexterm>
<primary>git commands</primary><secondary>filter-branch</secondary>
</indexterm>
<indexterm>
<primary>filter-branch</primary>
</indexterm>
Run <literal>git filter-branch</literal> to remove the identifier strings en masse.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git filter-branch --msg-filter 'sed -e "/^\[git-p4:/d"'
Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Ref 'refs/heads/master' was rewritten</programlisting>
<simpara>If you run <literal>git log</literal>, you see that all the SHA-1 hashes for the commits have changed because the <literal>git-p4</literal>
strings are no longer in the commit messages.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).</programlisting>
<simpara>Your import is ready to push to your Git server.</simpara>
</section>
</section>
<section xml:id="_git_tfs">
<title>TFS</title>
<simpara><indexterm>
<primary>TFS</primary>
</indexterm><indexterm>
<primary>Importing</primary><secondary>from TFS</secondary>
</indexterm>
<indexterm>
<primary>from TFS</primary>
</indexterm>
If your team is converting their VCS from TFVC to Git, you want the highest-fidelity conversion you can get.
This means that, while we covered both <literal>git-tfs</literal> and <literal>git-tf</literal> previously, we only cover <literal>git-tfs</literal> in this part,
because <literal>git-tfs</literal> supports branches which is prohibitively difficult using <literal>git-tf</literal>.</simpara>
<note>
<simpara>This is a one-way conversion.
The resulting Git repository can&#8217;t connect with the original TFVC project.</simpara>
</note>
<simpara>The first thing to do is map usernames.
TFVC is fairly liberal with what goes into the author field in changesets, but Git wants a human-readable
name and email address. You can get these from the <literal>tf</literal> command-line client.</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; tf history $/myproject -recursive &gt; AUTHORS_TMP</programlisting>
<simpara>This grabs all of the changeset information in the history of the project and puts it in the AUTHORS_TMP
file that we process to extract the data of the <literal>User</literal> column (column 2).
Open the file and find the position where author names start and end. Then, replace, in the following command-line,
the starting and ending columns <literal>11-20</literal> of the <literal>cut</literal> command with the ones found.</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; cat AUTHORS_TMP | cut -b 11-20 | tail -n+3 | uniq | sort &gt; AUTHORS</programlisting>
<simpara><literal>cut</literal> keeps only the characters in columns 11 through 20 inclusive from each line.
<literal>tail</literal> skips the first two lines, which are field headers and ASCII-art underlines.
The result of all of this is piped to <literal>uniq</literal> to eliminate duplicates, and saved to a file named <literal>AUTHORS</literal>.
The next step is manual. In order for <literal>git-tfs</literal> to make effective use of this file, each line must be in the
following format:</simpara>
<programlisting language="text" linenumbering="unnumbered">DOMAIN\username = User Name &lt;email@address.com&gt;</programlisting>
<simpara>The portion on the left of the equals sign is the <literal>User</literal> field from TFVC, and the portion on the right side
is the username that&#8217;s used in Git commits.</simpara>
<simpara>Once you have this file, the next thing to do is make a full clone of the TFVC project you&#8217;re interested in.</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; git tfs clone --with-branches --authors=AUTHORS https://username.visualstudio.com/DefaultCollection $/project/Trunk project_git</programlisting>
<simpara>Next clean the <literal>git-tfs-id</literal> sections from the bottom of the commit messages.
The following command does that:</simpara>
<programlisting language="powershell" linenumbering="unnumbered">PS&gt; git filter-branch -f --msg-filter 'sed "s/^git-tfs-id:.*$//g"' '--' --all</programlisting>
<simpara>That runs <literal>sed</literal> to replace any line starting with <literal>git-tfs-id:</literal> with an empty string, which Git then ignores.</simpara>
<simpara>Once that&#8217;s done, you&#8217;re ready to add a new remote, push all your branches, and have your team start working from Git.</simpara>
</section>
<section xml:id="_custom_importer">
<title>A Custom Importer</title>
<simpara><indexterm>
<primary>git commands</primary><secondary>fast-import</secondary>
</indexterm>
<indexterm>
<primary>fast-import</primary>
</indexterm>
<indexterm>
<primary>Importing</primary><secondary>from others</secondary>
</indexterm>
<indexterm>
<primary>from others</primary>
</indexterm>
If your VCS isn&#8217;t one of the above, try looking for an importer program&#8201;&#8212;&#8201;quality importers are available for
many other VCSs, including CVS, Clear Case, Visual Source Safe, and even a directory of archives.
If none of these work for you or you have a more obscure VCS, consider <literal>git fast-import</literal>.
This command reads simple instructions from stdin and writes Git data, doing what the instructions say.
It&#8217;s much easier to create a Git repository this way than to try to figure out how to write the raw files in a
Git repository (see <xref linkend="_git_internals"/>).
Running <literal>git fast-import</literal> lets you write an import script that reads the necessary information out of the VCS
you&#8217;re importing from and prints straightforward instructions to stdout.
You then run this program and pipe its output through <literal>git fast-import</literal>.</simpara>
<simpara>To quickly demonstrate, let&#8217;s write a simple importer.
Suppose you work in the <literal>current</literal> directory, and you back up your project by occasionally copying the directory into a
directory with a time-stamped name, such as <literal>back_YYYY_MM_DD</literal>. You want to import this into Git.
Your directory structure looks like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current</programlisting>
<simpara>In order to import into a Git directory, you need to review how a Git repository is structured.
As you may remember, Git is fundamentally a linked list of commits that point to a snapshot of content.
All you have to do is tell <literal>git fast-import</literal> what the content snapshots are, what commit data points to them,
and the order they go in.
Your strategy is to go through the snapshots one by one and create commits with the content of each directory,
linking each commit back to the previous one.</simpara>
<simpara>As in <xref linkend="_an_example_git_enforced_policy"/>, we write this in Ruby, because it&#8217;s what we generally work
with and it tends to be easy to read.
You can write this example pretty easily in anything you&#8217;re familiar with. It just needs to print the
appropriate information to <literal>stdout</literal>.
And, if you&#8217;re running Windows, this means you need to take special care to not introduce a carriage return
(CR) at the end of lines. <literal>git fast-import</literal> is very particular about just accepting line feeds (LF)
rather than the carriage return line feed (CRLF) that Windows uses.</simpara>
<simpara>To begin, change to the target directory and identify every subdirectory, each of contains a snapshot
that you want to import as a commit. Change to each subdirectory and print the commands necessary to export it.
Your basic main loop looks like</simpara>
<programlisting language="ruby" linenumbering="unnumbered">last_mark = nil

# loop through the directories
Dir.chdir(ARGV[0]) do
  Dir.glob("*").each do |dir|
    next if File.file?(dir)

    # move into the target directory
    Dir.chdir(dir) do
      last_mark = print_export(dir, last_mark)
    end
  end
end</programlisting>
<simpara>Run <literal>print_export</literal> inside each directory, which takes the file list and mark of the previous snapshot and returns the file list and mark of the current directory. This allows the directories to be linked properly.
<literal>Mark</literal> is the <literal>git fast-import</literal> term for an identifier you give to a commit. As you create commits, give each one a mark that you can use to link to it from other commits.
So, the first thing to do in your <literal>print_export</literal> method is to generate a mark from the directory name.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">mark = convert_dir_to_mark(dir)</programlisting>
<simpara>Do this by creating an array of directories and using the index value as the mark, because a mark must be an integer.
Your method looks like</simpara>
<programlisting language="ruby" linenumbering="unnumbered">$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks &lt;&lt; dir
  end
  ($marks.index(dir) + 1).to_s
end</programlisting>
<simpara>Now that you have an integer representation of your commit, you need a date for the commit metadata.
Because the date is expressed in the name of the directory, parse out the date.
The next line in your <literal>print_export</literal> file is</simpara>
<programlisting language="ruby" linenumbering="unnumbered">date = convert_dir_to_date(dir)</programlisting>
<simpara>where <literal>convert_dir_to_date</literal> is defined as</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def convert_dir_to_date(dir)
  if dir == 'current'
    return Time.now().to_i
  else
    dir = dir.gsub('back_', '')
    (year, month, day) = dir.split('_')
    return Time.local(year, month, day).to_i
  end
end</programlisting>
<simpara>That returns an integer value for the date of each directory.
The last piece of metadata you need for each commit is the committer data, which you hardcode in a global variable.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">$author = 'John Doe &lt;john@example.com&gt;'</programlisting>
<simpara>Now you&#8217;re ready to begin to output the commit data for your importer.
The initial information states that you&#8217;re defining a commit and what branch it&#8217;s on, followed by the mark you&#8217;ve
generated, the committer information and commit message, and then the previous commit, if any. The code looks like</simpara>
<programlisting language="ruby" linenumbering="unnumbered"># print the import information
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark</programlisting>
<simpara>Hardcode the time zone (-0700) because doing so is easy.
If you&#8217;re importing from another system, specify the time zone as an offset.
The commit message must be expressed in a special format.</simpara>
<screen>data (size)\n(content)</screen>
<simpara>The format consists of the word <literal>data</literal>, the size of the data to be read, a newline, and finally the data.
Because you need to use the same format to specify the file content later, create the <literal>export_data</literal> helper method.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def export_data(string)
  print "data #{string.size}\n#{string}"
end</programlisting>
<simpara>All that&#8217;s left is to specify the file content for each snapshot.
This is easy, because you already have each snapshot in a directory. Output the <literal>deleteall</literal> command followed by
the content of each file in the directory. Git then records each snapshot appropriately.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">puts 'deleteall'
Dir.glob("**/*").each do |file|
  next if !File.file?(file)
  inline_data(file)
end</programlisting>
<simpara>Note:  Because many VCSs think of their revisions as changes from one commit to another, <literal>git fast-import</literal> can
also take commands with each commit to specify which files have been added, removed, or modified, and what
the new content is. You could calculate the differences between snapshots and provide only this data,
but doing so is more complex. You may as well give Git all the data and let it figure things out.
If this is better suited to your data, check the <literal>git fast-import</literal> man page for details about how to provide
your data in this manner.</simpara>
<simpara>The format for listing the new file content or specifying a modified file with the new content is as follows:</simpara>
<screen>M 644 inline path/to/file
data (size)
(file content)</screen>
<simpara>Here, 644 is the mode (if you have executable files, specify 755 instead), and inline says to output the content immediately after this line.
Your <literal>inline_data</literal> method looks like</simpara>
<programlisting language="ruby" linenumbering="unnumbered">def inline_data(file, code = 'M', mode = '644')
  content = File.read(file)
  puts "#{code} #{mode} inline #{file}"
  export_data(content)
end</programlisting>
<simpara>Reuse the <literal>export_data</literal> method you defined earlier, because it&#8217;s the same as the way you specified your commit message data.</simpara>
<simpara>The last thing to do is to return the current mark so it can be passed to the next iteration.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">return mark</programlisting>
<note>
<simpara>If you&#8217;re running Windows make sure that you add one extra step.
As mentioned before, Windows uses CRLF for line termination characters while <literal>git fast-import</literal> expects only LF.
To get around this problem and make <literal>git fast-import</literal> happy, tell Ruby to use LF instead of CRLF.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">$stdout.binmode</programlisting>
</note>
<simpara>That&#8217;s it.
Here&#8217;s the script in its entirety.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">#!/usr/bin/env ruby

$stdout.binmode
$author = "John Doe &lt;john@example.com&gt;"

$marks = []
def convert_dir_to_mark(dir)
    if !$marks.include?(dir)
        $marks &lt;&lt; dir
    end
    ($marks.index(dir)+1).to_s
end


def convert_dir_to_date(dir)
    if dir == 'current'
        return Time.now().to_i
    else
        dir = dir.gsub('back_', '')
        (year, month, day) = dir.split('_')
        return Time.local(year, month, day).to_i
    end
end

def export_data(string)
    print "data #{string.size}\n#{string}"
end

def inline_data(file, code='M', mode='644')
    content = File.read(file)
    puts "#{code} #{mode} inline #{file}"
    export_data(content)
end

def print_export(dir, last_mark)
    date = convert_dir_to_date(dir)
    mark = convert_dir_to_mark(dir)

    puts 'commit refs/heads/master'
    puts "mark :#{mark}"
    puts "committer #{$author} #{date} -0700"
    export_data("imported from #{dir}")
    puts "from :#{last_mark}" if last_mark

    puts 'deleteall'
    Dir.glob("**/*").each do |file|
        next if !File.file?(file)
        inline_data(file)
    end
    mark
end

# Loop through the directories
last_mark = nil
Dir.chdir(ARGV[0]) do
    Dir.glob("*").each do |dir|
        next if File.file?(dir)

        # move into the target directory
        Dir.chdir(dir) do
            last_mark = print_export(dir, last_mark)
        end
    end
end</programlisting>
<simpara>If you run this script, you see content that looks something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe &lt;john@example.com&gt; 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
# Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe &lt;john@example.com&gt; 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
#!/bin/env ruby

puts "Hey there"
M 644 inline README.md
(...)</programlisting>
<simpara>To run the importer, pipe this output through <literal>git fast-import</literal> while in the Git directory you want to import into.
You can create a new directory and then run <literal>git init</literal> in it for a starting point, and then run your script.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:           234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------</programlisting>
<simpara>When the script completes successfully, it shows a bunch of statistics about what it accomplished.
In this case, you imported 13 objects total for 4 commits into 1 branch.
Now, run <literal>git log</literal> to see your new history.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe &lt;john@example.com&gt;
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe &lt;john@example.com&gt;
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03</programlisting>
<simpara>There you go&#8201;&#8212;&#8201;a nice, clean Git repository.
It&#8217;s important to note that nothing is checked out. You don&#8217;t have any files in your working directory at first.
To get them, you must reset your current branch to where <literal>master</literal> is now.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ ls
$ git reset --hard master
HEAD is now at 3caa046 imported from current
$ ls
README.md main.rb</programlisting>
<simpara>You can do a lot more with <literal>git fast-import</literal>&#8201;&#8212;&#8201;handle different modes, binary data, multiple branches and merging,
tags, progress indicators, and more. A number of examples of more complex scenarios are available in
the <literal>contrib/fast-import</literal> directory of the Git source code.</simpara>
</section>
</section>
<section xml:id="_summary_12">
<title>Summary</title>
<simpara>You should feel comfortable using Git as a client for other VCSs, or importing nearly any
existing repository into Git. In the next chapter, we cover the raw internals of Git so
you can understand what&#8217;s really going on internally.</simpara>
</section>
</chapter>
<chapter xml:id="ch10-git-internals">
<title>Git Internals</title>
<simpara>You may have skipped to this chapter from a much earlier chapter, or you may have gotten here after sequentially
reading the entire book up to this point&#8201;&#8212;&#8201;in either case, this is where we go over the inner workings
and implementation of Git. We found that understanding this information was fundamentally important to appreciating
how useful and powerful Git is, but others have argued that it can be confusing and unnecessarily complex
for beginners. Thus, we&#8217;ve made this discussion the last chapter in the book so you could decide when to read it
in your learning process.</simpara>
<simpara>Now that you&#8217;re here, let&#8217;s get started.
First, if it isn&#8217;t yet clear, Git is fundamentally a content-addressable filesystem with a VCS user interface
written on top of it. You learn more about what this means in a bit.</simpara>
<simpara>In the early days of Git (mostly pre 1.5), the user interface was much more complex because it emphasized
this filesystem rather than a polished VCS. In the last few years, the UI has been refined until it&#8217;s as
clean and easy to use as any system out there. However, the memories linger about the early Git UI
that was complex and difficult to learn.</simpara>
<simpara>The content-addressable filesystem layer is amazingly cool, so we&#8217;ll cover that first in this chapter.
Then, you&#8217;ll learn about the transport mechanisms and the repository maintenance tasks that you may
eventually have to deal with.</simpara>
<section xml:id="_plumbing_porcelain">
<title>Plumbing and Porcelain</title>
<simpara>This book covers how to use Git with 30 or so subcommands such as <literal>checkout</literal>, <literal>branch</literal>, <literal>remote</literal>, and so on.
But because Git was initially a toolkit for a VCS rather than a full user-friendly VCS, it has a
bunch of subcommands that do low-level work and were designed to be chained together UNIX-style or
called from scripts. These low-level commands are generally referred to as <literal>plumbing</literal> commands,
and the higher-level, more user-friendly commands are called <literal>porcelain</literal> commands.</simpara>
<simpara>The book&#8217;s first nine chapters deal almost exclusively with porcelain commands.
But in this chapter, we mostly cover plumbing commands because they give you access to the inner workings of Git and help demonstrate how and why Git does what it does.
Many of these commands aren&#8217;t meant to be used manually on the command line, but rather to be used as building blocks for new tools and custom scripts.</simpara>
<simpara>When you run <literal>git init</literal>, Git creates the <literal>.git</literal> directory, which is where almost everything that Git
manages is located. To back up or clone your repository, copying this single directory is all you need to do.
This entire chapter basically deals with the stuff in this directory.
Here&#8217;s what it looks like.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cd .git
$ ls -F1
HEAD
config*
description
hooks/
info/
objects/
refs/</programlisting>
<simpara>You may see some other files, but this is what <literal>git init</literal> creates.
The <literal>description</literal> file is only used by the GitWeb program, so don&#8217;t worry about it.
The <literal>config</literal> file contains your project-specific configuration options, and the <literal>info</literal> directory keeps
a global exclude file <indexterm>
<primary>excludes</primary>
</indexterm> for filename patterns to ignore that you don&#8217;t want to track
in a <literal>.gitignore</literal> file. The <literal>hooks</literal> directory contains your client- or server-side hook scripts,
which are discussed in detail in <xref linkend="_git_hooks"/>.</simpara>
<simpara>This leaves four important entries&#8201;&#8212;&#8201;the <literal>HEAD</literal> and (yet to be created) <literal>index</literal> files, and the <literal>objects</literal> and
<literal>refs</literal> directories. These are the core parts of Git.
The <literal>objects</literal> directory stores all the content in your repository, the <literal>refs</literal> directory stores pointers
to commits in the <literal>objects</literal> directory (branches, tags, remotes, and more), the <literal>HEAD</literal> file points to the
branch you currently have checked out, and the <literal>index</literal> file is where Git stores your staging area information.
We now look at each of these sections in detail to see how Git operates.</simpara>
</section>
<section xml:id="_objects">
<title>Git Objects</title>
<simpara>Git is a content-addressable filesystem.
Great. What does that mean?
It means that at its core, Git is a simple key-value data store.
You can insert any kind of content into it, and Git gives back a key to use to retrieve the content later.
To demonstrate, run the plumbing command <literal>git hash-object</literal>, which takes some data, stores it in your Git
repository, and gives back the key to the data. First, initialize a new Git repository and verify that there&#8217;s
nothing in the <literal>objects</literal> directory:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git init test
Initialized empty Git repository in /tmp/test/.git/
$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f</programlisting>
<simpara>Git has initialized the <literal>objects</literal> directory and created <literal>pack</literal> and <literal>info</literal> subdirectories in it, but there
are no regular files. Now, store some text in your Git repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4</programlisting>
<simpara>The <literal>-w</literal> flag tells <literal>git hash-object</literal> to store an object. Otherwise, the command simply shows what the key would be.
<literal>--stdin</literal> says to read the content from stdin. Without this, <literal>git hash-object</literal> expects a file path
as the last command line parameter. The output is a 40-character SHA-1 hash.
This is a hash of the content you&#8217;re storing, plus a header, which you learn about in a bit.
Now you see how Git has stored your data.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</programlisting>
<simpara>You now see a file in the <literal>objects</literal> directory.
This is how Git stores the content initially&#8201;&#8212;&#8201;as a single file for each piece of content, named with the SHA-1
hash of the content and a header. The subdirectory containing the object has the first 2 characters of the SHA-1
hash as its name, and the filename is the remaining 38 characters.</simpara>
<simpara>You can pull the content back out by running <literal>git cat-file</literal>.
This command is sort of a Swiss army knife for inspecting Git objects.
Passing <literal>-p</literal> instructs <literal>git cat-file</literal> to figure out the type of content and display it nicely.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content</programlisting>
<simpara>Now, you can add content to Git and pull it back out again.
For example, you can do some simple version control on a file.
First, create a new file and save its content in the repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo 'version 1' &gt; test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30</programlisting>
<simpara>Then, write some new content to the file, and save it again:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo 'version 2' &gt; test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</programlisting>
<simpara>Your repository contains three files.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</programlisting>
<simpara>You can revert the file back to the first version of <literal>test.txt</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt
$ cat test.txt
version 1</programlisting>
<simpara>Or the second version.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt
$ cat test.txt
version 2</programlisting>
<simpara>But remembering the SHA-1 hash for each version of your file isn&#8217;t practical. Plus, you aren&#8217;t storing the
filename&#8201;&#8212;&#8201;just the content. What you&#8217;re storing is an object type called a blob, which is similar to a file.
Git can tell you the object type of any object, given its SHA-1 hash, when you run <literal>git cat-file -t</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob</programlisting>
<section xml:id="_tree_objects">
<title>Tree Objects</title>
<simpara>The next object type we look at is a tree, which solves the problem of storing a filename. It also stores a
group of files together. Git stores content in a manner similar to a simplified UNIX filesystem.
All content is stored as trees and blobs, with trees corresponding to UNIX directories and blobs
corresponding to files. A single tree object contains one or more entries, each containing the SHA-1 hash
of a blob or subtree with an associated mode, type, and filename. For example, the most recent tree in a project
may look something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</programlisting>
<simpara>The <literal>master^{tree}</literal> syntax specifies the tree object that&#8217;s pointed to by the last commit on <literal>master</literal>.
Notice that the <literal>lib</literal> subdirectory isn&#8217;t a blob but a pointer to another tree.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</programlisting>
<simpara>Conceptually, the data that Git is storing is something like</simpara>
<figure>
<title>Simple version of the Git data model.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/data-model-1.png"/>
</imageobject>
<textobject><phrase>Simple version of the Git data model.</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can easily create your own tree. Git normally creates a tree by taking the state of your staging
area and writing a series of tree objects that represent to the state. So, to create a tree object,
first stage some files. To create a staging area containing a single entry&#8201;&#8212;&#8201;the first version of
your <literal>test.txt</literal> file&#8201;&#8212;&#8201;run the plumbing command <literal>git update-index</literal>. Run this command to artificially
add the earlier version of the <literal>test.txt</literal> file to the staging area. You must pass it the <literal>--add</literal> flag
because the file doesn&#8217;t yet exist in your staging area (you don&#8217;t even have a staging area set up yet),
and <literal>--cacheinfo</literal> because the file you&#8217;re adding isn&#8217;t in your directory but is in your repository.
Then, specify the mode, SHA-1 hash, and filename.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt</programlisting>
<simpara>In this case, you&#8217;re specifying a mode of <literal>100644</literal>, which means the file you&#8217;re adding is a normal file.
Other options are <literal>100755</literal>, which means it&#8217;s an executable file, and <literal>120000</literal>, which specifies a symbolic link.
The mode is taken from normal UNIX modes but is much less flexible. These three modes are the only ones
that are valid for blobs representing files (although other modes are used for directories and submodules).</simpara>
<simpara>Now, run <literal>git write-tree</literal> to write the staging area out as a tree object.
No <literal>-w</literal> flag is needed&#8201;&#8212;&#8201;running <literal>git write-tree</literal> automatically creates a tree object from the state of
the staging area if that tree doesn&#8217;t exist yet.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</programlisting>
<simpara>You can also verify that this is a tree object.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree</programlisting>
<simpara>You now create a new tree with the second version of <literal>test.txt</literal> and a new file as well.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo 'new file' &gt; new.txt
$ git update-index --cacheinfo 100644 \
  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
$ git update-index test.txt
$ git update-index --add new.txt</programlisting>
<simpara>Your staging area now has the new version of <literal>test.txt</literal> as well as the new file <literal>new.txt</literal>.
Write out that tree (recording the state of the staging area to a tree object) and see how it looks.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</programlisting>
<simpara>Notice that this tree has both blob entries and also that the SHA-1 hash of <literal>test.txt</literal> is the <literal>version 2</literal>
SHA-1 hash (<literal>1f7a7a</literal>). Just for fun, add the first tree as a subdirectory into this one.
You can put trees into your staging area by running <literal>git read-tree</literal>.
In this case, you can put an existing tree into your staging area as a subtree by adding
the <literal>--prefix</literal> flag to <literal>git read-tree</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</programlisting>
<simpara>If you created a working directory from the new tree you just wrote, you&#8217;d get the two files in the top level
of the working directory and a subdirectory named <literal>bak</literal> that contains the first version of the <literal>test.txt</literal> file.
You can think of the repository as looking like</simpara>
<figure>
<title>The content structure of your current Git data.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/data-model-2.png"/>
</imageobject>
<textobject><phrase>The content structure of your current Git data.</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_git_commit_objects">
<title>Commit Objects</title>
<simpara>You have three trees that specify the different snapshots of your project that you want to track,
but the earlier problem remains. You must remember all three SHA-1 hashes in order to retrieve the snapshots.
You also don&#8217;t have any information about who saved the snapshots, when they were saved, or why they were saved.
This is the information that the commit object stores.</simpara>
<simpara>To create a commit object, run <literal>git commit-tree</literal> and specify a single tree SHA-1 hash and which commit objects,
if any, directly preceded it. Start with the first tree you wrote.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo 'first commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d</programlisting>
<simpara>You get a different SHA-1 hash because the creation time and author are different in your commit.</simpara>
<simpara>Now look at your new commit object by running <literal>git cat-file</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700

first commit</programlisting>
<simpara>The format for a commit object is simple. It specifies the top-level tree for the snapshot of the project
at that point, the author/committer information (which uses your <literal>user.name</literal> and <literal>user.email</literal> configuration
settings and a timestamp), a blank line, and then the commit message.</simpara>
<simpara>Next, write the other two commit objects, each referencing the commit that came directly before it.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9</programlisting>
<simpara>Each of the three commit objects points to one of the three snapshot trees you created.
Oddly enough, you have a real Git history now that you can view by running <literal>git log</literal>, if you run it on the
last commit SHA-1 hash.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

	third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:14:29 2009 -0700

	second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)</programlisting>
<simpara>Amazing.
You&#8217;ve just performed the low-level operations to build a Git history without using any of the porcelain commands.
This is essentially what Git does when you run <literal>git add</literal> and <literal>git commit</literal>. It stores blobs for the files
that have changed, updates the staging area, writes out trees, and writes commit objects that reference
the top-level trees and the commits that came immediately before them. These three main Git objects&#8201;&#8212;&#8201;the blob,
the tree, and the commit&#8201;&#8212;&#8201;are initially stored as separate files in the <literal>.git/objects</literal> directory.
Here are all the objects in the example directory now, commented with what they store.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</programlisting>
<simpara>If you follow all the internal pointers, you get an object graph that looks something like</simpara>
<figure>
<title>All the reachable objects in your Git directory.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/data-model-3.png"/>
</imageobject>
<textobject><phrase>All the reachable objects in your Git directory.</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_object_storage">
<title>Object Storage</title>
<simpara>We mentioned earlier that a header is stored with the content. Let&#8217;s take a minute to look at how Git
stores its objects. You see how to store a blob object&#8201;&#8212;&#8201;in this case, the string
<literal>what is up, doc?</literal>&#8201;&#8212;&#8201;interactively in the Ruby scripting language.</simpara>
<simpara>Start interactive Ruby mode by running <literal>irb</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ irb
&gt;&gt; content = "what is up, doc?"
=&gt; "what is up, doc?"</programlisting>
<simpara>Git constructs a header that starts with the type of the object, in this case a blob.
Then, it adds a space followed by the size of the content and finally a null byte:</simpara>
<programlisting language="console" linenumbering="unnumbered">&gt;&gt; header = "blob #{content.length}\0"
=&gt; "blob 16\u0000"</programlisting>
<simpara>Git concatenates the header and the original content, and then calculates the SHA-1 hash of that new content.
You can calculate the SHA-1 hash of a string in Ruby by including the SHA1 digest library with the <literal>require</literal>
command and then calling <literal>Digest::SHA1.hexdigest()</literal> with the string to hash.</simpara>
<programlisting language="console" linenumbering="unnumbered">&gt;&gt; store = header + content
=&gt; "blob 16\u0000what is up, doc?"
&gt;&gt; require 'digest/sha1'
=&gt; true
&gt;&gt; sha1 = Digest::SHA1.hexdigest(store)
=&gt; "bd9dbf5aae1a3862dd1526723246b20206e5fc37"</programlisting>
<simpara>Let&#8217;s compare that to the output of <literal>git hash-object</literal>.
Here we run <literal>echo -n</literal> to prevent adding a newline to the input.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo -n "what is up, doc?" | git hash-object --stdin
bd9dbf5aae1a3862dd1526723246b20206e5fc37</programlisting>
<simpara>Git compresses the new content with zlib, which you can do in Ruby with the zlib library.
First, require the library and then run <literal>Zlib::Deflate.deflate()</literal> on the content.</simpara>
<programlisting language="console" linenumbering="unnumbered">&gt;&gt; require 'zlib'
=&gt; true
&gt;&gt; zlib_content = Zlib::Deflate.deflate(store)
=&gt; "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"</programlisting>
<simpara>Finally, write your zlib-deflated content to an object.
Determine the path of the object you want to write (the first two characters of the SHA-1 hash
being the subdirectory name, and the last 38 characters being the filename within that directory).
In Ruby, you can use the <literal>FileUtils.mkdir_p()</literal> function to create the subdirectory if it doesn&#8217;t exist.
Then, open the file with <literal>File.open()</literal> and write the previously zlib-compressed content to the file
with a <literal>write()</literal> call on the resulting file handle.</simpara>
<programlisting language="console" linenumbering="unnumbered">&gt;&gt; path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=&gt; ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
&gt;&gt; require 'fileutils'
=&gt; true
&gt;&gt; FileUtils.mkdir_p(File.dirname(path))
=&gt; ".git/objects/bd"
&gt;&gt; File.open(path, 'w') { |f| f.write zlib_content }
=&gt; 32</programlisting>
<simpara>Let&#8217;s check the content of the object by running <literal>git cat-file</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">---
$ git cat-file -p bd9dbf5aae1a3862dd1526723246b20206e5fc37
what is up, doc?
---</programlisting>
<simpara>That&#8217;s it&#8201;&#8212;&#8201;you&#8217;ve created a valid Git blob object.
All Git objects are stored the same way, just with different types. Instead of <literal>blob</literal>, the header
begins with <literal>commit</literal> or <literal>tree</literal>. Also, although the blob content can be nearly anything, the commit
and tree content are very specifically formatted.</simpara>
</section>
</section>
<section xml:id="_git_refs">
<title>Git References</title>
<simpara>If you were interested in seeing the history of your repository reachable from a specific commit, say, <literal>1a410e</literal>,
you could run something like <literal>git log 1a410e</literal>, but you would have to remember that <literal>1a410e</literal> is the
commit you want to use as the starting point. Instead, it would be easier if there were a file in which
you could store that SHA-1 value, using a simple filename you could use instead of the raw SHA-1 value.</simpara>
<simpara>In Git, these are called <literal>references</literal> or <literal>refs</literal>. You can find the files that contain the SHA-1 hashes
in the <literal>.git/refs</literal> directory. In the current project, this directory contains no files, but it&#8217;s organized
in a simple structure.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f</programlisting>
<simpara>To create a new reference that helps you remember where your latest commit is, you can technically run
something as simple as</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo 1a410efbd13591db07496601ebc7a059dd55cfe9 &gt; .git/refs/heads/master</programlisting>
<simpara>Now, you can use the <literal>master</literal> reference you just created instead of the SHA-1 hash in your Git commands.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty=oneline master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</programlisting>
<simpara>You aren&#8217;t encouraged to directly edit the reference files.
Instead, Git provides the <literal>git update-ref</literal> command to update a reference.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</programlisting>
<simpara>That&#8217;s basically what a branch in Git is&#8201;&#8212;&#8201;a simple reference to the head of a line of work.
This reference is just an SHA-1 hash. To create a branch called <literal>test</literal> back at the second commit, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git update-ref refs/heads/test cac0ca</programlisting>
<simpara>Your branch contains only work starting from that commit back to the first commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</programlisting>
<simpara>Now, your Git repository conceptually looks something like</simpara>
<figure>
<title>Git directory objects with branch head references included.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/data-model-4.png"/>
</imageobject>
<textobject><phrase>Git directory objects with branch head references included.</phrase></textobject>
</mediaobject>
</figure>
<simpara>When you run commands like <literal>git branch (branchname)</literal>, Git basically runs <literal>git update-ref</literal> to add the SHA-1
hash of the last commit of the branch you&#8217;re on into whatever new reference you want to create.</simpara>
<section xml:id="_the_head">
<title>The HEAD</title>
<simpara>The question now is, when you run <literal>git branch (branchname)</literal>, how does Git know the SHA-1 hash of the last commit?
The answer is the <literal>HEAD</literal> file.</simpara>
<simpara>The <literal>HEAD</literal> file is a symbolic reference to the branch you&#8217;re currently on.
By symbolic reference, we mean that unlike a normal reference, it doesn’t contain an SHA-1 hash
but rather the name of another reference. If you look at the file, you see something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat .git/HEAD
ref: refs/heads/master</programlisting>
<simpara>If you run <literal>git checkout test</literal>, Git updates the file to look like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat .git/HEAD
ref: refs/heads/test</programlisting>
<simpara>When you run <literal>git commit</literal>, Git creates the commit object, specifying the parent of that commit object to be whatever
SHA-1 hash the reference in <literal>HEAD</literal> points to.</simpara>
<simpara>You can also manually edit this file, but again a safe command exists&#8201;&#8212;&#8201;<literal>git symbolic-ref</literal>.
You can output the value of <literal>HEAD</literal> by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git symbolic-ref HEAD
refs/heads/master</programlisting>
<simpara>You can also set the value of <literal>HEAD</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test</programlisting>
<simpara>You can&#8217;t set a symbolic reference using any other string format.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/</programlisting>
</section>
<section xml:id="_tags">
<title>Tags</title>
<simpara>We just finished discussing Git&#8217;s three main object types, but there&#8217;s a fourth.
The tag object is very much like a commit object&#8201;&#8212;&#8201;it contains the name of the person creating the tag,
a date, a message, and a reference. The main difference is that a tag object generally points to a commit
rather than a tree. It&#8217;s like a branch reference, but it never moves. It always points to the same commit but
gives it a friendlier name.</simpara>
<simpara>As discussed in <xref linkend="_git_basics_chapter"/>, there are two types of tags&#8201;&#8212;&#8201;annotated and lightweight.
You can make a lightweight tag by running something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</programlisting>
<simpara>That&#8217;s all a lightweight tag is&#8201;&#8212;&#8201;a reference that never moves. An annotated tag is more complex, however.
If you create an annotated tag, Git creates a tag object and then writes a reference to point to it
rather than directly to the commit. You see this by creating an annotated tag (<literal>-a</literal> specifies that it&#8217;s
an annotated tag).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'</programlisting>
<simpara>Here&#8217;s the SHA-1 hash of the created object.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2</programlisting>
<simpara>Now, run <literal>git cat-file</literal> on that SHA-1 hash.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

test tag</programlisting>
<simpara>Notice that the object entry points to the commit SHA-1 hash that you tagged.
Also notice that it doesn&#8217;t need to point to a commit&#8201;&#8212;&#8201;you can tag any Git object.
In the Git source code, for example, the maintainer has added his GPG public key as a blob object and then tagged it.
You can view the public key by running this in a clone of the Git repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file blob junio-gpg-pub</programlisting>
<simpara>The Linux kernel repository also has a non-commit-pointing tag object&#8201;&#8212;&#8201;the first tag created points
to the initial tree of the import of the source code.</simpara>
</section>
<section xml:id="_remotes">
<title>Remotes</title>
<simpara>The third type of reference is a remote reference.
If you add a remote and push to it, Git stores the commit you last pushed to each branch in that remote
in the <literal>refs/remotes</literal> directory. For instance, you can add a remote called <literal>origin</literal> and push your <literal>master</literal> to it.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -&gt; master</programlisting>
<simpara>Then, you can see what <literal>master</literal> on the <literal>origin</literal> remote was the last time you communicated with the
remote server by looking at the <literal>refs/remotes/origin/master</literal> file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949</programlisting>
<simpara>Remote references differ from branches (<literal>refs/heads</literal> references) mainly in that they&#8217;re considered read-only.
You can run <literal>git checkout</literal> to one, but Git doesn&#8217;t point <literal>HEAD</literal> at one, so you never update it by running <literal>git commit</literal>.
Git manages them as bookmarks to the last known state of where those branches were on those servers.</simpara>
</section>
</section>
<section xml:id="_packfiles">
<title>Packfiles</title>
<simpara>Let&#8217;s go back to the objects directory in your test Git repository.
At this point, you have 11 objects&#8201;&#8212;&#8201;4 blobs, 3 trees, 3 commits, and 1 tag.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</programlisting>
<simpara>Git compresses the content of these files with zlib, and you&#8217;re not storing much, so all these
files collectively take up only 925 bytes. Adding some larger content to the repository demonstrates an
interesting feature of Git so let&#8217;s add the <literal>repo.rb</literal> file from the Grit library&#8201;&#8212;&#8201;about 22K.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ curl https://raw.githubusercontent.com/mojombo/grit/master/lib/grit/repo.rb &gt; repo.rb
$ git checkout master
$ git add repo.rb
$ git commit -m 'added repo.rb'
[master 484a592] added repo.rb
 3 files changed, 709 insertions(+), 2 deletions(-)
 delete mode 100644 bak/test.txt
 create mode 100644 repo.rb
 rewrite test.txt (100%)</programlisting>
<simpara>If you look at the resulting tree, you see the SHA-1 hash <literal>repo.rb</literal> was given when turned into a blob object.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</programlisting>
<simpara>You can then run <literal>git cat-file</literal> to see how big that object is.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -s 033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5
22044</programlisting>
<simpara>Now, modify that file a little, and see what happens.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ echo '# testing' &gt;&gt; repo.rb
$ git commit -am 'modified repo a bit'
[master 2431da6] modified repo.rb a bit
 1 file changed, 1 insertion(+)</programlisting>
<simpara>Check the tree created by that commit, and you see something interesting.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p master^{tree}
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob b042a60ef7dff760008df33cee372b945b6e884e      repo.rb
100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</programlisting>
<simpara>The blob is now a different blob, which means that although you added only a single line to the end of a
400-line file, Git stored that new content as a completely new object.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -s b042a60ef7dff760008df33cee372b945b6e884e
22054</programlisting>
<simpara>You have two nearly identical 22K objects, each compressed to approximately 7K.
Wouldn&#8217;t it be nice if Git could store one of them in full but store the second object only as the delta
between it and the first?</simpara>
<simpara>It turns out that it can. The initial format Git uses to save objects is called the <literal>loose</literal> object format.
However, occasionally Git packs up several of these objects into a single binary file called a <literal>packfile</literal>
in order to save space. Git does this if you have too many loose objects around, if you run <literal>git gc</literal> manually,
or if you push to a remote server. To see what happens, you can manually ask Git to pack up the objects by
running <literal>git gc</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git gc
Counting objects: 18, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (14/14), done.
Writing objects: 100% (18/18), done.
Total 18 (delta 3), reused 0 (delta 0)</programlisting>
<simpara>If you look in your objects directory, you find that most of your objects are gone, and a new pair
of files has appeared.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ find .git/objects -type f
.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
.git/objects/info/packs
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack</programlisting>
<simpara>The objects that remain are the blobs that aren&#8217;t pointed to by any commit&#8201;&#8212;&#8201;in this case, the <literal>what is up, doc?</literal>
example and the <literal>test content</literal> example blobs you created earlier.
Because you never added them to any commits, they&#8217;re considered dangling and aren&#8217;t included in your new packfile.</simpara>
<simpara>The other files are your new packfile and an index. The packfile is a single file containing the content of
all the objects that were removed from your filesystem. The index is a file that contains offsets into that
packfile so you can quickly seek to a specific object. What&#8217;s cool is that although the objects on disk
before you ran <literal>git gc</literal> were collectively about 15K in size, the new packfile is only 7K.
You&#8217;ve cut your disk usage in half by packing your objects.</simpara>
<simpara>How does Git do this?
When Git packs objects, it looks for files that are named and sized similarly, and stores just the deltas from one version of the file to the next.
You can look into the packfile and see what Git did to save space.
The <literal>git verify-pack</literal> plumbing command allows you to see what was packed.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git verify-pack -v .git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.idx
2431da676938450a4d72e260db3bf7b0f587bbc1 commit 223 155 12
69bcdaff5328278ab1c0812ce0e07fa7d26a96d7 commit 214 152 167
80d02664cb23ed55b226516648c7ad5d0a3deb90 commit 214 145 319
43168a18b7613d1281e5560855a83eb8fde3d687 commit 213 146 464
092917823486a802e94d727c820a9024e14a1fc2 commit 214 146 610
702470739ce72005e2edff522fde85d52a65df9b commit 165 118 756
d368d0ac0678cbe6cce505be58126d3526706e54 tag    130 122 874
fe879577cb8cffcdf25441725141e310dd7d239b tree   136 136 996
d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 1132
deef2e1b793907545e50a2ea2ddb5ba6c58c4506 tree   136 136 1178
d982c7cb2c2a972ee391a85da481fc1f9127a01d tree   6 17 1314 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   8 19 1331 1 \
  deef2e1b793907545e50a2ea2ddb5ba6c58c4506
0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 1350
83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 1426
fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 1445
b042a60ef7dff760008df33cee372b945b6e884e blob   22054 5799 1463
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   9 20 7262 1 \
  b042a60ef7dff760008df33cee372b945b6e884e
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 7282
non delta: 15 objects
chain length = 1: 3 objects
.git/objects/pack/pack-978e03944f5c581011e6998cd0e9e30000905586.pack: ok</programlisting>
<simpara>Here, the <literal>033b4</literal> blob, which was the first version of <literal>repo.rb</literal>, is referencing the <literal>b042a</literal> blob,
which was the second version of the file. The third column in the output is the size of the object in the pack,
so you see that <literal>b042a</literal> takes up 22K of the file, but that <literal>033b4</literal> only takes up 9 bytes.
What&#8217;s also interesting is that the second version of the file is the one that&#8217;s stored intact, whereas
the original version is stored as a delta. This is because you&#8217;re most likely to need faster access to the
most recent version of the file.</simpara>
<simpara>The really nice thing about this is that your repository can be repacked at any time.
Git occasionally repacks your repository automatically, always trying to save space, but you can also
manually repack at any time by running <literal>git gc</literal> by hand.</simpara>
</section>
<section xml:id="_refspec">
<title>The Refspec</title>
<simpara>Throughout this book, we&#8217;ve used simple mappings from remote branches to local references, but they can
be more complex. Suppose you add a remote like this.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git remote add origin https://github.com/schacon/simplegit-progit</programlisting>
<simpara>It adds a section to your <literal>.git/config</literal> file, specifying the name of the remote (<literal>origin</literal>), the URL
of the remote repository, and the refspec for fetching.</simpara>
<programlisting language="ini" linenumbering="unnumbered">[remote "origin"]
	url = https://github.com/schacon/simplegit-progit
	fetch = +refs/heads/*:refs/remotes/origin/*</programlisting>
<simpara>The format of the refspec is an optional <literal>+</literal>, followed by <literal>&lt;src&gt;:&lt;dst&gt;</literal>, where <literal>&lt;src&gt;</literal> is the
pattern for references on the remote side and <literal>&lt;dst&gt;</literal> is where those references are written locally.
The <literal>+</literal> tells Git to update the reference even if it isn&#8217;t a fast-forward.</simpara>
<simpara>The default behavior that&#8217;s carried out by <literal>git remote add</literal> is to fetch all the references under <literal>refs/heads/</literal>
on the server and write them to <literal>refs/remotes/origin/</literal> locally. So, if there&#8217;s a <literal>master</literal> on the server,
you can access the log of that branch locally by running</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log origin/master
$ git log remotes/origin/master
$ git log refs/remotes/origin/master</programlisting>
<simpara>They&#8217;re all equivalent, because Git expands each of them to <literal>refs/remotes/origin/master</literal>.</simpara>
<simpara>For Git instead to pull only <literal>master</literal> each time, and not every other branch on the remote server,
change the fetch line to</simpara>
<screen>fetch = +refs/heads/master:refs/remotes/origin/master</screen>
<simpara>This is just the default refspec for <literal>git fetch</literal> for that remote.
To do something one time, specify the refspec on the command line.
To pull <literal>master</literal> on the remote down to <literal>origin/mymaster</literal> locally, run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch origin master:refs/remotes/origin/mymaster</programlisting>
<simpara>You can also specify multiple refspecs.
On the command line, you can pull down several branches.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fetch origin master:refs/remotes/origin/mymaster \
	 topic:refs/remotes/origin/topic
From git@github.com:schacon/simplegit
 ! [rejected]        master     -&gt; origin/mymaster  (non fast forward)
 * [new branch]      topic      -&gt; origin/topic</programlisting>
<simpara>In this case, the <literal>master</literal> pull was rejected because it wasn&#8217;t a fast-forward reference.
You can override that by including the <literal>+</literal> in front of the refspec.</simpara>
<simpara>You can also specify multiple refspecs for fetching in your configuration file.
To always fetch <literal>master</literal> and the experiment branches, add two lines.</simpara>
<programlisting language="ini" linenumbering="unnumbered">[remote "origin"]
	url = https://github.com/schacon/simplegit-progit
	fetch = +refs/heads/master:refs/remotes/origin/master
	fetch = +refs/heads/experiment:refs/remotes/origin/experiment</programlisting>
<simpara>You can&#8217;t use partial globs in the pattern, so this would be invalid.</simpara>
<programlisting language="ini" linenumbering="unnumbered">fetch = +refs/heads/qa*:refs/remotes/origin/qa*</programlisting>
<simpara>However, you can use namespaces (or directories) to accomplish something like that.
If you have a QA team that pushes a series of branches, and you want to get <literal>master</literal> and any of the QA
team&#8217;s branches but nothing else, use a config section like</simpara>
<programlisting language="ini" linenumbering="unnumbered">[remote "origin"]
	url = https://github.com/schacon/simplegit-progit
	fetch = +refs/heads/master:refs/remotes/origin/master
	fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</programlisting>
<simpara>If you have a complex workflow process that has a QA team pushing branches, developers pushing branches,
and integration teams pushing and collaborating on remote branches, you can namespace them easily this way.</simpara>
<section xml:id="_pushing_refspecs">
<title>Pushing Refspecs</title>
<simpara>It&#8217;s nice that you can fetch namespaced references that way, but how does the QA team get their branches into
a <literal>qa/</literal> namespace in the first place? You accomplish that by using refspecs to push.</simpara>
<simpara>If the QA team wants to push their <literal>master</literal> to <literal>qa/master</literal> on the remote server, they run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin master:refs/heads/qa/master</programlisting>
<simpara>If they want Git to do that automatically each time they run <literal>git push origin</literal>, they add a <literal>push</literal> value
to their config file:</simpara>
<programlisting language="ini" linenumbering="unnumbered">[remote "origin"]
	url = https://github.com/schacon/simplegit-progit
	fetch = +refs/heads/*:refs/remotes/origin/*
	push = refs/heads/master:refs/heads/qa/master</programlisting>
<simpara>Again, this causes <literal>git push origin</literal> to push the local <literal>master</literal> to the remote <literal>qa/master</literal> by default.</simpara>
</section>
<section xml:id="_deleting_references">
<title>Deleting References</title>
<simpara>You can also use the refspec to delete references from the remote server by running something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git push origin :topic</programlisting>
<simpara>Because the refspec is <literal>&lt;src&gt;:&lt;dst&gt;</literal>, by leaving off the <literal>&lt;src&gt;</literal> part, this basically says to make <literal>topic</literal>
on the remote empty, which deletes it.</simpara>
</section>
</section>
<section xml:id="_transfer_protocols">
<title>Transfer Protocols</title>
<simpara>Git transfers data between two repositories in two primary ways&#8201;&#8212;&#8201;the <literal>dumb</literal> protocol and the <literal>smart</literal> protocol.
This section covers how these operate.</simpara>
<section xml:id="_the_dumb_protocol">
<title>The Dumb Protocol</title>
<simpara>If you&#8217;re setting up a repository to be served read-only over HTTP, the dumb protocol used to be what you should use.
This protocol is called <literal>dumb</literal> because it requires no Git-specific code on the server during the transfer process.
The fetch process is a series of HTTP <literal>GET</literal> requests, where the client can assume the layout of the Git
repository on the server.</simpara>
<note>
<simpara>The dumb protocol is rarely used these days.
It&#8217;s difficult to secure or make private, so most Git hosts (both cloud-based and on-premises) don&#8217;t use it.
It&#8217;s generally advised to use the smart protocol, which we describe a bit further on.</simpara>
</note>
<simpara>Let&#8217;s follow the <literal>http-fetch</literal> process for the simplegit library.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git clone http://server/simplegit-progit.git</programlisting>
<simpara>The first thing this command does is pull the <literal>info/refs</literal> file.
This file is written by the <literal>update-server-info</literal> command, which is why you need to enable that as a <literal>post-receive</literal>
hook in order for the HTTP transport to work properly.</simpara>
<screen>=&gt; GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</screen>
<simpara>Now you have a list of the remote references and SHA-1 hashes.
Next, you look for what the <literal>HEAD</literal> reference is so you know what to check out when you&#8217;re finished.</simpara>
<screen>=&gt; GET HEAD
ref: refs/heads/master</screen>
<simpara>You need to check out <literal>master</literal> when you&#8217;ve completed the process.
At this point, you&#8217;re ready to start the walking process.
Because your starting point is the <literal>ca82a6</literal> commit object you saw in the <literal>info/refs</literal> file, start by fetching that.</simpara>
<screen>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)</screen>
<simpara>You get an object back. That object is in loose format on the server, and you fetched it using a static HTTP GET
request. You can zlib-uncompress it, strip off the header, and look at the commit content.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the version number</programlisting>
<simpara>Next, you have two more objects to retrieve&#8201;&#8212;&#8201;<literal>cfda3b</literal>, which is the tree object that the commit we just
retrieved points to, and <literal>085bb3</literal>, which is the parent commit.</simpara>
<screen>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)</screen>
<simpara>That gives your next commit object. Grab the tree object.</simpara>
<screen>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)</screen>
<simpara>Oops&#8201;&#8212;&#8201;it looks like that tree object isn&#8217;t in loose format on the server, so you get a 404 response back.
There are a couple of reasons for this. The object could be in an alternate repository, or it could
be in a packfile in this repository. Git checks for any listed alternates first.</simpara>
<screen>=&gt; GET objects/info/http-alternates
(empty file)</screen>
<simpara>If this comes back with a list of alternate URLs, Git checks it for loose files and packfiles. This is a
nice mechanism for projects that are forks of one another to share objects on disk.
However, because no alternates are listed in this case, your object must be in a packfile.
To see what packfiles are available on this server, get the <literal>objects/info/packs</literal> file, which contains a listing
of them (also generated by <literal>update-server-info</literal>):</simpara>
<screen>=&gt; GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</screen>
<simpara>There&#8217;s only one packfile on the server, so your object is obviously in there, but check the index file to make sure.
This is also useful if you have multiple packfiles on the server, so you can see which packfile contains the
object you need.</simpara>
<screen>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)</screen>
<simpara>Now that you have the packfile index, you can see if your object is in it&#8201;&#8212;&#8201;because the index contains the SHA-1
hashes of the objects contained in the packfile and the offsets to those objects.
Your object is there, so go ahead and get the whole packfile.</simpara>
<screen>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)</screen>
<simpara>You have your tree object, so you continue walking your commits.
They&#8217;re all also contained in the packfile you just downloaded, so you don&#8217;t have to make any more requests to
your server. Git checks out a working copy of <literal>master</literal> that was pointed to by the <literal>HEAD</literal> reference you downloaded
at the beginning.</simpara>
</section>
<section xml:id="_the_smart_protocol">
<title>The Smart Protocol</title>
<simpara>The dumb protocol is simple but inefficient, and it can&#8217;t write data from the client to the server.
The smart protocol is a more common method of transferring data, but it requires a process on the server with
knowledge about Git. It can read local data, figure out what the client has and needs, and generate a
custom packfile. There are two sets of processes for transferring data&#8201;&#8212;&#8201;a pair for uploading data and a pair
for downloading data.</simpara>
<section xml:id="_uploading_data">
<title>Uploading Data</title>
<simpara><indexterm>
<primary>git commands</primary><secondary>send-pack</secondary>
</indexterm>
<indexterm>
<primary>send-pack</primary>
</indexterm><indexterm>
<primary>git commands</primary><secondary>receive-pack</secondary>
</indexterm>
<indexterm>
<primary>receive-pack</primary>
</indexterm>
To upload data to a server, Git uses the <literal>send-pack</literal> and <literal>receive-pack</literal> processes.
The <literal>send-pack</literal> process runs on the client and connects to a <literal>receive-pack</literal> process on the server.</simpara>
<section xml:id="_ssh">
<title>SSH</title>
<simpara>For example, say you run <literal>git push origin master</literal>, and <literal>origin</literal> is defined as a URL that uses the SSH protocol.
Git fires up the <literal>send-pack</literal> process, which initiates a connection over SSH to your server.
It tries to run a command on the server via SSH that looks something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ ssh -x git@server "git-receive-pack 'simplegit-progit.git'"
00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master□report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1+github-607-gfba4028 delete-refs
003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic
0000</programlisting>
<simpara><literal>git-receive-pack</literal> immediately responds with one line for each reference it currently has&#8201;&#8212;&#8201;in this case,
just <literal>master</literal> and its SHA-1 hash. The first line also has a list of the server&#8217;s capabilities (here
<literal>report-status</literal>, <literal>delete-refs</literal>, and some others, including the client identifier).</simpara>
<simpara>Each line starts with a 4-character hex value specifying the length of the rest of the line.
Your first line starts with 00a5, which is hexadecimal for 165, meaning that 165 bytes remain on that line.
The next line is 0000, meaning the server is done with its references listing.</simpara>
<simpara>Now that it knows the server&#8217;s state, <literal>send-pack</literal> determines what commits it has that the server doesn&#8217;t have.
For each reference that this push updates, <literal>send-pack</literal> tells <literal>receive-pack</literal> that information.
For instance, if you&#8217;re updating <literal>master</literal> and adding an <literal>experiment</literal> branch, the <literal>send-pack</literal> response
may look something like</simpara>
<screen>0085ca82a6dff817ec66f44342007202690a93763949  15027957951b64cf874c3557a0f3547bd83b3ff6 \
	refs/heads/master report-status
00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \
	refs/heads/experiment
0000</screen>
<simpara>Git sends a line for each reference you&#8217;re updating with the line&#8217;s length, the old SHA-1 hash, the new SHA-1 hash,
and the reference that&#8217;s being updated. The first line also has the client&#8217;s capabilities.
The SHA-1 hash of all '0&#8217;s means that nothing was there before&#8201;&#8212;&#8201;because you&#8217;re adding the experiment reference.
If you were deleting a reference, you&#8217;d see the opposite&#8201;&#8212;&#8201;all '0&#8217;s on the right side.</simpara>
<simpara>Next, the client sends a packfile of all the objects the server doesn&#8217;t have yet.
Finally, the server responds with a success (or failure) indication:</simpara>
<screen>000Aunpack ok</screen>
</section>
<section xml:id="_http_s">
<title>HTTP(S)</title>
<simpara>This process is mostly the same over HTTP(S), though the handshaking is a bit different.
The connection is initiated with this request.</simpara>
<screen>=&gt; GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
00ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master□report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000</screen>
<simpara>That&#8217;s the end of the first client-server exchange.
The client then makes another request, this time a <literal>POST</literal>, with the data that <literal>send-pack</literal> provides.</simpara>
<screen>=&gt; POST http://server/simplegit-progit.git/git-receive-pack</screen>
<simpara>The <literal>POST</literal> request includes the <literal>send-pack</literal> output and the packfile as its payload.
The server then indicates success or failure with its HTTP(S) response.</simpara>
</section>
</section>
<section xml:id="_downloading_data">
<title>Downloading Data</title>
<simpara><indexterm>
<primary>git commands</primary><secondary>fetch-pack</secondary>
</indexterm>
<indexterm>
<primary>fetch-pack</primary>
</indexterm><indexterm>
<primary>git commands</primary><secondary>upload-pack</secondary>
</indexterm>
<indexterm>
<primary>upload-pack</primary>
</indexterm>
When you download data, the <literal>fetch-pack</literal> and <literal>upload-pack</literal> processes do the work.
The client initiates a <literal>fetch-pack</literal> process that connects to an <literal>upload-pack</literal> process on the server to
negotiate what data are transferred.</simpara>
<section xml:id="_ssh_2">
<title>SSH</title>
<simpara>If you&#8217;re doing the fetch over SSH, <literal>fetch-pack</literal> runs something like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ ssh -x git@server "git-upload-pack 'simplegit-progit.git'"</programlisting>
<simpara>After <literal>fetch-pack</literal> connects, <literal>upload-pack</literal> sends back something like</simpara>
<screen>00dfca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000</screen>
<simpara>This is very similar to what <literal>receive-pack</literal> responds with, but the capabilities are different.
In addition, it sends back what <literal>HEAD</literal> points to (<literal>symref=HEAD:refs/heads/master</literal>) so the client knows what
to check out if this is a clone.</simpara>
<simpara>At this point, the <literal>fetch-pack</literal> process looks at the objects it has and responds with the objects it needs
by sending <literal>want</literal> and then the SHA-1 hash of what it wants. It sends all the objects it already has with <literal>have</literal> and
then the SHA-1 hash. At the end of this list, it writes <literal>done</literal> to initiate the <literal>upload-pack</literal> process to
begin sending the packfile of the data it needs:</simpara>
<screen>003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0009done
0000</screen>
</section>
<section xml:id="_http_s_2">
<title>HTTP(S)</title>
<simpara>The handshake for a fetch operation takes two HTTP(S) requests.
The first is a <literal>GET</literal> to the same endpoint used in the dumb protocol.</simpara>
<screen>=&gt; GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
00e7ca82a6dff817ec66f44342007202690a93763949 HEAD□multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed no-done symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000</screen>
<simpara>This is very similar to running <literal>git-upload-pack</literal> over an SSH connection, but the second exchange is
performed as a separate request.</simpara>
<screen>=&gt; POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000</screen>
<simpara>Again, this is the same format as above.
The response to this request indicates success or failure, and includes the packfile.</simpara>
</section>
</section>
</section>
<section xml:id="_protocols_summary">
<title>Protocols Summary</title>
<simpara>This section contains a very basic overview of the transfer protocols.
The protocol includes many other features, such as <literal>multi_ack</literal> or <literal>side-band</literal> capabilities, but covering
them is outside the scope of this book. We&#8217;ve tried to give a sense of the general back-and-forth between
client and server. If you need more knowledge than this, take a look at the Git source code.</simpara>
</section>
</section>
<section xml:id="_maintenance_and_data_recovery">
<title>Maintenance and Data Recovery</title>
<simpara>Occasionally, you may have to make a repository more compact, clean up an imported repository, or recover lost work.
This section covers some of these scenarios.</simpara>
<section xml:id="_git_gc">
<title>Maintenance</title>
<simpara>Git automatically runs a command called <literal>auto gc</literal> from time to time.
Most of the time, this command does nothing.
However, if there are too many loose objects (objects not in a packfile) or too many packfiles, Git launches
a full-fledged <literal>git gc</literal> command. The <literal>gc</literal> stands for garbage collect, and the command does a number of things.
It gathers up all the loose objects and places them in packfiles, it consolidates packfiles into one big packfile,
and it removes objects that aren&#8217;t reachable from any commit that are at least a few months old.</simpara>
<simpara>You can run <literal>auto gc</literal> manually.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git gc --auto</programlisting>
<simpara>Again, this generally does nothing.
You must have around 7,000 loose objects or more than 50 packfiles for Git to fire up a real <literal>gc</literal> command.
You can modify these limits with the <literal>gc.auto</literal> and <literal>gc.autopacklimit</literal> config settings, respectively.</simpara>
<simpara>The other thing <literal>gc</literal> does is pack up your references into a single file.
Suppose your repository contains the following branches and tags:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1</programlisting>
<simpara>After running <literal>git gc</literal>, files are no longer in the <literal>refs</literal> directory.
Git moves them for the sake of efficiency into a file named <literal>.git/packed-refs</literal> that looks like</simpara>
<programlisting language="console" linenumbering="unnumbered">$ cat .git/packed-refs
# pack-refs with: peeled fully-peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9</programlisting>
<simpara>If you update a reference, Git doesn&#8217;t modify this file but instead writes a new file to <literal>refs/heads</literal>.
To get the appropriate SHA-1 hash for a given reference, Git checks for that reference in the <literal>refs</literal> directory
and then checks the <literal>packed-refs</literal> file as a fallback. However, if you can&#8217;t find a reference in the <literal>refs</literal> directory,
it&#8217;s probably in your <literal>packed-refs</literal> file.</simpara>
<simpara>Notice the last line of the file, which begins with <literal>^</literal>.
This means the tag directly above is an annotated tag and that line is the commit that the annotated tag points to.</simpara>
</section>
<section xml:id="_data_recovery">
<title>Data Recovery</title>
<simpara>At some point in your Git journey, you may accidentally lose a commit.
Generally, this happens because you force-delete a branch that had work on it, and it turns out you wanted
the branch after all. Or you hard-reset a branch, thus abandoning commits that you still needed. When this happens,
how can you get your commits back?</simpara>
<simpara>Here&#8217;s an example that hard-resets <literal>master</literal> in your test repository to an older commit and then recovers the lost
commits. First, let&#8217;s review where your repository is at this point.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</programlisting>
<simpara>Now, move <literal>master</literal> back to the middle commit.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef third commit
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</programlisting>
<simpara>You&#8217;ve effectively lost the top two commits&#8201;&#8212;&#8201;you have no branch from which those commits are reachable.
You need to find the latest commit SHA-1 hash and then add a branch that points to it.
The trick is finding that latest commit SHA-1 hash.</simpara>
<simpara>Often, the quickest way is to use a tool called <literal>git reflog</literal>.
As you&#8217;re working, Git silently records what your <literal>HEAD</literal> is every time you change it.
Each time you commit or change branches, the reflog is updated.
The reflog is also updated by <literal>git update-ref</literal>, which is another reason to use it instead of just writing the
SHA-1 hash to your ref files, as we covered in <xref linkend="_git_refs"/>.
You can see where you&#8217;ve been at any time by running <literal>git reflog</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: modified repo.rb a bit
484a592 HEAD@{2}: commit: added repo.rb</programlisting>
<simpara>Here we see the two commits that we&#8217;ve had checked out. However there&#8217;s not much information here.
To see the same information in a much more useful way, run <literal>git log -g</literal>, which shows normal log output for your reflog.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:22:37 2009 -0700

		third commit

commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

       modified repo.rb a bit</programlisting>
<simpara>It looks like the bottom commit is the one you lost, so you can recover it by creating a new branch at that commit.
For example, you can start a branch named <literal>recover-branch</literal> at that commit (<literal>ab1afef</literal>).</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch recover-branch ab1afef
$ git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</programlisting>
<simpara>Cool&#8201;&#8212;&#8201;now you have a branch named <literal>recover-branch</literal> that&#8217;s where <literal>master</literal> used to be, making the
first two commits reachable again. Next, suppose your loss was for some reason not in the reflog.
You can simulate that by removing <literal>recover-branch</literal> and deleting the reflog. Now the first two commits
aren&#8217;t reachable by anything.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git branch -D recover-branch
$ rm -Rf .git/logs/</programlisting>
<simpara>Because the reflog data is kept in the <literal>.git/logs/</literal> directory, you effectively have no reflog.
How can you recover that commit at this point?
One way is to run <literal>git fsck</literal>, which checks your repository for integrity.
If you run it with the <literal>--full</literal> flag, it shows all objects that aren&#8217;t pointed to by another object.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (18/18), done.
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</programlisting>
<simpara>In this case, you see your missing commit after the string <literal>dangling commit</literal>.
Recover it the same way, by adding a branch that points to that SHA-1 hash.</simpara>
</section>
<section xml:id="_removing_objects">
<title>Removing Objects</title>
<simpara>There are a lot of great things about Git, but one feature that can cause issues is the fact
that <literal>git clone</literal> downloads the entire history of the project, including every version of every file.
This is fine if the whole thing is source code, because Git is highly optimized to compress that kind
of data efficiently. However, if someone at any point in the history of your project added a single huge file,
every clone for all time is forced to download that huge file, even if it&#8217;s removed from the project in the
very next commit. Because it&#8217;s reachable from the history, it is always there.</simpara>
<simpara>This can be a huge problem when you&#8217;re transferring Subversion or Perforce repositories into Git.
Because you don&#8217;t download the whole history when using those VCSs, this type of addition carries few consequences.
If you did an import from another VCS or otherwise find that your repository is much larger than it should be,
here&#8217;s how you can find and remove large objects.</simpara>
<simpara><emphasis role="strong">Be warned: this technique is destructive to your commit history.</emphasis>
It rewrites every commit object since the earliest tree in the repository to remove a large file reference.
If you do this immediately after an import, before anyone has started to base work on the commit, you&#8217;re fine.
Otherwise, you have to notify all contributors that they must rebase their work onto your new commits.</simpara>
<simpara>To demonstrate, add a large file into your test repository, remove it in the next commit, find it,
and remove it permanently from the repository. First, add a large object to your repository.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz &gt; git.tgz
$ git add git.tgz
$ git commit -m 'add git tarball'
[master 7b30847] add git tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 git.tgz</programlisting>
<simpara>Oops&#8201;&#8212;&#8201;you didn&#8217;t want to add a huge tarball to your project. Better get rid of it.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rm git.tgz
rm 'git.tgz'
$ git commit -m 'oops - removed large tarball'
[master dadf725] oops - removed large tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 git.tgz</programlisting>
<simpara>Now, run <literal>git gc</literal> on your repository to see how much space you&#8217;re using.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git gc
Counting objects: 17, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)</programlisting>
<simpara>Run <literal>git count-objects</literal> to quickly see how much space you&#8217;re using.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git count-objects -v
count: 7
size: 32
in-pack: 17
packs: 1
size-pack: 4868
prune-packable: 0
garbage: 0
size-garbage: 0</programlisting>
<simpara>The <literal>size-pack</literal> entry is the size of your packfiles in kilobytes, so you&#8217;re using almost 5MB.
Before the last commit, you were using closer to 2KB. Clearly, removing the file from the previous commit didn&#8217;t
remove it from your repository. Every time anyone clones this repository, they have to store all 5MB just to
get this tiny project, because you accidentally added a big file. Let&#8217;s get rid of it.</simpara>
<simpara>First you have to find it. In this case, you already know what file it is.
But suppose you didn&#8217;t. How would you identify what file or files were taking up so much space?
If you run <literal>git gc</literal>, all the objects are in a packfile. You can identify the big objects by running
another plumbing command called <literal>git verify-pack</literal> and sorting on the third field in the output, which is file size.
You can also pipe it through <literal>tail</literal> because you&#8217;re only interested in the last few largest files.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git verify-pack -v .git/objects/pack/pack-29…69.idx \
  | sort -k 3 -n \
  | tail -3
dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696
82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438</programlisting>
<simpara>The big object is at the bottom: 5MB.
To find out what file it is, run <literal>git rev-list</literal>, which you saw briefly in <xref linkend="_enforcing_commit_message_format"/>.
If you add <literal>--objects</literal> to <literal>git rev-list</literal>, it lists all the commit SHA-1 hashes and also the blob SHA-1
hashes with the file paths associated with them. Use this command to find your blob&#8217;s name.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git rev-list --objects --all | grep 82c99a3
82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz</programlisting>
<simpara>Now, you need to remove this file from all trees in your past.
You can easily see what commits modified this file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git log --oneline --branches -- git.tgz
dadf725 oops - removed large tarball
7b30847 add git tarball</programlisting>
<simpara>You must rewrite all the commits after <literal>7b30847</literal> to fully remove this file from your Git repository.
To do so, run <literal>git filter-branch</literal>, which you used in <xref linkend="_rewriting_history"/>.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git filter-branch --index-filter \
  'git rm --ignore-unmatch --cached git.tgz' -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref 'refs/heads/master' was rewritten</programlisting>
<simpara>The <literal>--index-filter</literal> flag is similar to the <literal>--tree-filter</literal> flag used in <xref linkend="_rewriting_history"/>,
except that instead of passing a command that modifies files in your working directory, you&#8217;re
modifying your staging area each time.</simpara>
<simpara>Rather than removing a specific file by running something like <literal>rm file</literal>, you have to remove it
by running <literal>git rm --cached</literal>. You must remove it from the staging area, not from your working directory.
The reason to do it this way is speed&#8201;&#8212;&#8201;because Git doesn&#8217;t have to check out each revision before
running your filter, the process can be much, much faster. You can accomplish the same task with <literal>--tree-filter</literal>.
The <literal>--ignore-unmatch</literal> flag to <literal>git rm</literal> tells it to not exit if the pattern you&#8217;re trying to remove isn&#8217;t there.
Finally, tell <literal>git filter-branch</literal> to rewrite your history only starting from the <literal>7b30847</literal> commit,
because you know that&#8217;s where this problem started. Otherwise, it starts from the beginning
and unnecessarily takes longer.</simpara>
<simpara>Your repository no longer contains a reference to that file.
However, your reflog and the new set of refs that Git added when you ran <literal>git filter-branch</literal> under
<literal>.git/refs/original</literal> still do, so you have to remove them and then repack the repository.
You need to get rid of anything that has a pointer to those old commits before you repack.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)</programlisting>
<simpara>Let&#8217;s see how much space you saved.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git count-objects -v
count: 11
size: 4904
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</programlisting>
<simpara>The packed repository size is down to 8KB, which is much better than 5MB.
You see from the size that the big object is still in your loose objects, so it&#8217;s not gone. But it isn&#8217;t
transferred on a push or clone, which is what&#8217;s important.
If you really wanted, you could remove the object completely by running <literal>git prune</literal> with the <literal>--expire</literal> flag:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git prune --expire now
$ git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</programlisting>
</section>
</section>
<section xml:id="_environment_variables">
<title>Environment Variables</title>
<simpara>Git uses a number of environment variables to determine how to behave.
Occasionally, knowing what these are comes in handy to make Git behave the way you want.
This isn&#8217;t an exhaustive list of all the environment variables Git pays attention to, but we cover the most useful.</simpara>
<section xml:id="_global_behavior">
<title>Global Behavior</title>
<simpara><emphasis role="strong"><literal>GIT_EXEC_PATH</literal></emphasis> determines where Git looks for its sub-programs (like <literal>git-commit</literal>, <literal>git-diff</literal>, and others).
  Check the current setting by running <literal>git --exec-path</literal>.</simpara>
<simpara><emphasis role="strong"><literal>HOME</literal></emphasis> isn&#8217;t usually considered customizable (too many other things depend on it), but it&#8217;s where Git looks for the global configuration file.
  For a truly portable Git installation, complete with global configuration, override <literal>HOME</literal> in your shell profile.</simpara>
<simpara><emphasis role="strong"><literal>PREFIX</literal></emphasis> is similar, but for the system-wide configuration.
  Git looks for this file at <literal>$PREFIX/etc/gitconfig</literal>.</simpara>
<simpara><emphasis role="strong"><literal>GIT_CONFIG_NOSYSTEM</literal></emphasis>, if set, disables the use of the system-wide configuration file.
  This is useful if your system configuration is interfering with your commands, but you can&#8217;t change or remove it.</simpara>
<simpara><emphasis role="strong"><literal>GIT_PAGER</literal></emphasis> controls the program used to display multi-page output.
If unset, <literal>PAGER</literal> is used as a fallback.</simpara>
<simpara><emphasis role="strong"><literal>GIT_EDITOR</literal></emphasis> is the editor Git launches when the user needs to edit text (in a commit message, for example).
If unset, <literal>EDITOR</literal> is used.</simpara>
</section>
<section xml:id="_repository_locations">
<title>Repository Locations</title>
<simpara>Git uses several environment variables to determine how it interacts with the current repository.</simpara>
<simpara><emphasis role="strong"><literal>GIT_DIR</literal></emphasis> is the location of the <literal>.git</literal> folder.
If this isn&#8217;t specified, Git walks up the directory tree until it gets to <literal>~</literal> or <literal>/</literal>, looking for a `.git`directory at every level.</simpara>
<simpara><emphasis role="strong"><literal>GIT_CEILING_DIRECTORIES</literal></emphasis> controls how Git searches for a <literal>.git</literal> directory.
If you access directories that are slow to load (such as across a slow network connection), you may want to have Git stop trying sooner than it might otherwise, especially if Git is invoked when constructing your shell prompt.</simpara>
<simpara><emphasis role="strong"><literal>GIT_WORK_TREE</literal></emphasis> is the root of the working directory for a non-bare repository.
If <literal>--git-dir</literal> or <literal>GIT_DIR</literal> is specified but none of <literal>--work-tree</literal>, <literal>GIT_WORK_TREE</literal>, or <literal>core.worktree</literal> is specified, the current working directory is regarded as the top level of the working directory.
If not specified, the parent directory of <literal>$GIT_DIR</literal> is used.</simpara>
<simpara><emphasis role="strong"><literal>GIT_INDEX_FILE</literal></emphasis> is the path to the index file (non-bare repositories only).</simpara>
<simpara><emphasis role="strong"><literal>GIT_OBJECT_DIRECTORY</literal></emphasis> specifies the directory that usually contains <literal>.git/objects</literal>.</simpara>
<simpara><emphasis role="strong"><literal>GIT_ALTERNATE_OBJECT_DIRECTORIES</literal></emphasis> is a colon-separated list (<literal>/dir/one:/dir/two:…</literal>) where Git checks for objects if they aren&#8217;t in <literal>GIT_OBJECT_DIRECTORY</literal>.
If you happen to have a lot of projects with large files with identical content, this can be used to avoid storing too many copies of them.</simpara>
</section>
<section xml:id="_pathspecs">
<title>Pathspecs</title>
<simpara>A <literal>pathspec</literal> refers to how you specify paths to Git, including the use of wildcards.
These are used in <literal>.gitignore</literal> and on the command-line (<literal>git add *.c</literal>).</simpara>
<simpara><emphasis role="strong"><literal>GIT_GLOB_PATHSPECS</literal> and <literal>GIT_NOGLOB_PATHSPECS</literal></emphasis> control the default behavior of wildcards in pathspecs.
If <literal>GIT_GLOB_PATHSPECS</literal> is set to 1, wildcard characters act as wildcards (which is the default), If <literal>GIT_NOGLOB_PATHSPECS</literal> is set to 1, wildcard characters only match themselves, meaning something like <literal>\*.c</literal> would only match a file <emphasis>named</emphasis> <literal>*.c</literal>, rather than any file whose name ends with <literal>.c</literal>.
You can override this by starting the pathspec with <literal>:(glob)</literal> or <literal>:(literal)</literal>, as in <literal>:(glob)*.c</literal>.</simpara>
<simpara><emphasis role="strong"><literal>GIT_LITERAL_PATHSPECS</literal></emphasis> disables both of the above behaviors. There are no wildcard characters, and the override prefixes are disabled as well.</simpara>
<simpara><emphasis role="strong"><literal>GIT_ICASE_PATHSPECS</literal></emphasis> sets all pathspecs to work in a case-insensitive manner.</simpara>
</section>
<section xml:id="_committing">
<title>Committing</title>
<simpara>The final creation of a Git commit object is usually done by <literal>git-commit-tree</literal>, which uses
these environment variables as its primary source of information, falling back to configuration values
only if these aren&#8217;t present.</simpara>
<simpara><emphasis role="strong"><literal>GIT_AUTHOR_NAME</literal></emphasis> is the human-readable name in the <literal>author</literal> field.</simpara>
<simpara><emphasis role="strong"><literal>GIT_AUTHOR_EMAIL</literal></emphasis> is the email for the <literal>author</literal> field.</simpara>
<simpara><emphasis role="strong"><literal>GIT_AUTHOR_DATE</literal></emphasis> is the timestamp for the <literal>author</literal> field.</simpara>
<simpara><emphasis role="strong"><literal>GIT_COMMITTER_NAME</literal></emphasis> sets the human name for the <literal>committer</literal> field.</simpara>
<simpara><emphasis role="strong"><literal>GIT_COMMITTER_EMAIL</literal></emphasis> is the email address for the <literal>committer</literal> field.</simpara>
<simpara><emphasis role="strong"><literal>GIT_COMMITTER_DATE</literal></emphasis> is the timestamp for the <literal>committer</literal> field.</simpara>
<simpara><emphasis role="strong"><literal>EMAIL</literal></emphasis> is the fallback email address in case the <literal>user.email</literal> configuration value isn&#8217;t set.
If <emphasis>this</emphasis> isn&#8217;t set, Git falls back to the system user and host names.</simpara>
</section>
<section xml:id="_networking">
<title>Networking</title>
<simpara>Git uses the <literal>curl</literal> library to do sending and receiving using HTTP, so <emphasis role="strong"><literal>GIT_CURL_VERBOSE</literal></emphasis> tells Git to
output all the messages produced by that library. This is similar to running <literal>curl -v</literal> on the command line.</simpara>
<simpara><emphasis role="strong"><literal>GIT_SSL_NO_VERIFY</literal></emphasis> tells Git to not verify SSL certificates.
This can sometimes be necessary if you&#8217;re using a self-signed certificate to serve Git repositories using HTTPS, or you&#8217;re in the middle of setting up a Git server but haven&#8217;t installed a valid certificate yet.</simpara>
<simpara>If the data rate of an HTTP operation is slower than <emphasis role="strong"><literal>GIT_HTTP_LOW_SPEED_LIMIT</literal></emphasis> bytes per second for longer than <emphasis role="strong"><literal>GIT_HTTP_LOW_SPEED_TIME</literal></emphasis> seconds, Git aborts that operation.
These values override the <literal>http.lowSpeedLimit</literal> and <literal>http.lowSpeedTime</literal> configuration values.</simpara>
<simpara><emphasis role="strong"><literal>GIT_HTTP_USER_AGENT</literal></emphasis> sets the user-agent string used by Git when communicating using HTTP.
The default is a value like <literal>git/2.0.0</literal>.</simpara>
</section>
<section xml:id="_diffing_and_merging">
<title>Diffing and Merging</title>
<simpara><emphasis role="strong"><literal>GIT_DIFF_OPTS</literal></emphasis> is a bit of a misnomer.
The only valid values are <literal>-u&lt;n&gt;</literal> or <literal>--unified=&lt;n&gt;</literal>, which control the number of context lines output by <literal>git diff</literal>.</simpara>
<simpara><emphasis role="strong"><literal>GIT_EXTERNAL_DIFF</literal></emphasis> is used to override the <literal>diff.external</literal> configuration value.
If set, Git invokes this program when <literal>git diff</literal> is invoked.</simpara>
<simpara><emphasis role="strong"><literal>GIT_DIFF_PATH_COUNTER</literal></emphasis> and <emphasis role="strong"><literal>GIT_DIFF_PATH_TOTAL</literal></emphasis> can be used by the program specified by <literal>GIT_EXTERNAL_DIFF</literal> or <literal>diff.external</literal>.
The former represents which file in a series is being diffed (starting with 1), and the latter is the total number of files in the series.</simpara>
<simpara><emphasis role="strong"><literal>GIT_MERGE_VERBOSITY</literal></emphasis> controls the output for the recursive merge strategy.
The allowed values are</simpara>
<itemizedlist>
<listitem>
<simpara>0 output nothing, except possibly a single error message.</simpara>
</listitem>
<listitem>
<simpara>1 show only conflicts.</simpara>
</listitem>
<listitem>
<simpara>2 also show file changes.</simpara>
</listitem>
<listitem>
<simpara>3 show when files are skipped because they haven&#8217;t changed.</simpara>
</listitem>
<listitem>
<simpara>4 show all paths as they&#8217;re processed.</simpara>
</listitem>
<listitem>
<simpara>5 and above show detailed debugging information.</simpara>
</listitem>
</itemizedlist>
<simpara>The default value is 2.</simpara>
</section>
<section xml:id="_debugging">
<title>Debugging</title>
<simpara>Want to know what Git is <emphasis>really</emphasis> up to?
Git has a fairly complete set of trace variables embedded that you can turn on as necessary.
The possible values of these variables are</simpara>
<itemizedlist>
<listitem>
<simpara><literal>true</literal>, <literal>1</literal>, or <literal>2</literal>&#8201;&#8212;&#8201;the trace category is written to stderr.</simpara>
</listitem>
<listitem>
<simpara>An absolute path starting with <literal>/</literal>&#8201;&#8212;&#8201;the trace output is written to that path.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong"><literal>GIT_TRACE</literal></emphasis> controls general traces, which don&#8217;t fit into any specific category.
This includes the expansion of aliases, and delegation to other sub-programs.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ GIT_TRACE=true git lga
20:12:49.877982 git.c:554               trace: exec: 'git-lga'
20:12:49.878369 run-command.c:341       trace: run_command: 'git-lga'
20:12:49.879529 git.c:282               trace: alias expansion: lga =&gt; 'log' '--graph' '--pretty=oneline' '--abbrev-commit' '--decorate' '--all'
20:12:49.879885 git.c:349               trace: built-in: git 'log' '--graph' '--pretty=oneline' '--abbrev-commit' '--decorate' '--all'
20:12:49.899217 run-command.c:341       trace: run_command: 'less'
20:12:49.899675 run-command.c:192       trace: exec: 'less'</programlisting>
<simpara><emphasis role="strong"><literal>GIT_TRACE_PACK_ACCESS</literal></emphasis> controls tracing of packfile access.
The first field is the packfile being accessed, the second is the offset within that file.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ GIT_TRACE_PACK_ACCESS=true git status
20:10:12.081397 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 12
20:10:12.081886 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 34662
20:10:12.082115 sha1_file.c:2088        .git/objects/pack/pack-c3fa...291e.pack 35175
# […]
20:10:12.087398 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 56914983
20:10:12.087419 sha1_file.c:2088        .git/objects/pack/pack-e80e...e3d2.pack 14303666
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean</programlisting>
<simpara><emphasis role="strong"><literal>GIT_TRACE_PACKET</literal></emphasis> enables packet-level tracing of network operations.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ GIT_TRACE_PACKET=true git ls-remote origin
20:15:14.867043 pkt-line.c:46           packet:          git&lt; # service=git-upload-pack
20:15:14.867071 pkt-line.c:46           packet:          git&lt; 0000
20:15:14.867079 pkt-line.c:46           packet:          git&lt; 97b8860c071898d9e162678ea1035a8ced2f8b1f HEAD\0multi_ack thin-pack side-band side-band-64k ofs-delta shallow no-progress include-tag multi_ack_detailed no-done symref=HEAD:refs/heads/master agent=git/2.0.4
20:15:14.867088 pkt-line.c:46           packet:          git&lt; 0f20ae29889d61f2e93ae00fd34f1cdb53285702 refs/heads/ab/add-interactive-show-diff-func-name
20:15:14.867094 pkt-line.c:46           packet:          git&lt; 36dc827bc9d17f80ed4f326de21247a5d1341fbc refs/heads/ah/doc-gitk-config
# […]</programlisting>
<simpara><emphasis role="strong"><literal>GIT_TRACE_PERFORMANCE</literal></emphasis> controls logging of performance data.
The output shows how long each particular Git invocation takes.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ GIT_TRACE_PERFORMANCE=true git gc
20:18:19.499676 trace.c:414             performance: 0.374835000 s: git command: 'git' 'pack-refs' '--all' '--prune'
20:18:19.845585 trace.c:414             performance: 0.343020000 s: git command: 'git' 'reflog' 'expire' '--all'
Counting objects: 170994, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (43413/43413), done.
Writing objects: 100% (170994/170994), done.
Total 170994 (delta 126176), reused 170524 (delta 125706)
20:18:23.567927 trace.c:414             performance: 3.715349000 s: git command: 'git' 'pack-objects' '--keep-true-parents' '--honor-pack-keep' '--non-empty' '--all' '--reflog' '--unpack-unreachable=2.weeks.ago' '--local' '--delta-base-offset' '.git/objects/pack/.tmp-49190-pack'
20:18:23.584728 trace.c:414             performance: 0.000910000 s: git command: 'git' 'prune-packed'
20:18:23.605218 trace.c:414             performance: 0.017972000 s: git command: 'git' 'update-server-info'
20:18:23.606342 trace.c:414             performance: 3.756312000 s: git command: 'git' 'repack' '-d' '-l' '-A' '--unpack-unreachable=2.weeks.ago'
Checking connectivity: 170994, done.
20:18:25.225424 trace.c:414             performance: 1.616423000 s: git command: 'git' 'prune' '--expire' '2.weeks.ago'
20:18:25.232403 trace.c:414             performance: 0.001051000 s: git command: 'git' 'rerere' 'gc'
20:18:25.233159 trace.c:414             performance: 6.112217000 s: git command: 'git' 'gc'</programlisting>
<simpara><emphasis role="strong"><literal>GIT_TRACE_SETUP</literal></emphasis> shows what Git is discovering about the repository and environment it&#8217;s interacting with.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ GIT_TRACE_SETUP=true git status
20:19:47.086765 trace.c:315             setup: git_dir: .git
20:19:47.087184 trace.c:316             setup: worktree: /Users/ben/src/git
20:19:47.087191 trace.c:317             setup: cwd: /Users/ben/src/git
20:19:47.087194 trace.c:318             setup: prefix: (null)
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean</programlisting>
</section>
<section xml:id="_miscellaneous">
<title>Miscellaneous</title>
<simpara><emphasis role="strong"><literal>GIT_SSH</literal></emphasis>, if specified, is a program that&#8217;s invoked instead of <literal>ssh</literal> when Git tries to connect to a host using SSH.
It&#8217;s invoked using the syntax <literal>$GIT_SSH [username@]host [-p &lt;port&gt;] &lt;command&gt;</literal>.
Note that this isn&#8217;t the easiest way to customize how <literal>ssh</literal> is invoked. It doesn&#8217;t support extra command-line parameters, so you&#8217;d have to write a wrapper script and set <literal>GIT_SSH</literal> to point to it.
It&#8217;s probably easier just to use the <literal>~/.ssh/config</literal> file for that.</simpara>
<simpara><emphasis role="strong"><literal>GIT_ASKPASS</literal></emphasis> overrides the <literal>core.askpass</literal> configuration value.
This is the program invoked whenever Git needs to prompt for credentials.
(See <xref linkend="_credential_caching"/> for more on this subsystem.)</simpara>
<simpara><emphasis role="strong"><literal>GIT_NAMESPACE</literal></emphasis> controls access to namespaced refs, and is equivalent to the <literal>--namespace</literal> flag.
This is mostly useful on the server side, where you might store multiple forks of a single repository in one repository, only keeping the refs separate.</simpara>
<simpara><emphasis role="strong"><literal>GIT_FLUSH</literal></emphasis> can be used to force Git to use non-buffered I/O when writing to stdout.
A value of 1 causes Git to flush more often, a value of 0 causes all output to be buffered.
The default value is to choose an appropriate buffering scheme depending on the activity and the output mode.</simpara>
<simpara><emphasis role="strong"><literal>GIT_REFLOG_ACTION</literal></emphasis> specifies the descriptive text written to the reflog.
Here&#8217;s an example:</simpara>
<programlisting language="console" linenumbering="unnumbered">$ GIT_REFLOG_ACTION="my action" git commit --allow-empty -m 'my message'
[master 9e3d55a] my message
$ git reflog -1
9e3d55a HEAD@{0}: my action: my message</programlisting>
</section>
</section>
<section xml:id="_summary_13">
<title>Summary</title>
<simpara>At this point, you should have a pretty good understanding of what Git does in the background and,
to some degree, how it&#8217;s implemented. This chapter has covered a number of plumbing commands&#8201;&#8212;&#8201;commands
that are lower level and simpler than the porcelain commands you&#8217;ve learned about in the rest of the book.
Understanding how Git works at a lower level should make it easier to understand why it does what it
does, and also to write your own tools and helper scripts to make your specific workflow work for you.</simpara>
<simpara>Git as a content-addressable filesystem is a very powerful tool that you can easily use as more than just a VCS.
We hope you can use your newfound knowledge of Git internals to implement your own cool application of
this technology and feel more comfortable using Git in more advanced ways.</simpara>
</section>
</chapter>
<appendix xml:id="A-git-in-other-environments">
<title>Git in Other Environments</title>
<simpara>If you read through the whole book, you&#8217;ve learned a lot about how to use Git at the command line.
You can work with local files, connect your repository to others over a network, and work effectively with
collaborators. But the story doesn&#8217;t end there. Git is usually used as part of a larger ecosystem, and the terminal
isn&#8217;t always the best way to work with it. Now we&#8217;ll take a look at some of the other kinds of environments
where Git can be useful, and how other applications work alongside Git.</simpara>
<section xml:id="_graphical_interfaces">
<title>Graphical Interfaces</title>
<simpara><indexterm>
<primary>GUIs</primary>
</indexterm><indexterm>
<primary>Graphical tools</primary>
</indexterm>
Git&#8217;s native environment is terminal-based.
New features show up there first, and only on the command line is the full power of Git completely at your disposal.
But a terminal interface isn&#8217;t the best choice for all tasks. Sometimes a graphical representation is what you need,
and some users are much more comfortable with a point-and-click interface.</simpara>
<simpara>It&#8217;s important to note that different interfaces are tailored for different workflows.
Some Git clients expose only a carefully curated subset of Git in order to support the creator&#8217;s favorite workflow.
When viewed in this light, none of these tools can be called <emphasis>better</emphasis> than any of the others. They&#8217;re simply
more fit for their intended purpose. Also note that there&#8217;s nothing these graphical clients can do that
command-line clients can&#8217;t. The command-line is still where you have the most power and control.</simpara>
<section xml:id="_literal_gitk_literal_and_literal_git_gui_literal">
<title><literal>gitk</literal> and <literal>git-gui</literal></title>
<simpara><indexterm>
<primary>git commands</primary><secondary>gitk</secondary>
</indexterm>
<indexterm>
<primary>gitk</primary>
</indexterm><indexterm>
<primary>git commands</primary><secondary>gui</secondary>
</indexterm>
<indexterm>
<primary>gui</primary>
</indexterm><indexterm>
<primary>gitk</primary>
</indexterm>
When you install Git, you also get two graphical tools, <literal>gitk</literal> and <literal>git-gui</literal>.</simpara>
<simpara><literal>gitk</literal> is a graphical history viewer.
Think of it like a powerful GUI shell over <literal>git log</literal> and <literal>git grep</literal>.
This is the tool to use when you&#8217;re trying to find something that happened in the past, or visualize your
project&#8217;s history.</simpara>
<simpara><literal>gitk</literal> is easy to invoke from the command-line. Just <literal>cd</literal> to a Git repository, and run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ gitk [git log options]</programlisting>
<simpara><literal>gitk</literal> accepts many command-line flags, most of which are passed through to the underlying <literal>git log</literal> command.
Probably one of the most useful is the <literal>--all</literal> flag, which tells <literal>gitk</literal> to show commits reachable from
<emphasis>any</emphasis> ref, not just <literal>HEAD</literal>. <literal>gitk</literal>'s interface looks like</simpara>
<figure>
<title>The <literal>gitk</literal> history viewer.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/gitk.png"/>
</imageobject>
<textobject><phrase>The `gitk` history viewer.</phrase></textobject>
</mediaobject>
</figure>
<simpara>On the top is something that looks a bit like the output of <literal>git log --graph</literal>. Each dot represents a commit,
the lines represent parent relationships, and refs are shown as colored boxes.
The yellow dot represents <literal>HEAD</literal>, and the red dot represents changes that are yet to be committed.
At the bottom is a view of the selected commit. The comments and diffs are on the left, and a summary view
is on the right. In between is a collection of controls used for searching history.</simpara>
<simpara><literal>git-gui</literal>, on the other hand, is primarily a tool for crafting commits.
It, too, is easy to invoke from the command line.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git gui</programlisting>
<simpara>And it looks something like</simpara>
<figure>
<title>The <literal>git-gui</literal> commit tool.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/git-gui.png"/>
</imageobject>
<textobject><phrase>The `git-gui` commit tool.</phrase></textobject>
</mediaobject>
</figure>
<simpara>On the left is the index, unstaged changes are on top, and staged changes on the bottom.
You can move entire files between the two states by clicking on their icons, or you can select a file for
viewing by clicking on its name.</simpara>
<simpara>At top right is the diff view, which shows the changes for the currently-selected file.
You can stage individual hunks (or individual lines) by right-clicking in this area.</simpara>
<simpara>At the bottom right is the message and action area. Type your message into the text box and click <literal>Commit</literal>
to do something similar to <literal>git commit</literal>. You can also choose to amend the last commit by choosing the <literal>Amend</literal>
radio button, which updates the <literal>Staged Changes</literal> area with the content of the last commit.
Then you can simply stage or unstage some changes, alter the commit message, and click <literal>Commit</literal> again
to replace the old commit with a new one.</simpara>
<simpara><literal>gitk</literal> and <literal>git-gui</literal> are examples of task-oriented tools.
Each of them is tailored for a specific purpose (viewing history and creating commits, respectively),
and omit features not necessary for that task.</simpara>
</section>
<section xml:id="_github_for_macs_and_windows">
<title>GitHub for Macs and Windows</title>
<simpara><indexterm>
<primary>GitHub for Mac</primary>
</indexterm><indexterm>
<primary>GitHub for Windows</primary>
</indexterm>
GitHub has created two workflow-oriented Git clients&#8201;&#8212;&#8201;one for Windows, and one for Macs.
These clients are a good example of workflow-oriented tools. Rather than expose <emphasis>all</emphasis> of Git&#8217;s functionality,
they instead focus on a curated set of commonly-used features that work well together. They look like</simpara>
<figure>
<title>GitHub for Macs.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/github_mac.png"/>
</imageobject>
<textobject><phrase>GitHub for Mac.</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>GitHub for Windows.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/github_win.png"/>
</imageobject>
<textobject><phrase>GitHub for Windows.</phrase></textobject>
</mediaobject>
</figure>
<simpara>They are designed to look and work very much alike, so we treat them like a single product.
We aren&#8217;t doing a detailed rundown of these tools (they have their own documentation), but a quick tour of
the <literal>changes</literal> view (which is where you spend most of your time) is in order.</simpara>
<itemizedlist>
<listitem>
<simpara>On the left is the list of repositories the client is tracking. You can add a repository (either by cloning or attaching locally) by clicking the <literal>+</literal> icon at the top of this area.</simpara>
</listitem>
<listitem>
<simpara>In the center is a commit-input area, where you enter a commit message, and select the files to be included.
(On Windows, the commit history is displayed directly below this. On a Mac, it&#8217;s on a separate tab.)</simpara>
</listitem>
<listitem>
<simpara>On the right is a diff view, which shows what&#8217;s changed in your working directory, or which changes were included in the selected commit.</simpara>
</listitem>
<listitem>
<simpara>The last thing to notice is the <literal>Sync</literal> button at the top-right, which is the primary way to interact over the network.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>You don&#8217;t need a GitHub account to use these tools.
While they&#8217;re designed to highlight GitHub&#8217;s service and recommended workflow, they happily work with any
repository, and can communicate with any Git server.</simpara>
</note>
<section xml:id="_installation_2">
<title>Installation</title>
<simpara>GitHub for Windows can be downloaded from <link xl:href="https://windows.github.com">https://windows.github.com</link>, and GitHub for Macs
from <link xl:href="https://mac.github.com">https://mac.github.com</link>. When the applications are first run, they walk you through the initial Git setup,
such as configuring your name and email address, and both set sane defaults for many common configuration options,
such as credential caches and CRLF behavior.</simpara>
<simpara>Both are <literal>evergreen</literal>&#8201;&#8212;&#8201;updates are downloaded and installed in the background while the applications are running.
This helpfully includes a bundled version of Git, which means you don&#8217;t have to worry about manually updating Git.
On Windows, the client includes a shortcut to launch Powershell with Posh-Git, which we talk more about later
in this chapter.</simpara>
<simpara>The next step is to give the tool some repositories to work with.
The client shows a list of the repositories you have access to on GitHub, and it can clone them in one step.
If you already have a local repository, just drag its directory from the Finder or Windows Explorer into
the GitHub client window, and it&#8217;s included in the list of repositories on the left.</simpara>
</section>
<section xml:id="_recommended_workflow">
<title>Recommended Workflow</title>
<simpara>Once it&#8217;s installed and configured, you can use the GitHub client for many common Git tasks.
Its intended workflow is sometimes called the <literal>GitHub Flow.</literal>
We cover this in more detail in <xref linkend="ch06-github_flow"/>, but the general gist is that (a) you commit to a branch,
and (b) you sync with a remote repository fairly regularly.</simpara>
<simpara>Branch management is one of the areas where the two tools diverge.
On Macs, there&#8217;s a button at the top of the window for creating a new branch.</simpara>
<figure>
<title><literal>Create Branch</literal> button on Macs.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/branch_widget_mac.png"/>
</imageobject>
<textobject><phrase>`Create Branch` button on Macs.</phrase></textobject>
</mediaobject>
</figure>
<simpara>On Windows, this is done by typing the new branch&#8217;s name in the branch-switching widget.</simpara>
<figure>
<title>Creating a branch on Windows.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/branch_widget_win.png"/>
</imageobject>
<textobject><phrase>Creating a branch on Windows.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Once your branch is created, making new commits is fairly straightforward.
Make some changes in your working directory, and when you switch to the GitHub client window, you see
which files changed. Enter a commit message, select the files you&#8217;d like to include, and click <literal>Commit</literal>.</simpara>
<simpara>The main way to interact with other repositories over the network is through the <literal>Sync</literal> feature.
Git internally has separate operations for pushing, fetching, merging, and rebasing, but the GitHub
clients collapse all of these into one multi-step feature. Here&#8217;s what happens when you click <literal>Sync</literal>.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>git pull --rebase</literal>.
If this fails because of a merge conflict, fall back to <literal>git pull --no-rebase</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>git push</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>This is the most common sequence of commands when working in this style, so squashing them into one command
saves a lot of time.</simpara>
</section>
<section xml:id="_summary_14">
<title>Summary</title>
<simpara>These tools are very well-suited for the workflow they&#8217;re designed for.
Developers and non-developers alike can be collaborating on a project within minutes, and many of the best
practices for this kind of workflow are baked into the tools. However, if your workflow is different,
or you want more control over how and when things are done, we recommend you use another client or the command line.</simpara>
</section>
</section>
<section xml:id="_other_guis">
<title>Other GUIs</title>
<simpara>There are a number of other graphical Git clients which run the gamut from specialized, single-purpose tools
all the way to apps that try to expose everything Git can do.
The official Git website has a curated list of the most popular clients at <link xl:href="http://git-scm.com/downloads/guis">http://git-scm.com/downloads/guis</link>.
A more comprehensive list is available on the Git wiki site, at
<link xl:href="https://git.wiki.kernel.org/index.php/Interfaces,_frontends,_and_tools#Graphical_Interfaces">https://git.wiki.kernel.org/index.php/Interfaces,_frontends,_and_tools#Graphical_Interfaces</link>.</simpara>
</section>
</section>
<section xml:id="_git_in_visual_studio">
<title>Git in Visual Studio</title>
<simpara><indexterm>
<primary>Visual Studio</primary>
</indexterm>
Starting with Visual Studio 2013 Update 1, Visual Studio users have a built-in Git client.
Visual Studio has had VCS integration features for quite some time, but they were oriented towards centralized,
file-locking systems. Git wasn&#8217;t a good match for this workflow. Visual Studio 2013&#8217;s Git support has been separated
from this older feature, and the result is a much better fit between Studio and Git.</simpara>
<simpara>To locate the feature, open a project that&#8217;s controlled by Git (or just <literal>git init</literal> an existing project),
and select View &gt; Team Explorer from the menu. You see the "Connect" view, which looks like</simpara>
<figure>
<title>Connecting to a Git repository from Team Explorer.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/vs-1.png"/>
</imageobject>
<textobject><phrase>Connecting to a Git repository from Team Explorer.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Visual Studio remembers all of the projects you&#8217;ve opened that are Git-controlled, and they&#8217;re available in the
list at the bottom. If you don&#8217;t see the one you want, click the <literal>Add</literal> link and enter the path to the project&#8217;s
working directory. Double clicking on one of the local Git repositories leads you to the <literal>Home</literal> view,
which looks like <xref linkend="vs_home"/>. This is a hub for performing Git actions. When you&#8217;re <emphasis>writing</emphasis> code,
you probably spend most of your time in the <literal>Changes</literal> view, but when it comes time to pull down changes
made by your teammates, use the <literal>Unsynced Commits</literal> and <literal>Branches</literal> views.</simpara>
<figure xml:id="vs_home">
<title>The <literal>Home</literal> view for a Git repository in Visual Studio.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/vs-2.png"/>
</imageobject>
<textobject><phrase>The Home view for a Git repository in Visual Studio.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Visual Studio now has a powerful task-focused UI for Git.
It includes a linear history view, a diff viewer, remote commands, and many other capabilities.
For complete documentation of this feature (which doesn&#8217;t fit here),
go to <link xl:href="http://msdn.microsoft.com/en-us/library/hh850437.aspx">http://msdn.microsoft.com/en-us/library/hh850437.aspx</link>.</simpara>
</section>
<section xml:id="_git_in_eclipse">
<title>Git in Eclipse</title>
<simpara><indexterm>
<primary>Eclipse</primary>
</indexterm>
Eclipse ships with a plugin called EGit, which provides a fairly-complete interface to Git.
It&#8217;s accessed by switching to the Git Perspective (Window &gt; Open Perspective &gt; Other…, and select "Git").</simpara>
<figure>
<title>Eclipse&#8217;s EGit environment.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/egit.png"/>
</imageobject>
<textobject><phrase>Eclipse&#8217;s EGit environment.</phrase></textobject>
</mediaobject>
</figure>
<simpara>EGit comes with plenty of great documentation, which you can find by going to Help &gt; Help Contents,
and choosing the "EGit Documentation" node from the content listing.</simpara>
</section>
<section xml:id="_git_in_bash">
<title>Git in Bash</title>
<simpara><indexterm>
<primary>bash</primary>
</indexterm><indexterm>
<primary>tab completion</primary><secondary>bash</secondary>
</indexterm>
<indexterm>
<primary>bash</primary>
</indexterm><indexterm>
<primary>shell prompts</primary><secondary>bash</secondary>
</indexterm>
<indexterm>
<primary>bash</primary>
</indexterm>
If you&#8217;re a Bash user, you can make use of some of its features to make your experience with Git a lot friendlier.
Git actually ships with plugins for several shells, but they&#8217;re not turned on by default.</simpara>
<simpara>First, get a copy of the <literal>contrib/completion/git-completion.bash</literal> file out of the Git source code.
Copy it somewhere handy, like your home directory, and add this to your <literal>.bashrc</literal>.</simpara>
<programlisting language="console" linenumbering="unnumbered">. ~/git-completion.bash</programlisting>
<simpara>Then, change your directory to a Git repository, and run</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git chec&lt;tab&gt;</programlisting>
<simpara>Bash auto-completes to <literal>git checkout</literal>.
This works with all of Git&#8217;s subcommands, command-line parameters, remotes, and ref names where appropriate.</simpara>
<simpara>It&#8217;s also useful to customize your prompt to show information about the current directory&#8217;s Git repository.
This can be as simple or complex as you want, but there are generally a few key pieces of information that most
people want to see, like the current branch, and the status of the working directory.
To add these to your prompt, just copy the <literal>contrib/completion/git-prompt.sh</literal> file from Git&#8217;s source
repository to your home directory, and add something like the following to your <literal>.bashrc</literal>:</simpara>
<programlisting language="console" linenumbering="unnumbered">. ~/git-prompt.sh
export GIT_PS1_SHOWDIRTYSTATE=1
export PS1='\w$(__git_ps1 " (%s)")\$ '</programlisting>
<simpara><literal>\w</literal> means print the current working directory, the <literal>\$</literal> prints the <literal>$</literal> part of the prompt,
and <literal>__git_ps1 " (%s)"</literal> calls the function provided by <literal>git-prompt.sh</literal> with a formatting argument.
Now your Bash prompt looks like this when you&#8217;re anywhere inside a Git-controlled project.</simpara>
<figure>
<title>Customized <literal>Bash</literal> prompt.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/git-bash.png"/>
</imageobject>
<textobject><phrase>Customized `Bash` prompt.</phrase></textobject>
</mediaobject>
</figure>
<simpara>Both of these scripts come with helpful documentation. Take a look at the content of <literal>git-completion.bash</literal>
and <literal>git-prompt.sh</literal> for more information.</simpara>
</section>
<section xml:id="_git_in_zsh">
<title>Git in Zsh</title>
<simpara><indexterm>
<primary>zsh</primary>
</indexterm><indexterm>
<primary>tab completion</primary><secondary>zsh</secondary>
</indexterm>
<indexterm>
<primary>zsh</primary>
</indexterm><indexterm>
<primary>shell prompts</primary><secondary>zsh</secondary>
</indexterm>
<indexterm>
<primary>zsh</primary>
</indexterm>
Zsh also includes a tab-completion library for Git.
To use it, simply run <literal>autoload -Uz compinit &amp;&amp; compinit</literal> in your <literal>.zshrc</literal>.
Zsh&#8217;s interface is a bit more powerful than Bash&#8217;s.</simpara>
<programlisting language="console" linenumbering="unnumbered">$ git che&lt;tab&gt;
check-attr        -- display gitattributes information
check-ref-format  -- ensure that a reference name is well formed
checkout          -- checkout branch or paths to working tree
checkout-index    -- copy files from index to working directory
cherry            -- find commits not merged upstream
cherry-pick       -- apply changes introduced by some existing commits</programlisting>
<simpara>Ambiguous tab-completions aren&#8217;t just listed&#8201;&#8212;&#8201;they have helpful descriptions, and you can graphically
navigate the list by repeatedly hitting tab. This works with Git commands, their arguments,
and names of things inside the repository (like refs and remotes), as well as filenames and
all the other things zsh knows how to tab-complete.</simpara>
<simpara>Zsh ships with a framework for getting information from version control systems called <literal>vcs_info</literal>.
To include the branch name on the right hand side of the prompt, add these lines to your <literal>~/.zshrc</literal> file.</simpara>
<programlisting language="console" linenumbering="unnumbered">autoload -Uz vcs_info
precmd_vcs_info() { vcs_info }
precmd_functions+=( precmd_vcs_info )
setopt prompt_subst
RPROMPT=\$vcs_info_msg_0_
# PROMPT=\$vcs_info_msg_0_'%# '
zstyle ':vcs_info:git:*' formats '%b'</programlisting>
<simpara>This results in a display of the current branch on the right-hand side of the terminal window,
whenever your shell is inside a Git repository.
(The left side is supported as well, of course; just uncomment the assignment to PROMPT.)</simpara>
<simpara>It looks a bit like</simpara>
<figure>
<title>Customized <literal>zsh</literal> prompt.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/zsh-prompt.png"/>
</imageobject>
<textobject><phrase>Customized `zsh` prompt.</phrase></textobject>
</mediaobject>
</figure>
<simpara>For more information on vcs_info, check out its documentation
in the <literal>zshcontrib(1)</literal> manual page, or online at <link xl:href="http://zsh.sourceforge.net/Doc/Release/User-Contributions.html#Version-Control-Information">http://zsh.sourceforge.net/Doc/Release/User-Contributions.html#Version-Control-Information</link>.</simpara>
<simpara>Instead of vcs_info, you might prefer the prompt customization script that ships with Git, called <literal>git-prompt.sh</literal>.
See <link xl:href="https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh">https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh</link> for details.
<literal>git-prompt.sh</literal> is compatible with both Bash and Zsh.</simpara>
<simpara>Zsh is powerful enough that there are entire frameworks dedicated to making it better.
One of them is called <literal>oh-my-zsh</literal>, and it can be found at <link xl:href="https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</link>.
<literal>oh-my-zsh</literal>'s plugin system comes with powerful Git tab-completion, and it has a variety of prompt "themes",
many of which display version-control data.
<xref linkend="oh_my_zsh_git"/> is just one example of what can be done with this system.</simpara>
<figure xml:id="oh_my_zsh_git">
<title>An example of an <literal>oh-my-zsh</literal> theme.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/zsh-oh-my.png"/>
</imageobject>
<textobject><phrase>An example of an `oh-my-zsh` theme.</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="_git_powershell">
<title>Git in Powershell</title>
<simpara><indexterm>
<primary>powershell</primary>
</indexterm><indexterm>
<primary>tab completion</primary><secondary>powershell</secondary>
</indexterm>
<indexterm>
<primary>powershell</primary>
</indexterm><indexterm>
<primary>shell prompts</primary><secondary>powershell</secondary>
</indexterm>
<indexterm>
<primary>powershell</primary>
</indexterm>
<indexterm>
<primary>posh-git</primary>
</indexterm>
The legacy command-line terminal on Windows (<literal>cmd.exe</literal>) isn&#8217;t really capable of a customized Git experience,
but if you&#8217;re using Powershell, you&#8217;re in luck.
This also works if you&#8217;re running PowerShell on a non-Windows platform like Debian.
A package called Posh-Git (<link xl:href="https://github.com/dahlbyk/posh-git">https://github.com/dahlbyk/posh-git</link>) provides powerful tab-completion facilities,
as well as an enhanced prompt to help you stay on top of your repository status. It looks like</simpara>
<figure>
<title>Powershell with Posh-git.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/posh-git.png"/>
</imageobject>
<textobject><phrase>Powershell with Posh-git.</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_installation_3">
<title>Installation</title>
<section xml:id="_prerequisites_windows_only">
<title>Prerequisites (Windows only)</title>
<simpara>Before you&#8217;re able to run PowerShell scripts on your machine, you need to set your local ExecutionPolicy to
RemoteSigned (Basically anything except Undefined and Restricted). If you choose AllSigned instead of RemoteSigned,
local scripts (your own) also need to be digitally signed in order to be executed. With RemoteSigned,
only Scripts having the "ZoneIdentifier" set to Internet (were downloaded from the web) need to be signed. Others don&#8217;t.
If you&#8217;re an administrator and want to set it for all Users on that machine, use "-Scope LocalMachine".
If you&#8217;re a normal user, without administrative rights, you can use "-Scope CurrentUser" to set it only for you.</simpara>
<simpara>More about PowerShell Scopes: <link xl:href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes</link></simpara>
<simpara>More about PowerShell ExecutionPolicy: <link xl:href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy</link></simpara>
<programlisting language="powershell" linenumbering="unnumbered">&gt; Set-ExecutionPolicy -Scope LocalMachine -ExecutionPolicy RemoteSigned -Force</programlisting>
</section>
<section xml:id="_powershell_gallery">
<title>PowerShell Gallery</title>
<simpara>If you have at least PowerShell 5 or PowerShell 4 with PackageManagement installed, you can use the package
manager to fetch Posh-Git.</simpara>
<simpara>More information about PowerShell Gallery: <link xl:href="https://docs.microsoft.com/en-us/powershell/gallery/overview">https://docs.microsoft.com/en-us/powershell/gallery/overview</link></simpara>
<programlisting language="powershell" linenumbering="unnumbered">&gt; Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
&gt; Update-Module PowerShellGet -Force
&gt; Install-Module Posh-Git -Scope AllUsers</programlisting>
<simpara>To install Posh-Git only for the current user and not globally, use "-Scope CurrentUser" instead.
If the second command fails with an error like <literal>Module 'PowerShellGet' was not installed by using Install-Module</literal>,
you&#8217;ll need to run another command first:</simpara>
<programlisting language="powershell" linenumbering="unnumbered">&gt; Install-Module PowerShellGet -Force -SkipPublisherCheck</programlisting>
<simpara>Then you can go back and try again.
This happens because the modules that ship with Windows Powershell are signed with a different
certificate.</simpara>
</section>
<section xml:id="_update_powershell_prompt">
<title>Update PowerShell Prompt</title>
<simpara>To include Git information in your prompt, Posh-Git needs to be imported. To do this automatically,
include the import statement into your $profile script. This script is executed everytime you open a new
PowerShell prompt. Keep in mind that there are multiple $profile scripts&#8201;&#8212;&#8201;one for the console and
a separate one for the ISE.</simpara>
<programlisting language="powershell" linenumbering="unnumbered">&gt; New-Item -Name $(Split-Path -Path $profile) -ItemType Directory -Force
&gt; 'Import-Module Posh-Git' | Out-File -Append -Encoding default -FilePath $profile</programlisting>
</section>
<section xml:id="_from_source">
<title>From Source</title>
<simpara>Just download the Posh-Git release from (<link xl:href="https://github.com/dahlbyk/posh-git">https://github.com/dahlbyk/posh-git</link>), and uncompress it to the
<literal>WindowsPowershell</literal> directory. Then open Powershell as an administrator, and run</simpara>
<programlisting language="powershell" linenumbering="unnumbered">&gt; cd ~\Documents\WindowsPowerShell\Module\posh-git
&gt; .\install.ps1</programlisting>
<simpara>This adds the proper line to your <literal>profile.ps1</literal> file, and Posh-Git runs the next time you start PowerShell.</simpara>
</section>
</section>
</section>
<section xml:id="_summary_15">
<title>Summary</title>
<simpara>You&#8217;ve learned how to harness Git&#8217;s power from inside the tools that you use during your everyday work,
and also how to access Git repositories from your own programs.</simpara>
</section>
</appendix>
<appendix xml:id="B-embedding-git-in-your-applications">
<title>Embedding Git in your Applications</title>
<simpara>If your application is for developers, chances are good that it could benefit from source control integration.
Even non-developer applications, such as document editors, could potentially benefit from version-control features,
and Git&#8217;s model works very well for many different scenarios.</simpara>
<simpara>To integrate Git with your application, you have essentially two options&#8201;&#8212;&#8201;spawn a shell and call the
<literal>git</literal> command-line program, or embed a Git library into your application.
Here we cover command-line integration and several of the most popular embeddable Git libraries.</simpara>
<section xml:id="_command_line_git">
<title>Command-line Git</title>
<simpara>One option is to spawn a shell process and use the <literal>git</literal> command-line tool to do the work.
This has the benefit of being canonical, and all of Git&#8217;s features are supported.
This also happens to be fairly easy, as most runtime environments have a relatively simple facility for invoking
a process with command-line arguments. However, this approach does have some downsides.</simpara>
<simpara>One is that all the output is in plain text.
This means that you have to parse Git&#8217;s occasionally-changing output format to read progress and result information,
which can be inefficient and error-prone.</simpara>
<simpara>Another is the lack of error recovery. If a repository is corrupted somehow, or the user has a incorrect
configuration value, Git simply refuses to perform many operations.</simpara>
<simpara>Yet another is process management.
Git requires you to maintain a shell environment in a separate process, which can add unwanted complexity.
Trying to coordinate many of these processes (especially when potentially accessing the same repository
from several processes) can be quite a challenge.</simpara>
</section>
<section xml:id="_libgit2">
<title>Libgit2</title>
<simpara><indexterm>
<primary>libgit2</primary>
</indexterm><indexterm>
<primary>C</primary>
</indexterm>
Another option at your disposal is Libgit2
which is a dependency-free implementation of Git, with a focus on having a nice API for use within other programs.
You can find it at <link xl:href="http://libgit2.github.com">http://libgit2.github.com</link>.</simpara>
<simpara>First, let&#8217;s take a look at what the C API looks like.
Here&#8217;s a whirlwind tour.</simpara>
<programlisting language="c" linenumbering="unnumbered">// Open a repository
git_repository *repo;
int error = git_repository_open(&amp;repo, "/path/to/repository");

// Dereference HEAD to a commit
git_object *head_commit;
error = git_revparse_single(&amp;head_commit, repo, "HEAD^{commit}");
git_commit *commit = (git_commit*)head_commit;

// Print some of the commit's properties
printf("%s", git_commit_message(commit));
const git_signature *author = git_commit_author(commit);
printf("%s &lt;%s&gt;\n", author-&gt;name, author-&gt;email);
const git_oid *tree_id = git_commit_tree_id(commit);

// Cleanup
git_commit_free(commit);
git_repository_free(repo);</programlisting>
<simpara>The first couple of lines open a Git repository.
The <literal>git_repository</literal> type represents a handle to a repository with a cache in memory.
This is the simplest method, for when you know the exact path of a repository&#8217;s working directory or <literal>.git</literal> folder.
There&#8217;s also <literal>git_repository_open_ext</literal> which includes options for searching, <literal>git_clone</literal> and friends for
making a local clone of a remote repository, and <literal>git_repository_init</literal> for creating an entirely new repository.</simpara>
<simpara>The second chunk of code uses rev-parse syntax (see <xref linkend="_branch_references"/> for more on this)
to get the commit that <literal>HEAD</literal> eventually points to. The type returned is a <literal>git_object</literal> pointer,
which represents something that exists in the Git object database for a repository.
<literal>git_object</literal> is actually a "parent" type for several different kinds of objects. The memory layout
for each of the "child" types is the same as for <literal>git_object</literal>, so you can safely cast to the right one.
In this case, <literal>git_object_type(commit)</literal> would return <literal>GIT_OBJ_COMMIT</literal>, so it&#8217;s safe to cast to a <literal>git_commit</literal> pointer.</simpara>
<simpara>The next chunk shows how to access the commit&#8217;s properties.
The last line here uses a <literal>git_oid</literal> type. This is Libgit2&#8217;s representation of an SHA-1 hash.</simpara>
<simpara>From this sample, a couple of patterns emerge.</simpara>
<itemizedlist>
<listitem>
<simpara>If you declare a pointer and pass a reference to it into a Libgit2 call, that call will probably return an integer error code.
A <literal>0</literal> value indicates success. Anything less is an error.</simpara>
</listitem>
<listitem>
<simpara>If Libgit2 populates a pointer for you, you&#8217;re responsible for freeing it.</simpara>
</listitem>
<listitem>
<simpara>If Libgit2 returns a <literal>const</literal> pointer from a call, you don&#8217;t have to free it, but it will become invalid when the object it belongs to is freed.</simpara>
</listitem>
<listitem>
<simpara>Writing C is a bit painful.</simpara>
</listitem>
</itemizedlist>
<simpara><indexterm>
<primary>Ruby</primary>
</indexterm>
That last pattern means it isn&#8217;t very probable that you&#8217;ll be writing C when using Libgit2.
Fortunately, there are a number of language-specific bindings available that make it fairly easy to work with
Git repositories from your specific language and environment.
Let&#8217;s take a look at the above example written using the Ruby bindings for Libgit2, which is named Rugged,
and can be found at <link xl:href="https://github.com/libgit2/rugged">https://github.com/libgit2/rugged</link>.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">repo = Rugged::Repository.new('path/to/repository')
commit = repo.head.target
puts commit.message
puts "#{commit.author[:name]} &lt;#{commit.author[:email]}&gt;"
tree = commit.tree</programlisting>
<simpara>As you can see, the code is much less cluttered.
First, Rugged uses exceptions. It can raise things like <literal>ConfigError</literal> or <literal>ObjectError</literal> to signal error conditions.
Second, there&#8217;s no explicit freeing of resources, since Ruby is garbage-collected.
Let&#8217;s take a look at a slightly more complicated example&#8201;&#8212;&#8201;crafting a commit from scratch.</simpara>
<programlisting language="ruby" linenumbering="unnumbered">blob_id = repo.write("Blob contents", :blob) <co xml:id="CO7-1"/>

index = repo.index
index.read_tree(repo.head.target.tree)
index.add(:path =&gt; 'newfile.txt', :oid =&gt; blob_id) <co xml:id="CO7-2"/>

sig = {
    :email =&gt; "bob@example.com",
    :name =&gt; "Bob User",
    :time =&gt; Time.now,
}

commit_id = Rugged::Commit.create(repo,
    :tree =&gt; index.write_tree(repo), <co xml:id="CO7-3"/>
    :author =&gt; sig,
    :committer =&gt; sig, <co xml:id="CO7-4"/>
    :message =&gt; "Add newfile.txt", <co xml:id="CO7-5"/>
    :parents =&gt; repo.empty? ? [] : [ repo.head.target ].compact, <co xml:id="CO7-6"/>
    :update_ref =&gt; 'HEAD', <co xml:id="CO7-7"/>
)
commit = repo.lookup(commit_id) <co xml:id="CO7-8"/></programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>Create a new blob, which contains the contents of a new file.</para>
</callout>
<callout arearefs="CO7-2">
<para>Populate the index with the head commit&#8217;s tree, and add the new file at the path <literal>newfile.txt</literal>.</para>
</callout>
<callout arearefs="CO7-3">
<para>This creates a new tree in the ODB, and uses it for the new commit.</para>
</callout>
<callout arearefs="CO7-4">
<para>We use the same signature for both the author and committer fields.</para>
</callout>
<callout arearefs="CO7-5">
<para>The commit message.</para>
</callout>
<callout arearefs="CO7-6">
<para>When creating a commit, you have to specify the new commit&#8217;s parents.
This uses the tip of <literal>HEAD</literal> for the single parent.</para>
</callout>
<callout arearefs="CO7-7">
<para>Rugged (and Libgit2) can optionally update a reference when making a commit.</para>
</callout>
<callout arearefs="CO7-8">
<para>The return value is the SHA-1 hash of a new commit object, which you can then use to get a <literal>Commit</literal> object.</para>
</callout>
</calloutlist>
<simpara>The Ruby code is nice and clean, but since Libgit2 is doing the heavy lifting, this code will run pretty fast, too.
If you&#8217;re not a rubyist, we touch on some other bindings in <xref linkend="_libgit2_bindings"/>.</simpara>
<section xml:id="_advanced_functionality">
<title>Advanced Functionality</title>
<simpara>Libgit2 has a couple of capabilities that are outside the scope of core Git.
One example is pluggability. Libgit2 allows you to provide custom "backends" for several types of operation,
so you can store things in a different way than stock Git does.
Libgit2 allows custom backends for configuration, ref storage, and the object database, among other things.</simpara>
<simpara>Let&#8217;s take a look at how this works.
The code below is borrowed from the set of backend examples provided by the Libgit2 team
(which can be found at <link xl:href="https://github.com/libgit2/libgit2-backends">https://github.com/libgit2/libgit2-backends</link>).
Here&#8217;s how a custom backend for the object database is set up.</simpara>
<programlisting language="c" linenumbering="unnumbered">git_odb *odb;
int error = git_odb_new(&amp;odb); <co xml:id="CO8-1"/>

git_odb_backend *my_backend;
error = git_odb_backend_mine(&amp;my_backend, /*…*/); <co xml:id="CO8-2"/>

error = git_odb_add_backend(odb, my_backend, 1); <co xml:id="CO8-3"/>

git_repository *repo;
error = git_repository_open(&amp;repo, "some-path");
error = git_repository_set_odb(odb); <co xml:id="CO8-4"/></programlisting>
<simpara><emphasis>(Note that errors are captured, but not handled. We hope your code is better than ours.)</emphasis></simpara>
<calloutlist>
<callout arearefs="CO8-1">
<para>Initialize an empty object database (ODB) &#8220;frontend,&#8221; which will act as a container for the &#8220;backends&#8221; which are the ones doing the real work.</para>
</callout>
<callout arearefs="CO8-2">
<para>Initialize a custom ODB backend.</para>
</callout>
<callout arearefs="CO8-3">
<para>Add the backend to the frontend.</para>
</callout>
<callout arearefs="CO8-4">
<para>Open a repository, and set it to use our ODB to look up objects.</para>
</callout>
</calloutlist>
<simpara>But what&#8217;s this <literal>git_odb_backend_mine</literal> thing?
Well, that&#8217;s the constructor for your own ODB implementation, and you can do whatever you want in there,
as long as you fill in the <literal>git_odb_backend</literal> structure properly. Here&#8217;s what it <emphasis>could</emphasis> look like.</simpara>
<programlisting language="c" linenumbering="unnumbered">typedef struct {
    git_odb_backend parent;

    // Some other stuff
    void *custom_context;
} my_backend_struct;

int git_odb_backend_mine(git_odb_backend **backend_out, /*…*/)
{
    my_backend_struct *backend;

    backend = calloc(1, sizeof (my_backend_struct));

    backend-&gt;custom_context = …;

    backend-&gt;parent.read = &amp;my_backend__read;
    backend-&gt;parent.read_prefix = &amp;my_backend__read_prefix;
    backend-&gt;parent.read_header = &amp;my_backend__read_header;
    // …

    *backend_out = (git_odb_backend *) backend;

    return GIT_SUCCESS;
}</programlisting>
<simpara>The subtlest constraint here is that <literal>my_backend_struct</literal>'s first member must be a <literal>git_odb_backend</literal> structure.
This ensures that the memory layout is what the Libgit2 code expects it to be.
The rest of it is arbitrary. This structure can be as large or small as you need it to be.</simpara>
<simpara>The initialization function allocates some memory for the structure, sets up the custom context,
and then fills in the members of the <literal>parent</literal> structure that it supports.
Take a look at the <literal>include/git2/sys/odb_backend.h</literal> file in the Libgit2 source for a complete set of call signatures.
Your particular use case will help determine which of these you&#8217;ll want to support.</simpara>
</section>
<section xml:id="_libgit2_bindings">
<title>Other Bindings</title>
<simpara>Libgit2 has bindings for many languages.
Here we show a small example using a few of the more complete bindings packages as of this writing.
Libraries exist for many other languages, including C++, Go, Node.js, Erlang, and the JVM, all in
various stages of maturity.
The official collection of bindings can be found by browsing the repositories at <link xl:href="https://github.com/libgit2">https://github.com/libgit2</link>.
The code we write returns the commit message from the commit eventually pointed to by <literal>HEAD</literal> (sort of like <literal>git log -1</literal>).</simpara>
<section xml:id="_libgit3sharp">
<title>LibGit3Sharp</title>
<simpara><indexterm>
<primary>.NET</primary>
</indexterm><indexterm>
<primary>C#</primary>
</indexterm><indexterm>
<primary>Mono</primary>
</indexterm>
If you&#8217;re writing a .NET or Mono application, LibGit2Sharp (<link xl:href="https://github.com/libgit2/libgit2sharp">https://github.com/libgit2/libgit2sharp</link>) is
what you&#8217;re looking for. The bindings are written in C#, and great care has been taken to wrap the raw Libgit2
calls with native-feeling CLR APIs. Here&#8217;s our example program.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">new Repository(@"C:\path\to\repo").Head.Tip.Message;</programlisting>
<simpara>For desktop Windows applications, there&#8217;s even a NuGet package that will help you get started quickly.</simpara>
</section>
<section xml:id="_objective_git">
<title>objective-git</title>
<simpara><indexterm>
<primary>Apple</primary>
</indexterm><indexterm>
<primary>Objective-C</primary>
</indexterm><indexterm>
<primary>Cocoa</primary>
</indexterm>
If your application is running on an Apple platform, you&#8217;re likely using Objective-C as your implementation language.
Objective-Git (<link xl:href="https://github.com/libgit2/objective-git">https://github.com/libgit2/objective-git</link>) is the name of the Libgit2 bindings for that environment.
The example program looks like</simpara>
<programlisting language="objc" linenumbering="unnumbered">GTRepository *repo =
    [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: @"/path/to/repo"] error:NULL];
NSString *msg = [[[repo headReferenceWithError:NULL] resolvedTarget] message];</programlisting>
<simpara>Objective-git is fully interoperable with Swift, so don&#8217;t fear if you&#8217;ve left Objective-C behind.</simpara>
</section>
<section xml:id="_pygit2">
<title>pygit2</title>
<simpara><indexterm>
<primary>Python</primary>
</indexterm>
The bindings for Libgit2 in Python are called Pygit2, and can be found at <link xl:href="http://www.pygit2.org/">http://www.pygit2.org/</link>.
Here&#8217;s an example program.</simpara>
<programlisting language="python" linenumbering="unnumbered">pygit2.Repository("/path/to/repo") # open repository
    .head                          # get the current branch
    .peel(pygit2.Commit)           # walk down to the commit
    .message                       # read the message</programlisting>
</section>
</section>
<section xml:id="_further_reading">
<title>Further Reading</title>
<simpara>Of course, a full treatment of Libgit2&#8217;s capabilities is outside the scope of this book.
For more information on Libgit2 itself, there&#8217;s API documentation at <link xl:href="https://libgit2.github.com/libgit2">https://libgit2.github.com/libgit2</link>,
and a set of guides at <link xl:href="https://libgit2.github.com/docs">https://libgit2.github.com/docs</link>.
For the other bindings, check the bundled README and tests. There are often small tutorials and pointers to
further reading there.</simpara>
</section>
</section>
<section xml:id="_jgit">
<title>JGit</title>
<simpara><indexterm>
<primary>jgit</primary>
</indexterm><indexterm>
<primary>Java</primary>
</indexterm>
To use Git in a Java program, there&#8217;s a fully featured Git library called JGit.
JGit is a relatively full-featured implementation of Git written natively in Java, and is widely used in the
Java community. The JGit project is under the Eclipse umbrella, and its home is <link xl:href="http://www.eclipse.org/jgit">http://www.eclipse.org/jgit</link>.</simpara>
<section xml:id="_getting_set_up">
<title>Getting Set Up</title>
<simpara>There are a number of ways to connect your project with JGit.
Probably the easiest is to use Maven. The integration is accomplished by adding the following snippet
to the <literal>&lt;dependencies&gt;</literal> tag in your pom.xml file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt;
    &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt;
    &lt;version&gt;3.5.0.201409260305-r&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>The <literal>version</literal> number will most likely have advanced by the time you read this.
Check <link xl:href="http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit">http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit</link> for updated repository information.
Once this step is done, Maven automatically acquires and uses the JGit libraries you need.</simpara>
<simpara>If you&#8217;d rather manage the binary dependencies yourself, pre-built JGit binaries are available
from <link xl:href="http://www.eclipse.org/jgit/download">http://www.eclipse.org/jgit/download</link>.
You can build them into your project by running a command like</simpara>
<programlisting language="console" linenumbering="unnumbered">javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java
java -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App</programlisting>
</section>
<section xml:id="_plumbing">
<title>Plumbing</title>
<simpara>JGit has two basic levels of API&#8201;&#8212;&#8201;plumbing and porcelain.
The terminology for these comes from Git itself, and JGit is divided similarly.
Porcelain APIs are a friendly front-end for common user-level actions (the sorts of things a normal
user would use the Git command-line tool for), while the plumbing APIs are for interacting with low-level
repository objects directly.</simpara>
<simpara>The starting point for most JGit sessions is the <literal>Repository</literal> class, and the first thing to do is to create
an instance of it. For a filesystem-based repository (yes, JGit allows for other storage models),
this is accomplished using <literal>FileRepositoryBuilder</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">// Create a new repository
Repository newlyCreatedRepo = FileRepositoryBuilder.create(
    new File("/tmp/new_repo/.git"));
newlyCreatedRepo.create();

// Open an existing repository
Repository existingRepo = new FileRepositoryBuilder()
    .setGitDir(new File("my_repo/.git"))
    .build();</programlisting>
<simpara>The builder has a fluent API for providing all the things it needs to find a Git repository,
whether or not your program knows exactly where it&#8217;s located. It can use environment variables (<literal>.readEnvironment()</literal>),
start from a place in the working directory and search (<literal>.setWorkTree(…).findGitDir()</literal>),
or just open a known <literal>.git</literal> directory as above.</simpara>
<simpara>Once you have a <literal>Repository</literal> instance, you can do all sorts of things with it. Here&#8217;s a quick sample.</simpara>
<programlisting language="java" linenumbering="unnumbered">// Get a reference
Ref master = repo.getRef("master");

// Get the object the reference points to
ObjectId masterTip = master.getObjectId();

// Rev-parse
ObjectId obj = repo.resolve("HEAD^{tree}");

// Load raw object contents
ObjectLoader loader = repo.open(masterTip);
loader.copyTo(System.out);

// Create a branch
RefUpdate createBranch1 = repo.updateRef("refs/heads/branch1");
createBranch1.setNewObjectId(masterTip);
createBranch1.update();

// Delete a branch
RefUpdate deleteBranch1 = repo.updateRef("refs/heads/branch1");
deleteBranch1.setForceUpdate(true);
deleteBranch1.delete();

// Config
Config cfg = repo.getConfig();
String name = cfg.getString("user", null, "name");</programlisting>
<simpara>There&#8217;s quite a bit going on here, so let&#8217;s go through it one section at a time.</simpara>
<simpara>The first line gets a pointer to the <literal>master</literal> reference.
JGit automatically grabs the <emphasis>actual</emphasis> master ref, which lives at <literal>refs/heads/master</literal>, and returns an
object that lets you fetch information about the reference.
You can get the name (<literal>.getName()</literal>), and either the target object of a direct reference (<literal>.getObjectId()</literal>)
or the reference pointed to by a symbolic ref (<literal>.getTarget()</literal>).
Ref objects are also used to represent tag refs and objects, so you can ask if the tag is <literal>peeled</literal>, meaning
that it points to the final target of a (potentially long) string of tag objects.</simpara>
<simpara>The second line gets the target of the <literal>master</literal> reference, which is returned as an ObjectId instance.
ObjectId represents the SHA-1 hash of an object, which might or might not exist in the repository.
The third line is similar, but shows how JGit handles the rev-parse syntax (for more on this,
see <xref linkend="_branch_references"/>). You can pass any object specifier that Git understands,
and JGit will return either a valid ObjectId for that object, or <literal>null</literal>.</simpara>
<simpara>The next two lines show how to load the raw contents of an object.
In this example, we call <literal>ObjectLoader.copyTo()</literal> to stream the contents of the object directly to stdout,
but ObjectLoader also has methods to read the type and size of an object, as well as return it as a byte array.
For large objects (where <literal>.isLarge()</literal> returns <literal>true</literal>), you can call <literal>.openStream()</literal> to get an InputStream-like
object that can read the raw object data without pulling it all into memory at once.</simpara>
<simpara>The next few lines show what it takes to create a new branch.
We create a RefUpdate instance, configure some parameters, and call <literal>.update()</literal> to trigger the change.
Directly following this is the code to delete that same branch.
Note that <literal>.setForceUpdate(true)</literal> is required for this to work, otherwise the <literal>.delete()</literal> call will
return <literal>REJECTED</literal>, and nothing will happen.</simpara>
<simpara>The last example shows how to fetch the <literal>user.name</literal> value from the Git configuration files.
This Config instance uses the repository we opened earlier for local configuration,
but will automatically detect the global and system configuration files and read values from them as well.</simpara>
<simpara>This is only a small sampling of the full plumbing API. There are many more methods and classes available.
Also not shown here is how JGit handles errors, which is through the use of exceptions.
JGit APIs sometimes throw standard Java exceptions (such as <literal>IOException</literal>), but there are a host
of JGit-specific exception types that are provided as well (such as <literal>NoRemoteRepositoryException</literal>,
<literal>CorruptObjectException</literal>, and <literal>NoMergeBaseException</literal>).</simpara>
</section>
<section xml:id="_porcelain">
<title>Porcelain</title>
<simpara>The plumbing APIs are rather complete, but it can be cumbersome to string them together to achieve common tasks,
like adding a file to the index, or making a new commit. JGit provides a higher-level set of APIs to help out with
this, and the entry point to these APIs is the <literal>Git</literal> class.</simpara>
<programlisting language="java" linenumbering="unnumbered">Repository repo;
// construct repo...
Git git = new Git(repo);</programlisting>
<simpara>The Git class has a nice set of high-level <emphasis>builder</emphasis>-style methods that can be used to construct some pretty
complex behavior. Let&#8217;s take a look at an example&#8201;&#8212;&#8201;running something like <literal>git ls-remote</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">CredentialsProvider cp = new UsernamePasswordCredentialsProvider("username", "p4ssw0rd");
Collection&lt;Ref&gt; remoteRefs = git.lsRemote()
    .setCredentialsProvider(cp)
    .setRemote("origin")
    .setTags(true)
    .setHeads(false)
    .call();
for (Ref ref : remoteRefs) {
    System.out.println(ref.getName() + " -&gt; " + ref.getObjectId().name());
}</programlisting>
<simpara>This is a common pattern with the Git class. The methods return a command object that lets you chain
method calls to set parameters, which are executed when you call <literal>.call()</literal>.
In this case, we&#8217;re asking the <literal>origin</literal> remote for tags, but not heads.
Also notice the use of a <literal>CredentialsProvider</literal> object for authentication.</simpara>
<simpara>Many other commands are available through the Git class including, but not limited to, <literal>add</literal>, <literal>blame</literal>,
<literal>commit</literal>, <literal>clean</literal>, <literal>push</literal>, <literal>rebase</literal>, <literal>revert</literal>, and <literal>reset</literal>.</simpara>
</section>
<section xml:id="_further_reading_2">
<title>Further Reading</title>
<simpara>This is only a small sampling of JGit&#8217;s full capabilities.
To learn more, here&#8217;s where to look for information and inspiration:</simpara>
<itemizedlist>
<listitem>
<simpara>The official JGit API documentation can be found at <link xl:href="http://www.eclipse.org/jgit/documentation/">http://www.eclipse.org/jgit/documentation/</link>.
These are in standard Javadoc, so your favorite JVM IDE will be able to install them locally, as well.</simpara>
</listitem>
<listitem>
<simpara>The JGit Cookbook at <link xl:href="https://github.com/centic9/jgit-cookbook">https://github.com/centic9/jgit-cookbook</link> has many examples of how to do specific tasks with JGit.</simpara>
</listitem>
<listitem>
<simpara>There are several good resources mentioned at <link xl:href="http://stackoverflow.com/questions/6861881">http://stackoverflow.com/questions/6861881</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_go_git">
<title>go-git</title>
<simpara><indexterm>
<primary>go-git</primary>
</indexterm><indexterm>
<primary>Go</primary>
</indexterm>
To integrate Git into a service written in Golang, there&#8217;s a pure Go library implementation.
This implementation doesn&#8217;t have any native dependencies and thus isn&#8217;t prone to manual memory management errors.
It&#8217;s also transparent to the standard Golang performance analysis tools like CPU, Memory profilers, race detector,
etc.</simpara>
<simpara>go-git is focused on extensibility and compatibility, and supports most of the plumbing APIs, which are
documented at <link xl:href="https://github.com/src-d/go-git/blob/master/COMPATIBILITY.md">https://github.com/src-d/go-git/blob/master/COMPATIBILITY.md</link>.</simpara>
<simpara>Here&#8217;s a basic example of using Go APIs.</simpara>
<programlisting language="go" linenumbering="unnumbered">import 	"gopkg.in/src-d/go-git.v4"

r, err := git.PlainClone("/tmp/foo", false, &amp;git.CloneOptions{
    URL:      "https://github.com/src-d/go-git",
    Progress: os.Stdout,
})</programlisting>
<simpara>As soon as you have a <literal>Repository</literal> instance, you can access information and perform mutations on it.</simpara>
<programlisting language="go" linenumbering="unnumbered">// retrieves the branch pointed by HEAD
ref, err := r.Head()

// get the commit object, pointed by ref
commit, err := r.CommitObject(ref.Hash())

// retrieves the commit history
history, err := commit.History()

// iterates over the commits and print each
for _, c := range history {
    fmt.Println(c)
}</programlisting>
<section xml:id="_advanced_functionality_2">
<title>Advanced Functionality</title>
<simpara>go-git has few notable advanced features, one of which is a pluggable storage system,
which is similar to Libgit2 backends. The default implementation is in-memory storage, which is very fast.</simpara>
<programlisting language="go" linenumbering="unnumbered">r, err := git.Clone(memory.NewStorage(), nil, &amp;git.CloneOptions{
    URL: "https://github.com/src-d/go-git",
})</programlisting>
<simpara>Pluggable storage provides many interesting options. For instance,
<link xl:href="https://github.com/src-d/go-git/tree/master/_examples/storage">https://github.com/src-d/go-git/tree/master/_examples/storage</link> allows you to store references, objects,
and configuration in an Aerospike database.</simpara>
<simpara>Another feature is a flexible filesystem abstraction.
Using <link xl:href="https://godoc.org/github.com/src-d/go-billy#Filesystem">https://godoc.org/github.com/src-d/go-billy#Filesystem</link> it&#8217;s easy to store all the files in different way,
i.e by packing all of them into a single archive on disk or by keeping them all in-memory.</simpara>
<simpara>Another advanced use-case includes a fine-tunable HTTP client, such as the one found at
<link xl:href="https://github.com/src-d/go-git/blob/master/_examples/custom_http/main.go">https://github.com/src-d/go-git/blob/master/_examples/custom_http/main.go</link>.</simpara>
<programlisting language="go" linenumbering="unnumbered">customClient := &amp;http.Client{
	Transport: &amp;http.Transport{ // accept any certificate (might be useful for testing)
		TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},
	},
	Timeout: 15 * time.Second,  // 15 second timeout
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
		return http.ErrUseLastResponse // don't follow redirect
	},
}

// Override http(s) default protocol to use our custom client
client.InstallProtocol("https", githttp.NewClient(customClient))

// Clone repository using the new client if the protocol is https://
r, err := git.Clone(memory.NewStorage(), nil, &amp;git.CloneOptions{URL: url})</programlisting>
</section>
<section xml:id="_further_reading_3">
<title>Further Reading</title>
<simpara>A full treatment of go-git&#8217;s capabilities is outside the scope of this book.
For more information on go-git, there&#8217;s API documentation at <link xl:href="https://godoc.org/gopkg.in/src-d/go-git.v4">https://godoc.org/gopkg.in/src-d/go-git.v4</link>,
and a set of usage examples at <link xl:href="https://github.com/src-d/go-git/tree/master/_examples">https://github.com/src-d/go-git/tree/master/_examples</link>.</simpara>
</section>
</section>
<section xml:id="_dulwich">
<title>Dulwich</title>
<simpara><indexterm>
<primary>Dulwich</primary>
</indexterm><indexterm>
<primary>Python</primary>
</indexterm>
There is also a pure-Python Git implementation called Dulwich.
The project is hosted at <link xl:href="https://www.dulwich.io/">https://www.dulwich.io/</link> .
It aims to provide an interface to Git repositories, both local and remote, that doesn&#8217;t run Git directly
but instead uses pure Python. It has an optional C extension which significantly improves performance.</simpara>
<simpara>Dulwich follows Git design by separating two basic levels of API&#8201;&#8212;&#8201;plumbing and porcelain.</simpara>
<simpara>Here&#8217;s an example of using the lower level API to access the commit message of the last commit.</simpara>
<programlisting language="python" linenumbering="unnumbered">from dulwich.repo import Repo
r = Repo('.')
r.head()
# '57fbe010446356833a6ad1600059d80b1e731e15'

c = r[r.head()]
c
# &lt;Commit 015fc1267258458901a94d228e39f0a378370466&gt;

c.message
# 'Add note about encoding.\n'</programlisting>
<simpara>To print a commit log using the high-level porcelain API, run</simpara>
<programlisting language="python" linenumbering="unnumbered">from dulwich import porcelain
porcelain.log('.', max_entries=1)

#commit: 57fbe010446356833a6ad1600059d80b1e731e15
#Author: Jelmer Vernooĳ &lt;jelmer@jelmer.uk&gt;
#Date:   Sat Apr 29 2017 23:57:34 +0000</programlisting>
<section xml:id="_further_reading_4">
<title>Further Reading</title>
<itemizedlist>
<listitem>
<simpara>The official API documentation is available at <link xl:href="https://www.dulwich.io/apidocs/dulwich.html">https://www.dulwich.io/apidocs/dulwich.html</link></simpara>
</listitem>
<listitem>
<simpara>Official tutorial at <link xl:href="https://www.dulwich.io/docs/tutorial">https://www.dulwich.io/docs/tutorial</link> has many examples of how to do specific tasks with Dulwich</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</appendix>
<index xml:id="_index">
<title>Index</title>

</index>
</book>